var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
import http from "http";
import https from "https";
import zlib from "zlib";
import Stream, { PassThrough, pipeline } from "stream";
import { types } from "util";
import { randomBytes } from "crypto";
import { format } from "url";
function dataUriToBuffer(uri2) {
  if (!/^data:/i.test(uri2)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri2 = uri2.replace(/\r?\n/g, "");
  const firstComma = uri2.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri2.substring(5, firstComma).split(";");
  let charset3 = "";
  let base64 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset3 = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset3.length) {
    typeFull += ";charset=US-ASCII";
    charset3 = "US-ASCII";
  }
  const encoding3 = base64 ? "base64" : "ascii";
  const data = unescape(uri2.substring(firstComma + 1));
  const buffer2 = Buffer.from(data, encoding3);
  buffer2.type = type;
  buffer2.typeFull = typeFull;
  buffer2.charset = charset3;
  return buffer2;
}
async function* read(parts) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else {
      yield part;
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name2, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name2}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name2, value] of form) {
    yield getHeader(boundary, name2, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name2, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name2, value));
    if (isBlob(value)) {
      length += value.size;
    } else {
      length += Buffer.byteLength(String(value));
    }
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof Stream)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const err = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(err);
        throw err;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    if (error3 instanceof FetchBaseError) {
      throw error3;
    } else {
      throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    }
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name2, value]) => {
    try {
      validateHeaderName(name2);
      validateHeaderValue(name2, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch2(url, options_) {
  return new Promise((resolve3, reject) => {
    const request = new Request2(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = src(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve3(response2);
      return;
    }
    const send2 = (options2.protocol === "https:" ? https : http).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof Stream.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send2(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (err) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      finalize();
    });
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (error3) {
                reject(error3);
              }
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve3(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
        }
      }
      response_.once("end", () => {
        if (signal) {
          signal.removeEventListener("abort", abortAndFinalize);
        }
      });
      let body = pipeline(response_, new PassThrough(), (error3) => {
        reject(error3);
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve3(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pipeline(body, zlib.createGunzip(zlibOptions), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve3(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pipeline(response_, new PassThrough(), (error3) => {
          reject(error3);
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pipeline(body, zlib.createInflate(), (error3) => {
              reject(error3);
            });
          } else {
            body = pipeline(body, zlib.createInflateRaw(), (error3) => {
              reject(error3);
            });
          }
          response = new Response2(body, responseOptions);
          resolve3(response);
        });
        return;
      }
      if (codings === "br") {
        body = pipeline(body, zlib.createBrotliDecompress(), (error3) => {
          reject(error3);
        });
        response = new Response2(body, responseOptions);
        resolve3(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve3(response);
    });
    writeToStream(request_, request);
  });
}
var src, Readable, wm, Blob, fetchBlob, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, INTERNALS, isRequest, Request2, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    src = dataUriToBuffer;
    ({ Readable } = Stream);
    wm = new WeakMap();
    Blob = class {
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let buffer2;
          if (element instanceof Buffer) {
            buffer2 = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer2 = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer2 = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer2 = element;
          } else {
            buffer2 = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer2.length || buffer2.size || 0;
          return buffer2;
        });
        const type = options2.type === void 0 ? "" : String(options2.type).toLowerCase();
        wm.set(this, {
          type: /[^\u0020-\u007E]/.test(type) ? "" : type,
          size,
          parts
        });
      }
      get size() {
        return wm.get(this).size;
      }
      get type() {
        return wm.get(this).type;
      }
      async text() {
        return Buffer.from(await this.arrayBuffer()).toString();
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of this.stream()) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        return Readable.from(read(wm.get(this).parts));
      }
      slice(start = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = wm.get(this).parts.values();
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            const chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            blobParts.push(chunk);
            added += ArrayBuffer.isView(chunk) ? chunk.byteLength : chunk.size;
            relativeStart = 0;
            if (added >= span) {
              break;
            }
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        Object.assign(wm.get(blob), { size: span, parts: blobParts });
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.stream === "function" && object.stream.length === 0 && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    fetchBlob = Blob;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && object[NAME] === "AbortSignal";
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => randomBytes(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof Stream)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = Stream.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof Stream) {
          body.on("error", (err) => {
            const error3 = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
            this[INTERNALS$2].error = error3;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer: buffer2, byteOffset, byteLength } = await consumeBody(this);
        return buffer2.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new fetchBlob([buf], {
          type: ct
        });
      }
      async json() {
        const buffer2 = await consumeBody(this);
        return JSON.parse(buffer2.toString());
      }
      async text() {
        const buffer2 = await consumeBody(this);
        return buffer2.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance2, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance2;
      if (instance2.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough({ highWaterMark });
        p2 = new PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance2[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof Stream) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name2) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name2)) {
        const err = new TypeError(`Header name must be a valid HTTP token [${name2}]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw err;
      }
    };
    validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name2, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const err = new TypeError(`Invalid character in header content ["${name2}"]`);
        Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" });
        throw err;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers2) {
          const raw = init2.raw();
          for (const [name2, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name2, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name2, value]) => {
          validateHeaderName(name2);
          validateHeaderValue(name2, String(value));
          return [String(name2).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name2, value) => {
                  validateHeaderName(name2);
                  validateHeaderValue(name2, String(value));
                  return URLSearchParams.prototype[p].call(receiver, String(name2).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name2) => {
                  validateHeaderName(name2);
                  return URLSearchParams.prototype[p].call(receiver, String(name2).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name2) {
        const values = this.getAll(name2);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name2)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback) {
        for (const name2 of this.keys()) {
          callback(this.get(name2), name2);
        }
      }
      *values() {
        for (const name2 of this.keys()) {
          yield this.get(name2);
        }
      }
      *entries() {
        for (const name2 of this.keys()) {
          yield [name2, this.get(name2)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status2 = options2.status || 200;
        const headers = new Headers2(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: options2.url,
          status: status2,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status2 = 302) {
        if (!isRedirect(status2)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status: status2
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request2 = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers2(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal !== null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
    globalThis.fetch = fetch2;
    globalThis.Response = Response2;
    globalThis.Request = Request2;
    globalThis.Headers = Headers2;
  }
});

// node_modules/@sveltejs/adapter-node/files/shims.js
import { createRequire } from "module";
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-node/files/shims.js"() {
    init_install_fetch();
    Object.defineProperty(globalThis, "require", {
      enumerable: true,
      value: createRequire(import.meta.url)
    });
  }
});

// node_modules/bson/lib/bson/map.js
var require_map = __commonJS({
  "node_modules/bson/lib/bson/map.js"(exports2, module2) {
    init_shims();
    "use strict";
    if (typeof global.Map !== "undefined") {
      module2.exports = global.Map;
      module2.exports.Map = global.Map;
    } else {
      Map2 = function(array) {
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null)
            continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
        }
      };
      Map2.prototype.clear = function() {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function(key) {
        var value = this._values[key];
        if (value == null)
          return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? [key, self2._values[key].v] : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.forEach = function(callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function(key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function(key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Map2.prototype.set = function(key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = { v: value, i: this._keys.length - 1 };
        return this;
      };
      Map2.prototype.values = function() {
        var self2 = this;
        var index2 = 0;
        return {
          next: function() {
            var key = self2._keys[index2++];
            return {
              value: key !== void 0 ? self2._values[key].v : void 0,
              done: key !== void 0 ? false : true
            };
          }
        };
      };
      Object.defineProperty(Map2.prototype, "size", {
        enumerable: true,
        get: function() {
          return this._keys.length;
        }
      });
      module2.exports = Map2;
      module2.exports.Map = Map2;
    }
    var Map2;
  }
});

// node_modules/bson/lib/bson/long.js
var require_long = __commonJS({
  "node_modules/bson/lib/bson/long.js"(exports2, module2) {
    init_shims();
    function Long2(low, high) {
      if (!(this instanceof Long2))
        return new Long2(low, high);
      this._bsontype = "Long";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Long2.prototype.toInt = function() {
      return this.low_;
    };
    Long2.prototype.toNumber = function() {
      return this.high_ * Long2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Long2.prototype.toBigInt = function() {
      return BigInt(this.toString());
    };
    Long2.prototype.toJSON = function() {
      return this.toString();
    };
    Long2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix);
          var div = this.div(radixLong);
          var rem = div.multiply(radixLong).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Long2.prototype.getHighBits = function() {
      return this.high_;
    };
    Long2.prototype.getLowBits = function() {
      return this.low_;
    };
    Long2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Long2.TWO_PWR_32_DBL_ + this.low_;
    };
    Long2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Long2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Long2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Long2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Long2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Long2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Long2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Long2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Long2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Long2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Long2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Long2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Long2.prototype.negate = function() {
      if (this.equals(Long2.MIN_VALUE)) {
        return Long2.MIN_VALUE;
      } else {
        return this.not().add(Long2.ONE);
      }
    };
    Long2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Long2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Long2.ZERO;
      } else if (other.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        return other.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      } else if (other.equals(Long2.MIN_VALUE)) {
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Long2.TWO_PWR_24_) && other.lessThan(Long2.TWO_PWR_24_)) {
        return Long2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Long2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Long2.ZERO;
      }
      if (this.equals(Long2.MIN_VALUE)) {
        if (other.equals(Long2.ONE) || other.equals(Long2.NEG_ONE)) {
          return Long2.MIN_VALUE;
        } else if (other.equals(Long2.MIN_VALUE)) {
          return Long2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Long2.ZERO)) {
            return other.isNegative() ? Long2.ONE : Long2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Long2.MIN_VALUE)) {
        return Long2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Long2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Long2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Long2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Long2.prototype.not = function() {
      return Long2.fromBits(~this.low_, ~this.high_);
    };
    Long2.prototype.and = function(other) {
      return Long2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Long2.prototype.or = function(other) {
      return Long2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Long2.prototype.xor = function(other) {
      return Long2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Long2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Long2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Long2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Long2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Long2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Long2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Long2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Long2.fromBits(high, 0);
        } else {
          return Long2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Long2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Long2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Long2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Long2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Long2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Long2.ZERO;
      } else if (value <= -Long2.TWO_PWR_63_DBL_) {
        return Long2.MIN_VALUE;
      } else if (value + 1 >= Long2.TWO_PWR_63_DBL_) {
        return Long2.MAX_VALUE;
      } else if (value < 0) {
        return Long2.fromNumber(-value).negate();
      } else {
        return new Long2(value % Long2.TWO_PWR_32_DBL_ | 0, value / Long2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Long2.fromBigInt = function(value) {
      return Long2.fromString(value.toString(10), 10);
    };
    Long2.fromBits = function(lowBits, highBits) {
      return new Long2(lowBits, highBits);
    };
    Long2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Long2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Long2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      return result;
    };
    Long2.INT_CACHE_ = {};
    Long2.TWO_PWR_16_DBL_ = 1 << 16;
    Long2.TWO_PWR_24_DBL_ = 1 << 24;
    Long2.TWO_PWR_32_DBL_ = Long2.TWO_PWR_16_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_31_DBL_ = Long2.TWO_PWR_32_DBL_ / 2;
    Long2.TWO_PWR_48_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_16_DBL_;
    Long2.TWO_PWR_64_DBL_ = Long2.TWO_PWR_32_DBL_ * Long2.TWO_PWR_32_DBL_;
    Long2.TWO_PWR_63_DBL_ = Long2.TWO_PWR_64_DBL_ / 2;
    Long2.ZERO = Long2.fromInt(0);
    Long2.ONE = Long2.fromInt(1);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0);
    Long2.TWO_PWR_24_ = Long2.fromInt(1 << 24);
    module2.exports = Long2;
    module2.exports.Long = Long2;
  }
});

// node_modules/bson/lib/bson/double.js
var require_double = __commonJS({
  "node_modules/bson/lib/bson/double.js"(exports2, module2) {
    init_shims();
    function Double2(value) {
      if (!(this instanceof Double2))
        return new Double2(value);
      this._bsontype = "Double";
      this.value = value;
    }
    Double2.prototype.valueOf = function() {
      return this.value;
    };
    Double2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Double2;
    module2.exports.Double = Double2;
  }
});

// node_modules/bson/lib/bson/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/bson/lib/bson/timestamp.js"(exports2, module2) {
    init_shims();
    function Timestamp2(low, high) {
      if (!(this instanceof Timestamp2))
        return new Timestamp2(low, high);
      this._bsontype = "Timestamp";
      this.low_ = low | 0;
      this.high_ = high | 0;
    }
    Timestamp2.prototype.toInt = function() {
      return this.low_;
    };
    Timestamp2.prototype.toNumber = function() {
      return this.high_ * Timestamp2.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
    };
    Timestamp2.prototype.toJSON = function() {
      return this.toString();
    };
    Timestamp2.prototype.toString = function(opt_radix) {
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (this.isZero()) {
        return "0";
      }
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          var radixTimestamp = Timestamp2.fromNumber(radix);
          var div = this.div(radixTimestamp);
          var rem = div.multiply(radixTimestamp).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return "-" + this.negate().toString(radix);
        }
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = "";
      while (!rem.isZero()) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = "0" + digits;
          }
          result = "" + digits + result;
        }
      }
    };
    Timestamp2.prototype.getHighBits = function() {
      return this.high_;
    };
    Timestamp2.prototype.getLowBits = function() {
      return this.low_;
    };
    Timestamp2.prototype.getLowBitsUnsigned = function() {
      return this.low_ >= 0 ? this.low_ : Timestamp2.TWO_PWR_32_DBL_ + this.low_;
    };
    Timestamp2.prototype.getNumBitsAbs = function() {
      if (this.isNegative()) {
        if (this.equals(Timestamp2.MIN_VALUE)) {
          return 64;
        } else {
          return this.negate().getNumBitsAbs();
        }
      } else {
        var val = this.high_ !== 0 ? this.high_ : this.low_;
        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) !== 0) {
            break;
          }
        }
        return this.high_ !== 0 ? bit + 33 : bit + 1;
      }
    };
    Timestamp2.prototype.isZero = function() {
      return this.high_ === 0 && this.low_ === 0;
    };
    Timestamp2.prototype.isNegative = function() {
      return this.high_ < 0;
    };
    Timestamp2.prototype.isOdd = function() {
      return (this.low_ & 1) === 1;
    };
    Timestamp2.prototype.equals = function(other) {
      return this.high_ === other.high_ && this.low_ === other.low_;
    };
    Timestamp2.prototype.notEquals = function(other) {
      return this.high_ !== other.high_ || this.low_ !== other.low_;
    };
    Timestamp2.prototype.lessThan = function(other) {
      return this.compare(other) < 0;
    };
    Timestamp2.prototype.lessThanOrEqual = function(other) {
      return this.compare(other) <= 0;
    };
    Timestamp2.prototype.greaterThan = function(other) {
      return this.compare(other) > 0;
    };
    Timestamp2.prototype.greaterThanOrEqual = function(other) {
      return this.compare(other) >= 0;
    };
    Timestamp2.prototype.compare = function(other) {
      if (this.equals(other)) {
        return 0;
      }
      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) {
        return -1;
      }
      if (!thisNeg && otherNeg) {
        return 1;
      }
      if (this.subtract(other).isNegative()) {
        return -1;
      } else {
        return 1;
      }
    };
    Timestamp2.prototype.negate = function() {
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.MIN_VALUE;
      } else {
        return this.not().add(Timestamp2.ONE);
      }
    };
    Timestamp2.prototype.add = function(other) {
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.subtract = function(other) {
      return this.add(other.negate());
    };
    Timestamp2.prototype.multiply = function(other) {
      if (this.isZero()) {
        return Timestamp2.ZERO;
      } else if (other.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        return other.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return this.isOdd() ? Timestamp2.MIN_VALUE : Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().multiply(other.negate());
        } else {
          return this.negate().multiply(other).negate();
        }
      } else if (other.isNegative()) {
        return this.multiply(other.negate()).negate();
      }
      if (this.lessThan(Timestamp2.TWO_PWR_24_) && other.lessThan(Timestamp2.TWO_PWR_24_)) {
        return Timestamp2.fromNumber(this.toNumber() * other.toNumber());
      }
      var a48 = this.high_ >>> 16;
      var a32 = this.high_ & 65535;
      var a16 = this.low_ >>> 16;
      var a00 = this.low_ & 65535;
      var b48 = other.high_ >>> 16;
      var b32 = other.high_ & 65535;
      var b16 = other.low_ >>> 16;
      var b00 = other.low_ & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Timestamp2.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    };
    Timestamp2.prototype.div = function(other) {
      if (other.isZero()) {
        throw Error("division by zero");
      } else if (this.isZero()) {
        return Timestamp2.ZERO;
      }
      if (this.equals(Timestamp2.MIN_VALUE)) {
        if (other.equals(Timestamp2.ONE) || other.equals(Timestamp2.NEG_ONE)) {
          return Timestamp2.MIN_VALUE;
        } else if (other.equals(Timestamp2.MIN_VALUE)) {
          return Timestamp2.ONE;
        } else {
          var halfThis = this.shiftRight(1);
          var approx = halfThis.div(other).shiftLeft(1);
          if (approx.equals(Timestamp2.ZERO)) {
            return other.isNegative() ? Timestamp2.ONE : Timestamp2.NEG_ONE;
          } else {
            var rem = this.subtract(other.multiply(approx));
            var result = approx.add(rem.div(other));
            return result;
          }
        }
      } else if (other.equals(Timestamp2.MIN_VALUE)) {
        return Timestamp2.ZERO;
      }
      if (this.isNegative()) {
        if (other.isNegative()) {
          return this.negate().div(other.negate());
        } else {
          return this.negate().div(other).negate();
        }
      } else if (other.isNegative()) {
        return this.div(other.negate()).negate();
      }
      var res = Timestamp2.ZERO;
      rem = this;
      while (rem.greaterThanOrEqual(other)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Timestamp2.fromNumber(approx);
        var approxRem = approxRes.multiply(other);
        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Timestamp2.fromNumber(approx);
          approxRem = approxRes.multiply(other);
        }
        if (approxRes.isZero()) {
          approxRes = Timestamp2.ONE;
        }
        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }
      return res;
    };
    Timestamp2.prototype.modulo = function(other) {
      return this.subtract(this.div(other).multiply(other));
    };
    Timestamp2.prototype.not = function() {
      return Timestamp2.fromBits(~this.low_, ~this.high_);
    };
    Timestamp2.prototype.and = function(other) {
      return Timestamp2.fromBits(this.low_ & other.low_, this.high_ & other.high_);
    };
    Timestamp2.prototype.or = function(other) {
      return Timestamp2.fromBits(this.low_ | other.low_, this.high_ | other.high_);
    };
    Timestamp2.prototype.xor = function(other) {
      return Timestamp2.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
    };
    Timestamp2.prototype.shiftLeft = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var low = this.low_;
        if (numBits < 32) {
          var high = this.high_;
          return Timestamp2.fromBits(low << numBits, high << numBits | low >>> 32 - numBits);
        } else {
          return Timestamp2.fromBits(0, low << numBits - 32);
        }
      }
    };
    Timestamp2.prototype.shiftRight = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >> numBits);
        } else {
          return Timestamp2.fromBits(high >> numBits - 32, high >= 0 ? 0 : -1);
        }
      }
    };
    Timestamp2.prototype.shiftRightUnsigned = function(numBits) {
      numBits &= 63;
      if (numBits === 0) {
        return this;
      } else {
        var high = this.high_;
        if (numBits < 32) {
          var low = this.low_;
          return Timestamp2.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits);
        } else if (numBits === 32) {
          return Timestamp2.fromBits(high, 0);
        } else {
          return Timestamp2.fromBits(high >>> numBits - 32, 0);
        }
      }
    };
    Timestamp2.fromInt = function(value) {
      if (-128 <= value && value < 128) {
        var cachedObj = Timestamp2.INT_CACHE_[value];
        if (cachedObj) {
          return cachedObj;
        }
      }
      var obj = new Timestamp2(value | 0, value < 0 ? -1 : 0);
      if (-128 <= value && value < 128) {
        Timestamp2.INT_CACHE_[value] = obj;
      }
      return obj;
    };
    Timestamp2.fromNumber = function(value) {
      if (isNaN(value) || !isFinite(value)) {
        return Timestamp2.ZERO;
      } else if (value <= -Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MIN_VALUE;
      } else if (value + 1 >= Timestamp2.TWO_PWR_63_DBL_) {
        return Timestamp2.MAX_VALUE;
      } else if (value < 0) {
        return Timestamp2.fromNumber(-value).negate();
      } else {
        return new Timestamp2(value % Timestamp2.TWO_PWR_32_DBL_ | 0, value / Timestamp2.TWO_PWR_32_DBL_ | 0);
      }
    };
    Timestamp2.fromBits = function(lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function(str, opt_radix) {
      if (str.length === 0) {
        throw Error("number format error: empty string");
      }
      var radix = opt_radix || 10;
      if (radix < 2 || 36 < radix) {
        throw Error("radix out of range: " + radix);
      }
      if (str.charAt(0) === "-") {
        return Timestamp2.fromString(str.substring(1), radix).negate();
      } else if (str.indexOf("-") >= 0) {
        throw Error('number format error: interior "-" character: ' + str);
      }
      var radixToPower = Timestamp2.fromNumber(Math.pow(radix, 8));
      var result = Timestamp2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Timestamp2.fromNumber(Math.pow(radix, size));
          result = result.multiply(power).add(Timestamp2.fromNumber(value));
        } else {
          result = result.multiply(radixToPower);
          result = result.add(Timestamp2.fromNumber(value));
        }
      }
      return result;
    };
    Timestamp2.INT_CACHE_ = {};
    Timestamp2.TWO_PWR_16_DBL_ = 1 << 16;
    Timestamp2.TWO_PWR_24_DBL_ = 1 << 24;
    Timestamp2.TWO_PWR_32_DBL_ = Timestamp2.TWO_PWR_16_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_31_DBL_ = Timestamp2.TWO_PWR_32_DBL_ / 2;
    Timestamp2.TWO_PWR_48_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_16_DBL_;
    Timestamp2.TWO_PWR_64_DBL_ = Timestamp2.TWO_PWR_32_DBL_ * Timestamp2.TWO_PWR_32_DBL_;
    Timestamp2.TWO_PWR_63_DBL_ = Timestamp2.TWO_PWR_64_DBL_ / 2;
    Timestamp2.ZERO = Timestamp2.fromInt(0);
    Timestamp2.ONE = Timestamp2.fromInt(1);
    Timestamp2.NEG_ONE = Timestamp2.fromInt(-1);
    Timestamp2.MAX_VALUE = Timestamp2.fromBits(4294967295 | 0, 2147483647 | 0);
    Timestamp2.MIN_VALUE = Timestamp2.fromBits(0, 2147483648 | 0);
    Timestamp2.TWO_PWR_24_ = Timestamp2.fromInt(1 << 24);
    module2.exports = Timestamp2;
    module2.exports.Timestamp = Timestamp2;
  }
});

// node_modules/bson/lib/bson/parser/utils.js
var require_utils = __commonJS({
  "node_modules/bson/lib/bson/parser/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    function normalizedFunctionString(fn) {
      return fn.toString().replace(/function *\(/, "function (");
    }
    function newBuffer(item, encoding3) {
      return new Buffer(item, encoding3);
    }
    function allocBuffer() {
      return Buffer.alloc.apply(Buffer, arguments);
    }
    function toBuffer2() {
      return Buffer.from.apply(Buffer, arguments);
    }
    module2.exports = {
      normalizedFunctionString,
      allocBuffer: typeof Buffer.alloc === "function" ? allocBuffer : newBuffer,
      toBuffer: typeof Buffer.from === "function" ? toBuffer2 : newBuffer
    };
  }
});

// node_modules/bson/lib/bson/objectid.js
var require_objectid = __commonJS({
  "node_modules/bson/lib/bson/objectid.js"(exports2, module2) {
    init_shims();
    var inspect = "inspect";
    var utils2 = require_utils();
    var MACHINE_ID = parseInt(Math.random() * 16777215, 10);
    var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
    try {
      if (Buffer && Buffer.from) {
        hasBufferType = true;
        inspect = __require("util").inspect.custom || "inspect";
      }
    } catch (err) {
      hasBufferType = false;
    }
    var hasBufferType;
    var ObjectID2 = function ObjectID3(id) {
      if (id instanceof ObjectID3)
        return id;
      if (!(this instanceof ObjectID3))
        return new ObjectID3(id);
      this._bsontype = "ObjectID";
      if (id == null || typeof id === "number") {
        this.id = this.generate(id);
        if (ObjectID3.cacheHexString)
          this.__id = this.toString("hex");
        return;
      }
      var valid = ObjectID3.isValid(id);
      if (!valid && id != null) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      } else if (valid && typeof id === "string" && id.length === 24 && hasBufferType) {
        return new ObjectID3(utils2.toBuffer(id, "hex"));
      } else if (valid && typeof id === "string" && id.length === 24) {
        return ObjectID3.createFromHexString(id);
      } else if (id != null && id.length === 12) {
        this.id = id;
      } else if (id != null && typeof id.toHexString === "function") {
        return id;
      } else {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (ObjectID3.cacheHexString)
        this.__id = this.toString("hex");
    };
    var hexTable = [];
    for (var i = 0; i < 256; i++) {
      hexTable[i] = (i <= 15 ? "0" : "") + i.toString(16);
    }
    ObjectID2.prototype.toHexString = function() {
      if (ObjectID2.cacheHexString && this.__id)
        return this.__id;
      var hexString = "";
      if (!this.id || !this.id.length) {
        throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
      }
      if (this.id instanceof _Buffer) {
        hexString = convertToHex(this.id);
        if (ObjectID2.cacheHexString)
          this.__id = hexString;
        return hexString;
      }
      for (var i2 = 0; i2 < this.id.length; i2++) {
        hexString += hexTable[this.id.charCodeAt(i2)];
      }
      if (ObjectID2.cacheHexString)
        this.__id = hexString;
      return hexString;
    };
    ObjectID2.prototype.get_inc = function() {
      return ObjectID2.index = (ObjectID2.index + 1) % 16777215;
    };
    ObjectID2.prototype.getInc = function() {
      return this.get_inc();
    };
    ObjectID2.prototype.generate = function(time) {
      if (typeof time !== "number") {
        time = ~~(Date.now() / 1e3);
      }
      var pid = (typeof process === "undefined" || process.pid === 1 ? Math.floor(Math.random() * 1e5) : process.pid) % 65535;
      var inc = this.get_inc();
      var buffer2 = utils2.allocBuffer(12);
      buffer2[3] = time & 255;
      buffer2[2] = time >> 8 & 255;
      buffer2[1] = time >> 16 & 255;
      buffer2[0] = time >> 24 & 255;
      buffer2[6] = MACHINE_ID & 255;
      buffer2[5] = MACHINE_ID >> 8 & 255;
      buffer2[4] = MACHINE_ID >> 16 & 255;
      buffer2[8] = pid & 255;
      buffer2[7] = pid >> 8 & 255;
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    };
    ObjectID2.prototype.toString = function(format3) {
      if (this.id && this.id.copy) {
        return this.id.toString(typeof format3 === "string" ? format3 : "hex");
      }
      return this.toHexString();
    };
    ObjectID2.prototype[inspect] = ObjectID2.prototype.toString;
    ObjectID2.prototype.toJSON = function() {
      return this.toHexString();
    };
    ObjectID2.prototype.equals = function equals(otherId) {
      if (otherId instanceof ObjectID2) {
        return this.toString() === otherId.toString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
        return otherId === this.id.toString("binary");
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      } else if (typeof otherId === "string" && ObjectID2.isValid(otherId) && otherId.length === 12) {
        return otherId === this.id;
      } else if (otherId != null && (otherId instanceof ObjectID2 || otherId.toHexString)) {
        return otherId.toHexString() === this.toHexString();
      } else {
        return false;
      }
    };
    ObjectID2.prototype.getTimestamp = function() {
      var timestamp = new Date();
      var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectID2.index = ~~(Math.random() * 16777215);
    ObjectID2.createPk = function createPk() {
      return new ObjectID2();
    };
    ObjectID2.createFromTime = function createFromTime(time) {
      var buffer2 = utils2.toBuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer2[3] = time & 255;
      buffer2[2] = time >> 8 & 255;
      buffer2[1] = time >> 16 & 255;
      buffer2[0] = time >> 24 & 255;
      return new ObjectID2(buffer2);
    };
    var decodeLookup = [];
    i = 0;
    while (i < 10)
      decodeLookup[48 + i] = i++;
    while (i < 16)
      decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
    var _Buffer = Buffer;
    var convertToHex = function(bytes2) {
      return bytes2.toString("hex");
    };
    ObjectID2.createFromHexString = function createFromHexString(string) {
      if (typeof string === "undefined" || string != null && string.length !== 24) {
        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
      }
      if (hasBufferType)
        return new ObjectID2(utils2.toBuffer(string, "hex"));
      var array = new _Buffer(12);
      var n = 0;
      var i2 = 0;
      while (i2 < 24) {
        array[n++] = decodeLookup[string.charCodeAt(i2++)] << 4 | decodeLookup[string.charCodeAt(i2++)];
      }
      return new ObjectID2(array);
    };
    ObjectID2.isValid = function isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "number") {
        return true;
      }
      if (typeof id === "string") {
        return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
      }
      if (id instanceof ObjectID2) {
        return true;
      }
      if (id instanceof _Buffer) {
        return true;
      }
      if (typeof id.toHexString === "function" && (id.id instanceof _Buffer || typeof id.id === "string")) {
        return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
      }
      return false;
    };
    Object.defineProperty(ObjectID2.prototype, "generationTime", {
      enumerable: true,
      get: function() {
        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
      },
      set: function(value) {
        this.id[3] = value & 255;
        this.id[2] = value >> 8 & 255;
        this.id[1] = value >> 16 & 255;
        this.id[0] = value >> 24 & 255;
      }
    });
    module2.exports = ObjectID2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.ObjectId = ObjectID2;
  }
});

// node_modules/bson/lib/bson/regexp.js
var require_regexp = __commonJS({
  "node_modules/bson/lib/bson/regexp.js"(exports2, module2) {
    init_shims();
    function BSONRegExp2(pattern, options2) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2();
      this._bsontype = "BSONRegExp";
      this.pattern = pattern || "";
      this.options = options2 || "";
      for (var i = 0; i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new Error("the regular expression options [" + this.options[i] + "] is not supported");
        }
      }
    }
    module2.exports = BSONRegExp2;
    module2.exports.BSONRegExp = BSONRegExp2;
  }
});

// node_modules/bson/lib/bson/symbol.js
var require_symbol = __commonJS({
  "node_modules/bson/lib/bson/symbol.js"(exports2, module2) {
    init_shims();
    var inspect = Buffer ? __require("util").inspect.custom || "inspect" : "inspect";
    function Symbol2(value) {
      if (!(this instanceof Symbol2))
        return new Symbol2(value);
      this._bsontype = "Symbol";
      this.value = value;
    }
    Symbol2.prototype.valueOf = function() {
      return this.value;
    };
    Symbol2.prototype.toString = function() {
      return this.value;
    };
    Symbol2.prototype[inspect] = function() {
      return this.value;
    };
    Symbol2.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Symbol2;
    module2.exports.Symbol = Symbol2;
  }
});

// node_modules/bson/lib/bson/int_32.js
var require_int_32 = __commonJS({
  "node_modules/bson/lib/bson/int_32.js"(exports2, module2) {
    init_shims();
    var Int322 = function(value) {
      if (!(this instanceof Int322))
        return new Int322(value);
      this._bsontype = "Int32";
      this.value = value;
    };
    Int322.prototype.valueOf = function() {
      return this.value;
    };
    Int322.prototype.toJSON = function() {
      return this.value;
    };
    module2.exports = Int322;
    module2.exports.Int32 = Int322;
  }
});

// node_modules/bson/lib/bson/code.js
var require_code = __commonJS({
  "node_modules/bson/lib/bson/code.js"(exports2, module2) {
    init_shims();
    var Code2 = function Code3(code, scope) {
      if (!(this instanceof Code3))
        return new Code3(code, scope);
      this._bsontype = "Code";
      this.code = code;
      this.scope = scope;
    };
    Code2.prototype.toJSON = function() {
      return { scope: this.scope, code: this.code };
    };
    module2.exports = Code2;
    module2.exports.Code = Code2;
  }
});

// node_modules/bson/lib/bson/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/bson/lib/bson/decimal128.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_long();
    var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
    var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
    var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
    var EXPONENT_MAX = 6111;
    var EXPONENT_MIN = -6176;
    var EXPONENT_BIAS = 6176;
    var MAX_DIGITS = 34;
    var NAN_BUFFER = [
      124,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_NEGATIVE_BUFFER = [
      248,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var INF_POSITIVE_BUFFER = [
      120,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ].reverse();
    var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
    var utils2 = require_utils();
    var isDigit = function(value) {
      return !isNaN(parseInt(value, 10));
    };
    var divideu128 = function(value) {
      var DIVISOR = Long2.fromNumber(1e3 * 1e3 * 1e3);
      var _rem = Long2.fromNumber(0);
      var i = 0;
      if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
        return { quotient: value, rem: _rem };
      }
      for (i = 0; i <= 3; i++) {
        _rem = _rem.shiftLeft(32);
        _rem = _rem.add(new Long2(value.parts[i], 0));
        value.parts[i] = _rem.div(DIVISOR).low_;
        _rem = _rem.modulo(DIVISOR);
      }
      return { quotient: value, rem: _rem };
    };
    var multiply64x2 = function(left2, right) {
      if (!left2 && !right) {
        return { high: Long2.fromNumber(0), low: Long2.fromNumber(0) };
      }
      var leftHigh = left2.shiftRightUnsigned(32);
      var leftLow = new Long2(left2.getLowBits(), 0);
      var rightHigh = right.shiftRightUnsigned(32);
      var rightLow = new Long2(right.getLowBits(), 0);
      var productHigh = leftHigh.multiply(rightHigh);
      var productMid = leftHigh.multiply(rightLow);
      var productMid2 = leftLow.multiply(rightHigh);
      var productLow = leftLow.multiply(rightLow);
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productMid = new Long2(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
      productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
      productLow = productMid.shiftLeft(32).add(new Long2(productLow.getLowBits(), 0));
      return { high: productHigh, low: productLow };
    };
    var lessThan = function(left2, right) {
      var uhleft = left2.high_ >>> 0;
      var uhright = right.high_ >>> 0;
      if (uhleft < uhright) {
        return true;
      } else if (uhleft === uhright) {
        var ulleft = left2.low_ >>> 0;
        var ulright = right.low_ >>> 0;
        if (ulleft < ulright)
          return true;
      }
      return false;
    };
    var Decimal1282 = function(bytes2) {
      this._bsontype = "Decimal128";
      this.bytes = bytes2;
    };
    Decimal1282.fromString = function(string) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = [0, 0];
      var significandLow = [0, 0];
      var biasedExponent = 0;
      var index2 = 0;
      string = string.trim();
      if (string.length >= 7e3) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      var stringMatch = string.match(PARSE_STRING_REGEXP);
      var infMatch = string.match(PARSE_INF_REGEXP);
      var nanMatch = string.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (stringMatch && stringMatch[4] && stringMatch[2] === void 0) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "+" || string[index2] === "-") {
        isNegative = string[index2++] === "-";
      }
      if (!isDigit(string[index2]) && string[index2] !== ".") {
        if (string[index2] === "i" || string[index2] === "I") {
          return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
        } else if (string[index2] === "N") {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
      }
      while (isDigit(string[index2]) || string[index2] === ".") {
        if (string[index2] === ".") {
          if (sawRadix) {
            return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
          }
          sawRadix = true;
          index2 = index2 + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (string[index2] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(string[index2], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) {
          nDigits = nDigits + 1;
        }
        if (sawRadix) {
          radixPosition = radixPosition + 1;
        }
        nDigitsRead = nDigitsRead + 1;
        index2 = index2 + 1;
      }
      if (sawRadix && !nDigitsRead) {
        throw new Error("" + string + " not a valid Decimal128 string");
      }
      if (string[index2] === "e" || string[index2] === "E") {
        var match = string.substr(++index2).match(EXPONENT_REGEX);
        if (!match || !match[2]) {
          return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
        }
        exponent = parseInt(match[0], 10);
        index2 = index2 + match[0].length;
      }
      if (string[index2]) {
        return new Decimal1282(utils2.toBuffer(NAN_BUFFER));
      }
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (exponent !== 0 && significantDigits !== 1) {
          while (string[firstNonZero + significantDigits - 1] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          } else {
            return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
          }
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits && string[significantDigits] !== "0") {
        var endOfString = nDigitsRead;
        if (sawRadix && exponent === EXPONENT_MIN) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(string[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(utils2.toBuffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                }
              }
            } else {
              break;
            }
          }
        }
      }
      significandHigh = Long2.fromNumber(0);
      significandLow = Long2.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long2.fromNumber(0);
        significandLow = Long2.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        dIdx = firstDigit;
        significandLow = Long2.fromNumber(digits[dIdx++]);
        significandHigh = new Long2(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      } else {
        dIdx = firstDigit;
        significandHigh = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long2.fromNumber(10));
          significandHigh = significandHigh.add(Long2.fromNumber(digits[dIdx]));
        }
        significandLow = Long2.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long2.fromNumber(10));
          significandLow = significandLow.add(Long2.fromNumber(digits[dIdx]));
        }
      }
      var significand = multiply64x2(significandHigh, Long2.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long2.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = { low: Long2.fromNumber(0), high: Long2.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long2.fromNumber(1)).equals(Long2.fromNumber)) {
        dec.high = dec.high.or(Long2.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent).and(Long2.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long2.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long2.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long2.fromString("9223372036854775808"));
      }
      var buffer2 = utils2.allocBuffer(16);
      index2 = 0;
      buffer2[index2++] = dec.low.low_ & 255;
      buffer2[index2++] = dec.low.low_ >> 8 & 255;
      buffer2[index2++] = dec.low.low_ >> 16 & 255;
      buffer2[index2++] = dec.low.low_ >> 24 & 255;
      buffer2[index2++] = dec.low.high_ & 255;
      buffer2[index2++] = dec.low.high_ >> 8 & 255;
      buffer2[index2++] = dec.low.high_ >> 16 & 255;
      buffer2[index2++] = dec.low.high_ >> 24 & 255;
      buffer2[index2++] = dec.high.low_ & 255;
      buffer2[index2++] = dec.high.low_ >> 8 & 255;
      buffer2[index2++] = dec.high.low_ >> 16 & 255;
      buffer2[index2++] = dec.high.low_ >> 24 & 255;
      buffer2[index2++] = dec.high.high_ & 255;
      buffer2[index2++] = dec.high.high_ >> 8 & 255;
      buffer2[index2++] = dec.high.high_ >> 16 & 255;
      buffer2[index2++] = dec.high.high_ >> 24 & 255;
      return new Decimal1282(buffer2);
    };
    var COMBINATION_MASK = 31;
    var EXPONENT_MASK = 16383;
    var COMBINATION_INFINITY = 30;
    var COMBINATION_NAN = 31;
    EXPONENT_BIAS = 6176;
    Decimal1282.prototype.toString = function() {
      var high;
      var midh;
      var midl;
      var low;
      var combination;
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++)
        significand[i] = 0;
      var index2 = 0;
      var exponent;
      var scientific_exponent;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: new Array(4) };
      i;
      var j, k;
      var string = [];
      index2 = 0;
      var buffer2 = this.bytes;
      low = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      midl = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      midh = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      high = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      index2 = 0;
      var dec = {
        low: new Long2(low, midl),
        high: new Long2(midh, high)
      };
      if (dec.high.lessThan(Long2.ZERO)) {
        string.push("-");
      }
      combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low_;
          if (!least_digits)
            continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index2] = 0;
      } else {
        significand_digits = 36;
        i = 0;
        while (!significand[index2]) {
          i++;
          significand_digits = significand_digits - 1;
          index2 = index2 + 1;
        }
      }
      scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        string.push(significand[index2++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (i = 0; i < significand_digits; i++) {
          string.push(significand[index2++]);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push("+" + scientific_exponent);
        } else {
          string.push(scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (i = 0; i < significand_digits; i++) {
            string.push(significand[index2++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (i = 0; i < radix_position; i++) {
              string.push(significand[index2++]);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(significand[index2++]);
          }
        }
      }
      return string.join("");
    };
    Decimal1282.prototype.toJSON = function() {
      return { $numberDecimal: this.toString() };
    };
    module2.exports = Decimal1282;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/lib/bson/min_key.js
var require_min_key = __commonJS({
  "node_modules/bson/lib/bson/min_key.js"(exports2, module2) {
    init_shims();
    function MinKey2() {
      if (!(this instanceof MinKey2))
        return new MinKey2();
      this._bsontype = "MinKey";
    }
    module2.exports = MinKey2;
    module2.exports.MinKey = MinKey2;
  }
});

// node_modules/bson/lib/bson/max_key.js
var require_max_key = __commonJS({
  "node_modules/bson/lib/bson/max_key.js"(exports2, module2) {
    init_shims();
    function MaxKey2() {
      if (!(this instanceof MaxKey2))
        return new MaxKey2();
      this._bsontype = "MaxKey";
    }
    module2.exports = MaxKey2;
    module2.exports.MaxKey = MaxKey2;
  }
});

// node_modules/bson/lib/bson/db_ref.js
var require_db_ref = __commonJS({
  "node_modules/bson/lib/bson/db_ref.js"(exports2, module2) {
    init_shims();
    function DBRef2(namespace, oid, db) {
      if (!(this instanceof DBRef2))
        return new DBRef2(namespace, oid, db);
      this._bsontype = "DBRef";
      this.namespace = namespace;
      this.oid = oid;
      this.db = db;
    }
    DBRef2.prototype.toJSON = function() {
      return {
        $ref: this.namespace,
        $id: this.oid,
        $db: this.db == null ? "" : this.db
      };
    };
    module2.exports = DBRef2;
    module2.exports.DBRef = DBRef2;
  }
});

// node_modules/bson/lib/bson/binary.js
var require_binary = __commonJS({
  "node_modules/bson/lib/bson/binary.js"(exports2, module2) {
    init_shims();
    if (typeof global !== "undefined") {
      Buffer2 = __require("buffer").Buffer;
    }
    var Buffer2;
    var utils2 = require_utils();
    function Binary2(buffer2, subType) {
      if (!(this instanceof Binary2))
        return new Binary2(buffer2, subType);
      if (buffer2 != null && !(typeof buffer2 === "string") && !Buffer2.isBuffer(buffer2) && !(buffer2 instanceof Uint8Array) && !Array.isArray(buffer2)) {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
      this._bsontype = "Binary";
      if (buffer2 instanceof Number) {
        this.sub_type = buffer2;
        this.position = 0;
      } else {
        this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
        this.position = 0;
      }
      if (buffer2 != null && !(buffer2 instanceof Number)) {
        if (typeof buffer2 === "string") {
          if (typeof Buffer2 !== "undefined") {
            this.buffer = utils2.toBuffer(buffer2);
          } else if (typeof Uint8Array !== "undefined" || Object.prototype.toString.call(buffer2) === "[object Array]") {
            this.buffer = writeStringToArray(buffer2);
          } else {
            throw new Error("only String, Buffer, Uint8Array or Array accepted");
          }
        } else {
          this.buffer = buffer2;
        }
        this.position = buffer2.length;
      } else {
        if (typeof Buffer2 !== "undefined") {
          this.buffer = utils2.allocBuffer(Binary2.BUFFER_SIZE);
        } else if (typeof Uint8Array !== "undefined") {
          this.buffer = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE));
        } else {
          this.buffer = new Array(Binary2.BUFFER_SIZE);
        }
        this.position = 0;
      }
    }
    Binary2.prototype.put = function put(byte_value) {
      if (byte_value["length"] != null && typeof byte_value !== "number" && byte_value.length !== 1)
        throw new Error("only accepts single character String, Uint8Array or Array");
      if (typeof byte_value !== "number" && byte_value < 0 || byte_value > 255)
        throw new Error("only accepts number in a valid unsigned byte range 0-255");
      var decoded_byte = null;
      if (typeof byte_value === "string") {
        decoded_byte = byte_value.charCodeAt(0);
      } else if (byte_value["length"] != null) {
        decoded_byte = byte_value[0];
      } else {
        decoded_byte = byte_value;
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decoded_byte;
      } else {
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          var buffer2 = utils2.allocBuffer(Binary2.BUFFER_SIZE + this.buffer.length);
          this.buffer.copy(buffer2, 0, 0, this.buffer.length);
          this.buffer = buffer2;
          this.buffer[this.position++] = decoded_byte;
        } else {
          buffer2 = null;
          if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
            buffer2 = new Uint8Array(new ArrayBuffer(Binary2.BUFFER_SIZE + this.buffer.length));
          } else {
            buffer2 = new Array(Binary2.BUFFER_SIZE + this.buffer.length);
          }
          for (var i = 0; i < this.buffer.length; i++) {
            buffer2[i] = this.buffer[i];
          }
          this.buffer = buffer2;
          this.buffer[this.position++] = decoded_byte;
        }
      }
    };
    Binary2.prototype.write = function write(string, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.length < offset + string.length) {
        var buffer2 = null;
        if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
          buffer2 = utils2.allocBuffer(this.buffer.length + string.length);
          this.buffer.copy(buffer2, 0, 0, this.buffer.length);
        } else if (Object.prototype.toString.call(this.buffer) === "[object Uint8Array]") {
          buffer2 = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length));
          for (var i = 0; i < this.position; i++) {
            buffer2[i] = this.buffer[i];
          }
        }
        this.buffer = buffer2;
      }
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(string) && Buffer2.isBuffer(this.buffer)) {
        string.copy(this.buffer, offset, 0, string.length);
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (typeof Buffer2 !== "undefined" && typeof string === "string" && Buffer2.isBuffer(this.buffer)) {
        this.buffer.write(string, offset, "binary");
        this.position = offset + string.length > this.position ? offset + string.length : this.position;
      } else if (Object.prototype.toString.call(string) === "[object Uint8Array]" || Object.prototype.toString.call(string) === "[object Array]" && typeof string !== "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string[i];
        }
        this.position = offset > this.position ? offset : this.position;
      } else if (typeof string === "string") {
        for (i = 0; i < string.length; i++) {
          this.buffer[offset++] = string.charCodeAt(i);
        }
        this.position = offset > this.position ? offset : this.position;
      }
    };
    Binary2.prototype.read = function read2(position2, length) {
      length = length && length > 0 ? length : this.position;
      if (this.buffer["slice"]) {
        return this.buffer.slice(position2, position2 + length);
      } else {
        var buffer2 = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
        for (var i = 0; i < length; i++) {
          buffer2[i] = this.buffer[position2++];
        }
      }
      return buffer2;
    };
    Binary2.prototype.value = function value(asRaw) {
      asRaw = asRaw == null ? false : asRaw;
      if (asRaw && typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer) && this.buffer.length === this.position)
        return this.buffer;
      if (typeof Buffer2 !== "undefined" && Buffer2.isBuffer(this.buffer)) {
        return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
      } else {
        if (asRaw) {
          if (this.buffer["slice"] != null) {
            return this.buffer.slice(0, this.position);
          } else {
            var newBuffer = Object.prototype.toString.call(this.buffer) === "[object Uint8Array]" ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
            for (var i = 0; i < this.position; i++) {
              newBuffer[i] = this.buffer[i];
            }
            return newBuffer;
          }
        } else {
          return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
        }
      }
    };
    Binary2.prototype.length = function length() {
      return this.position;
    };
    Binary2.prototype.toJSON = function() {
      return this.buffer != null ? this.buffer.toString("base64") : "";
    };
    Binary2.prototype.toString = function(format3) {
      return this.buffer != null ? this.buffer.slice(0, this.position).toString(format3) : "";
    };
    var BSON_BINARY_SUBTYPE_DEFAULT = 0;
    var writeStringToArray = function(data) {
      var buffer2 = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        buffer2[i] = data.charCodeAt(i);
      }
      return buffer2;
    };
    var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
      var result = "";
      for (var i = startIndex; i < endIndex; i++) {
        result = result + String.fromCharCode(byteArray[i]);
      }
      return result;
    };
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    module2.exports = Binary2;
    module2.exports.Binary = Binary2;
  }
});

// node_modules/bson/lib/bson/parser/deserializer.js
var require_deserializer = __commonJS({
  "node_modules/bson/lib/bson/parser/deserializer.js"(exports, module) {
    init_shims();
    "use strict";
    var Long = require_long().Long;
    var Double = require_double().Double;
    var Timestamp = require_timestamp().Timestamp;
    var ObjectID = require_objectid().ObjectID;
    var Symbol = require_symbol().Symbol;
    var Code = require_code().Code;
    var MinKey = require_min_key().MinKey;
    var MaxKey = require_max_key().MaxKey;
    var Decimal128 = require_decimal128();
    var Int32 = require_int_32();
    var DBRef = require_db_ref().DBRef;
    var BSONRegExp = require_regexp().BSONRegExp;
    var Binary = require_binary().Binary;
    var utils = require_utils();
    var deserialize = function(buffer2, options2, isArray) {
      options2 = options2 == null ? {} : options2;
      var index2 = options2 && options2.index ? options2.index : 0;
      var size = buffer2[index2] | buffer2[index2 + 1] << 8 | buffer2[index2 + 2] << 16 | buffer2[index2 + 3] << 24;
      if (size < 5 || buffer2.length < size || size + index2 > buffer2.length) {
        throw new Error("corrupt bson message");
      }
      if (buffer2[index2 + size - 1] !== 0) {
        throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
      }
      return deserializeObject(buffer2, index2, options2, isArray);
    };
    var deserializeObject = function(buffer2, index2, options2, isArray) {
      var evalFunctions = options2["evalFunctions"] == null ? false : options2["evalFunctions"];
      var cacheFunctions = options2["cacheFunctions"] == null ? false : options2["cacheFunctions"];
      var cacheFunctionsCrc32 = options2["cacheFunctionsCrc32"] == null ? false : options2["cacheFunctionsCrc32"];
      if (!cacheFunctionsCrc32)
        var crc32 = null;
      var fieldsAsRaw = options2["fieldsAsRaw"] == null ? null : options2["fieldsAsRaw"];
      var raw = options2["raw"] == null ? false : options2["raw"];
      var bsonRegExp = typeof options2["bsonRegExp"] === "boolean" ? options2["bsonRegExp"] : false;
      var promoteBuffers = options2["promoteBuffers"] == null ? false : options2["promoteBuffers"];
      var promoteLongs = options2["promoteLongs"] == null ? true : options2["promoteLongs"];
      var promoteValues = options2["promoteValues"] == null ? true : options2["promoteValues"];
      var startIndex = index2;
      if (buffer2.length < 5)
        throw new Error("corrupt bson message < 5 bytes long");
      var size = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
      if (size < 5 || size > buffer2.length)
        throw new Error("corrupt bson message");
      var object = isArray ? [] : {};
      var arrayIndex = 0;
      var done = false;
      while (!done) {
        var elementType = buffer2[index2++];
        if (elementType === 0)
          break;
        var i = index2;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new Error("Bad BSON Document: illegal CString");
        var name2 = isArray ? arrayIndex++ : buffer2.toString("utf8", index2, i);
        index2 = i + 1;
        if (elementType === BSON.BSON_DATA_STRING) {
          var stringSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer2.length - index2 || buffer2[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name2] = buffer2.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_OID) {
          var oid = utils.allocBuffer(12);
          buffer2.copy(oid, 0, index2, index2 + 12);
          object[name2] = new ObjectID(oid);
          index2 = index2 + 12;
        } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {
          object[name2] = new Int32(buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24);
        } else if (elementType === BSON.BSON_DATA_INT) {
          object[name2] = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
        } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {
          object[name2] = new Double(buffer2.readDoubleLE(index2));
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_NUMBER) {
          object[name2] = buffer2.readDoubleLE(index2);
          index2 = index2 + 8;
        } else if (elementType === BSON.BSON_DATA_DATE) {
          var lowBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          var highBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          object[name2] = new Date(new Long(lowBits, highBits).toNumber());
        } else if (elementType === BSON.BSON_DATA_BOOLEAN) {
          if (buffer2[index2] !== 0 && buffer2[index2] !== 1)
            throw new Error("illegal boolean type value");
          object[name2] = buffer2[index2++] === 1;
        } else if (elementType === BSON.BSON_DATA_OBJECT) {
          var _index = index2;
          var objectSize = buffer2[index2] | buffer2[index2 + 1] << 8 | buffer2[index2 + 2] << 16 | buffer2[index2 + 3] << 24;
          if (objectSize <= 0 || objectSize > buffer2.length - index2)
            throw new Error("bad embedded document length in bson");
          if (raw) {
            object[name2] = buffer2.slice(index2, index2 + objectSize);
          } else {
            object[name2] = deserializeObject(buffer2, _index, options2, false);
          }
          index2 = index2 + objectSize;
        } else if (elementType === BSON.BSON_DATA_ARRAY) {
          _index = index2;
          objectSize = buffer2[index2] | buffer2[index2 + 1] << 8 | buffer2[index2 + 2] << 16 | buffer2[index2 + 3] << 24;
          var arrayOptions = options2;
          var stopIndex = index2 + objectSize;
          if (fieldsAsRaw && fieldsAsRaw[name2]) {
            arrayOptions = {};
            for (var n in options2)
              arrayOptions[n] = options2[n];
            arrayOptions["raw"] = true;
          }
          object[name2] = deserializeObject(buffer2, _index, arrayOptions, true);
          index2 = index2 + objectSize;
          if (buffer2[index2 - 1] !== 0)
            throw new Error("invalid array terminator byte");
          if (index2 !== stopIndex)
            throw new Error("corrupted array bson");
        } else if (elementType === BSON.BSON_DATA_UNDEFINED) {
          object[name2] = void 0;
        } else if (elementType === BSON.BSON_DATA_NULL) {
          object[name2] = null;
        } else if (elementType === BSON.BSON_DATA_LONG) {
          lowBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          highBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          var long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            object[name2] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            object[name2] = long;
          }
        } else if (elementType === BSON.BSON_DATA_DECIMAL128) {
          var bytes2 = utils.allocBuffer(16);
          buffer2.copy(bytes2, 0, index2, index2 + 16);
          index2 = index2 + 16;
          var decimal128 = new Decimal128(bytes2);
          object[name2] = decimal128.toObject ? decimal128.toObject() : decimal128;
        } else if (elementType === BSON.BSON_DATA_BINARY) {
          var binarySize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          var totalBinarySize = binarySize;
          var subType = buffer2[index2++];
          if (binarySize < 0)
            throw new Error("Negative binary type element size found");
          if (binarySize > buffer2.length)
            throw new Error("Binary type size larger than document size");
          if (buffer2["slice"] != null) {
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            if (promoteBuffers && promoteValues) {
              object[name2] = buffer2.slice(index2, index2 + binarySize);
            } else {
              object[name2] = new Binary(buffer2.slice(index2, index2 + binarySize), subType);
            }
          } else {
            var _buffer = typeof Uint8Array !== "undefined" ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
              binarySize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
              if (binarySize < 0)
                throw new Error("Negative binary type element size found for subtype 0x02");
              if (binarySize > totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to long binary size");
              if (binarySize < totalBinarySize - 4)
                throw new Error("Binary type with subtype 0x02 contains to short binary size");
            }
            for (i = 0; i < binarySize; i++) {
              _buffer[i] = buffer2[index2 + i];
            }
            if (promoteBuffers && promoteValues) {
              object[name2] = _buffer;
            } else {
              object[name2] = new Binary(_buffer, subType);
            }
          }
          index2 = index2 + binarySize;
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {
          i = index2;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new Error("Bad BSON Document: illegal CString");
          var source = buffer2.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new Error("Bad BSON Document: illegal CString");
          var regExpOptions = buffer2.toString("utf8", index2, i);
          index2 = i + 1;
          var optionsArray = new Array(regExpOptions.length);
          for (i = 0; i < regExpOptions.length; i++) {
            switch (regExpOptions[i]) {
              case "m":
                optionsArray[i] = "m";
                break;
              case "s":
                optionsArray[i] = "g";
                break;
              case "i":
                optionsArray[i] = "i";
                break;
            }
          }
          object[name2] = new RegExp(source, optionsArray.join(""));
        } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {
          i = index2;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new Error("Bad BSON Document: illegal CString");
          source = buffer2.toString("utf8", index2, i);
          index2 = i + 1;
          i = index2;
          while (buffer2[i] !== 0 && i < buffer2.length) {
            i++;
          }
          if (i >= buffer2.length)
            throw new Error("Bad BSON Document: illegal CString");
          regExpOptions = buffer2.toString("utf8", index2, i);
          index2 = i + 1;
          object[name2] = new BSONRegExp(source, regExpOptions);
        } else if (elementType === BSON.BSON_DATA_SYMBOL) {
          stringSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer2.length - index2 || buffer2[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          object[name2] = new Symbol(buffer2.toString("utf8", index2, index2 + stringSize - 1));
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {
          lowBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          highBits = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          object[name2] = new Timestamp(lowBits, highBits);
        } else if (elementType === BSON.BSON_DATA_MIN_KEY) {
          object[name2] = new MinKey();
        } else if (elementType === BSON.BSON_DATA_MAX_KEY) {
          object[name2] = new MaxKey();
        } else if (elementType === BSON.BSON_DATA_CODE) {
          stringSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer2.length - index2 || buffer2[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var functionString = buffer2.toString("utf8", index2, index2 + stringSize - 1);
          if (evalFunctions) {
            if (cacheFunctions) {
              var hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name2] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name2] = isolateEval(functionString);
            }
          } else {
            object[name2] = new Code(functionString);
          }
          index2 = index2 + stringSize;
        } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {
          var totalSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (totalSize < 4 + 4 + 4 + 1) {
            throw new Error("code_w_scope total size shorter minimum expected length");
          }
          stringSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer2.length - index2 || buffer2[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          functionString = buffer2.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          _index = index2;
          objectSize = buffer2[index2] | buffer2[index2 + 1] << 8 | buffer2[index2 + 2] << 16 | buffer2[index2 + 3] << 24;
          var scopeObject = deserializeObject(buffer2, _index, options2, false);
          index2 = index2 + objectSize;
          if (totalSize < 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to short, truncating scope");
          }
          if (totalSize > 4 + 4 + objectSize + stringSize) {
            throw new Error("code_w_scope total size is to long, clips outer document");
          }
          if (evalFunctions) {
            if (cacheFunctions) {
              hash2 = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
              object[name2] = isolateEvalWithHash(functionCache, hash2, functionString, object);
            } else {
              object[name2] = isolateEval(functionString);
            }
            object[name2].scope = scopeObject;
          } else {
            object[name2] = new Code(functionString, scopeObject);
          }
        } else if (elementType === BSON.BSON_DATA_DBPOINTER) {
          stringSize = buffer2[index2++] | buffer2[index2++] << 8 | buffer2[index2++] << 16 | buffer2[index2++] << 24;
          if (stringSize <= 0 || stringSize > buffer2.length - index2 || buffer2[index2 + stringSize - 1] !== 0)
            throw new Error("bad string length in bson");
          var namespace = buffer2.toString("utf8", index2, index2 + stringSize - 1);
          index2 = index2 + stringSize;
          var oidBuffer = utils.allocBuffer(12);
          buffer2.copy(oidBuffer, 0, index2, index2 + 12);
          oid = new ObjectID(oidBuffer);
          index2 = index2 + 12;
          var parts = namespace.split(".");
          var db = parts.shift();
          var collection = parts.join(".");
          object[name2] = new DBRef(collection, oid, db);
        } else {
          throw new Error("Detected unknown BSON type " + elementType.toString(16) + ' for fieldname "' + name2 + '", are you using the latest BSON parser');
        }
      }
      if (size !== index2 - startIndex) {
        if (isArray)
          throw new Error("corrupt array bson");
        throw new Error("corrupt object bson");
      }
      if (object["$id"] != null)
        object = new DBRef(object["$ref"], object["$id"], object["$db"]);
      return object;
    };
    var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
      var value = null;
      if (functionCache[hash] == null) {
        eval("value = " + functionString);
        functionCache[hash] = value;
      }
      return functionCache[hash].bind(object);
    };
    var isolateEval = function(functionString) {
      var value = null;
      eval("value = " + functionString);
      return value;
    };
    var BSON = {};
    var functionCache = BSON.functionCache = {};
    BSON.BSON_DATA_NUMBER = 1;
    BSON.BSON_DATA_STRING = 2;
    BSON.BSON_DATA_OBJECT = 3;
    BSON.BSON_DATA_ARRAY = 4;
    BSON.BSON_DATA_BINARY = 5;
    BSON.BSON_DATA_UNDEFINED = 6;
    BSON.BSON_DATA_OID = 7;
    BSON.BSON_DATA_BOOLEAN = 8;
    BSON.BSON_DATA_DATE = 9;
    BSON.BSON_DATA_NULL = 10;
    BSON.BSON_DATA_REGEXP = 11;
    BSON.BSON_DATA_DBPOINTER = 12;
    BSON.BSON_DATA_CODE = 13;
    BSON.BSON_DATA_SYMBOL = 14;
    BSON.BSON_DATA_CODE_W_SCOPE = 15;
    BSON.BSON_DATA_INT = 16;
    BSON.BSON_DATA_TIMESTAMP = 17;
    BSON.BSON_DATA_LONG = 18;
    BSON.BSON_DATA_DECIMAL128 = 19;
    BSON.BSON_DATA_MIN_KEY = 255;
    BSON.BSON_DATA_MAX_KEY = 127;
    BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON.BSON_INT32_MAX = 2147483647;
    BSON.BSON_INT32_MIN = -2147483648;
    BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON.JS_INT_MAX = 9007199254740992;
    BSON.JS_INT_MIN = -9007199254740992;
    var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992);
    var JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
    module.exports = deserialize;
  }
});

// node_modules/bson/lib/bson/float_parser.js
var require_float_parser = __commonJS({
  "node_modules/bson/lib/bson/float_parser.js"(exports2) {
    init_shims();
    var readIEEE754 = function(buffer2, offset, endian, mLen, nBytes) {
      var e, m2, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = bBE ? 0 : nBytes - 1, d3 = bBE ? 1 : -1, s3 = buffer2[offset + i];
      i += d3;
      e = s3 & (1 << -nBits) - 1;
      s3 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d3, nBits -= 8)
        ;
      m2 = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d3, nBits -= 8)
        ;
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m2 ? NaN : (s3 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s3 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    var writeIEEE754 = function(buffer2, value, offset, endian, mLen, nBytes) {
      var e, m2, c, bBE = endian === "big", eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = bBE ? nBytes - 1 : 0, d3 = bBE ? -1 : 1, s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d3, m2 /= 256, mLen -= 8)
        ;
      e = e << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d3, e /= 256, eLen -= 8)
        ;
      buffer2[offset + i - d3] |= s3 * 128;
    };
    exports2.readIEEE754 = readIEEE754;
    exports2.writeIEEE754 = writeIEEE754;
  }
});

// node_modules/bson/lib/bson/parser/serializer.js
var require_serializer = __commonJS({
  "node_modules/bson/lib/bson/parser/serializer.js"(exports2, module2) {
    init_shims();
    "use strict";
    var writeIEEE754 = require_float_parser().writeIEEE754;
    var Long2 = require_long().Long;
    var Map2 = require_map();
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var regexp = /\x00/;
    var ignoreKeys = ["$db", "$ref", "$id", "$clusterTime"];
    var isDate = function isDate2(d3) {
      return typeof d3 === "object" && Object.prototype.toString.call(d3) === "[object Date]";
    };
    var isRegExp = function isRegExp2(d3) {
      return Object.prototype.toString.call(d3) === "[object RegExp]";
    };
    var serializeString = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_STRING;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes + 1;
      buffer2[index2 - 1] = 0;
      var size = buffer2.write(value, index2 + 4, "utf8");
      buffer2[index2 + 3] = size + 1 >> 24 & 255;
      buffer2[index2 + 2] = size + 1 >> 16 & 255;
      buffer2[index2 + 1] = size + 1 >> 8 & 255;
      buffer2[index2] = size + 1 & 255;
      index2 = index2 + 4 + size;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeNumber = function(buffer2, key, value, index2, isArray) {
      if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
        if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
          buffer2[index2++] = BSON2.BSON_DATA_INT;
          var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer2[index2++] = 0;
          buffer2[index2++] = value & 255;
          buffer2[index2++] = value >> 8 & 255;
          buffer2[index2++] = value >> 16 & 255;
          buffer2[index2++] = value >> 24 & 255;
        } else if (value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
          buffer2[index2++] = BSON2.BSON_DATA_NUMBER;
          numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer2[index2++] = 0;
          writeIEEE754(buffer2, value, index2, "little", 52, 8);
          index2 = index2 + 8;
        } else {
          buffer2[index2++] = BSON2.BSON_DATA_LONG;
          numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
          index2 = index2 + numberOfWrittenBytes;
          buffer2[index2++] = 0;
          var longVal = Long2.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          buffer2[index2++] = lowBits & 255;
          buffer2[index2++] = lowBits >> 8 & 255;
          buffer2[index2++] = lowBits >> 16 & 255;
          buffer2[index2++] = lowBits >> 24 & 255;
          buffer2[index2++] = highBits & 255;
          buffer2[index2++] = highBits >> 8 & 255;
          buffer2[index2++] = highBits >> 16 & 255;
          buffer2[index2++] = highBits >> 24 & 255;
        }
      } else {
        buffer2[index2++] = BSON2.BSON_DATA_NUMBER;
        numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer2[index2++] = 0;
        writeIEEE754(buffer2, value, index2, "little", 52, 8);
        index2 = index2 + 8;
      }
      return index2;
    };
    var serializeNull = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_NULL;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeBoolean = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_BOOLEAN;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      buffer2[index2++] = value ? 1 : 0;
      return index2;
    };
    var serializeDate = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_DATE;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var dateInMilis = Long2.fromNumber(value.getTime());
      var lowBits = dateInMilis.getLowBits();
      var highBits = dateInMilis.getHighBits();
      buffer2[index2++] = lowBits & 255;
      buffer2[index2++] = lowBits >> 8 & 255;
      buffer2[index2++] = lowBits >> 16 & 255;
      buffer2[index2++] = lowBits >> 24 & 255;
      buffer2[index2++] = highBits & 255;
      buffer2[index2++] = highBits >> 8 & 255;
      buffer2[index2++] = highBits >> 16 & 255;
      buffer2[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeRegExp = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      if (value.source && value.source.match(regexp) != null) {
        throw Error("value " + value.source + " must not contain null bytes");
      }
      index2 = index2 + buffer2.write(value.source, index2, "utf8");
      buffer2[index2++] = 0;
      if (value.global)
        buffer2[index2++] = 115;
      if (value.ignoreCase)
        buffer2[index2++] = 105;
      if (value.multiline)
        buffer2[index2++] = 109;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeBSONRegExp = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_REGEXP;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      if (value.pattern.match(regexp) != null) {
        throw Error("pattern " + value.pattern + " must not contain null bytes");
      }
      index2 = index2 + buffer2.write(value.pattern, index2, "utf8");
      buffer2[index2++] = 0;
      index2 = index2 + buffer2.write(value.options.split("").sort().join(""), index2, "utf8");
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeMinMax = function(buffer2, key, value, index2, isArray) {
      if (value === null) {
        buffer2[index2++] = BSON2.BSON_DATA_NULL;
      } else if (value._bsontype === "MinKey") {
        buffer2[index2++] = BSON2.BSON_DATA_MIN_KEY;
      } else {
        buffer2[index2++] = BSON2.BSON_DATA_MAX_KEY;
      }
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeObjectId = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_OID;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      if (typeof value.id === "string") {
        buffer2.write(value.id, index2, "binary");
      } else if (value.id && value.id.copy) {
        value.id.copy(buffer2, index2, 0, 12);
      } else {
        throw new Error("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
      }
      return index2 + 12;
    };
    var serializeBuffer = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var size = value.length;
      buffer2[index2++] = size & 255;
      buffer2[index2++] = size >> 8 & 255;
      buffer2[index2++] = size >> 16 & 255;
      buffer2[index2++] = size >> 24 & 255;
      buffer2[index2++] = BSON2.BSON_BINARY_SUBTYPE_DEFAULT;
      value.copy(buffer2, index2, 0, size);
      index2 = index2 + size;
      return index2;
    };
    var serializeObject = function(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
      for (var i = 0; i < path.length; i++) {
        if (path[i] === value)
          throw new Error("cyclic dependency detected");
      }
      path.push(value);
      buffer2[index2++] = Array.isArray(value) ? BSON2.BSON_DATA_ARRAY : BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var endIndex = serializeInto(buffer2, value, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined, path);
      path.pop();
      return endIndex;
    };
    var serializeDecimal128 = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_DECIMAL128;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      value.bytes.copy(buffer2, index2, 0, 16);
      return index2 + 16;
    };
    var serializeLong = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = value._bsontype === "Long" ? BSON2.BSON_DATA_LONG : BSON2.BSON_DATA_TIMESTAMP;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var lowBits = value.getLowBits();
      var highBits = value.getHighBits();
      buffer2[index2++] = lowBits & 255;
      buffer2[index2++] = lowBits >> 8 & 255;
      buffer2[index2++] = lowBits >> 16 & 255;
      buffer2[index2++] = lowBits >> 24 & 255;
      buffer2[index2++] = highBits & 255;
      buffer2[index2++] = highBits >> 8 & 255;
      buffer2[index2++] = highBits >> 16 & 255;
      buffer2[index2++] = highBits >> 24 & 255;
      return index2;
    };
    var serializeInt32 = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      buffer2[index2++] = value & 255;
      buffer2[index2++] = value >> 8 & 255;
      buffer2[index2++] = value >> 16 & 255;
      buffer2[index2++] = value >> 24 & 255;
      return index2;
    };
    var serializeDouble = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      writeIEEE754(buffer2, value, index2, "little", 52, 8);
      index2 = index2 + 8;
      return index2;
    };
    var serializeFunction = function(buffer2, key, value, index2, checkKeys, depth, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var functionString = normalizedFunctionString(value);
      var size = buffer2.write(functionString, index2 + 4, "utf8") + 1;
      buffer2[index2] = size & 255;
      buffer2[index2 + 1] = size >> 8 & 255;
      buffer2[index2 + 2] = size >> 16 & 255;
      buffer2[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeCode = function(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
      if (value.scope && typeof value.scope === "object") {
        buffer2[index2++] = BSON2.BSON_DATA_CODE_W_SCOPE;
        var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer2[index2++] = 0;
        var startIndex = index2;
        var functionString = typeof value.code === "string" ? value.code : value.code.toString();
        index2 = index2 + 4;
        var codeSize = buffer2.write(functionString, index2 + 4, "utf8") + 1;
        buffer2[index2] = codeSize & 255;
        buffer2[index2 + 1] = codeSize >> 8 & 255;
        buffer2[index2 + 2] = codeSize >> 16 & 255;
        buffer2[index2 + 3] = codeSize >> 24 & 255;
        buffer2[index2 + 4 + codeSize - 1] = 0;
        index2 = index2 + codeSize + 4;
        var endIndex = serializeInto(buffer2, value.scope, checkKeys, index2, depth + 1, serializeFunctions, ignoreUndefined);
        index2 = endIndex - 1;
        var totalSize = endIndex - startIndex;
        buffer2[startIndex++] = totalSize & 255;
        buffer2[startIndex++] = totalSize >> 8 & 255;
        buffer2[startIndex++] = totalSize >> 16 & 255;
        buffer2[startIndex++] = totalSize >> 24 & 255;
        buffer2[index2++] = 0;
      } else {
        buffer2[index2++] = BSON2.BSON_DATA_CODE;
        numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
        index2 = index2 + numberOfWrittenBytes;
        buffer2[index2++] = 0;
        functionString = value.code.toString();
        var size = buffer2.write(functionString, index2 + 4, "utf8") + 1;
        buffer2[index2] = size & 255;
        buffer2[index2 + 1] = size >> 8 & 255;
        buffer2[index2 + 2] = size >> 16 & 255;
        buffer2[index2 + 3] = size >> 24 & 255;
        index2 = index2 + 4 + size - 1;
        buffer2[index2++] = 0;
      }
      return index2;
    };
    var serializeBinary = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_BINARY;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var data = value.value(true);
      var size = value.position;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY)
        size = size + 4;
      buffer2[index2++] = size & 255;
      buffer2[index2++] = size >> 8 & 255;
      buffer2[index2++] = size >> 16 & 255;
      buffer2[index2++] = size >> 24 & 255;
      buffer2[index2++] = value.sub_type;
      if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
        size = size - 4;
        buffer2[index2++] = size & 255;
        buffer2[index2++] = size >> 8 & 255;
        buffer2[index2++] = size >> 16 & 255;
        buffer2[index2++] = size >> 24 & 255;
      }
      data.copy(buffer2, index2, 0, value.position);
      index2 = index2 + value.position;
      return index2;
    };
    var serializeSymbol = function(buffer2, key, value, index2, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_SYMBOL;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var size = buffer2.write(value.value, index2 + 4, "utf8") + 1;
      buffer2[index2] = size & 255;
      buffer2[index2 + 1] = size >> 8 & 255;
      buffer2[index2 + 2] = size >> 16 & 255;
      buffer2[index2 + 3] = size >> 24 & 255;
      index2 = index2 + 4 + size - 1;
      buffer2[index2++] = 0;
      return index2;
    };
    var serializeDBRef = function(buffer2, key, value, index2, depth, serializeFunctions, isArray) {
      buffer2[index2++] = BSON2.BSON_DATA_OBJECT;
      var numberOfWrittenBytes = !isArray ? buffer2.write(key, index2, "utf8") : buffer2.write(key, index2, "ascii");
      index2 = index2 + numberOfWrittenBytes;
      buffer2[index2++] = 0;
      var startIndex = index2;
      var endIndex;
      if (value.db != null) {
        endIndex = serializeInto(buffer2, {
          $ref: value.namespace,
          $id: value.oid,
          $db: value.db
        }, false, index2, depth + 1, serializeFunctions);
      } else {
        endIndex = serializeInto(buffer2, {
          $ref: value.namespace,
          $id: value.oid
        }, false, index2, depth + 1, serializeFunctions);
      }
      var size = endIndex - startIndex;
      buffer2[startIndex++] = size & 255;
      buffer2[startIndex++] = size >> 8 & 255;
      buffer2[startIndex++] = size >> 16 & 255;
      buffer2[startIndex++] = size >> 24 & 255;
      return endIndex;
    };
    var serializeInto = function serializeInto2(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
      startingIndex = startingIndex || 0;
      path = path || [];
      path.push(object);
      var index2 = startingIndex + 4;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          var key = "" + i;
          var value = object[i];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          var type = typeof value;
          if (type === "string") {
            index2 = serializeString(buffer2, key, value, index2, true);
          } else if (type === "number") {
            index2 = serializeNumber(buffer2, key, value, index2, true);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer2, key, value, index2, true);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer2, key, value, index2, true);
          } else if (value === void 0) {
            index2 = serializeNull(buffer2, key, value, index2, true);
          } else if (value === null) {
            index2 = serializeNull(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer2, key, value, index2, true);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer2, key, value, index2, true);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer2, key, value, index2, true);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer2, key, value, index2, true);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer2, key, value, index2, depth, serializeFunctions, true);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer2, key, value, index2, true);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer2, key, value, index2, true);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else if (object instanceof Map2) {
        var iterator = object.entries();
        var done = false;
        while (!done) {
          var entry = iterator.next();
          done = entry.done;
          if (done)
            continue;
          key = entry.value[0];
          value = entry.value[1];
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer2, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer2, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer2, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer2, key, value, index2);
          } else if (value === null || value === void 0 && ignoreUndefined === false) {
            index2 = serializeNull(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer2, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer2, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer2, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer2, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer2, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer2, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      } else {
        if (object.toBSON) {
          if (typeof object.toBSON !== "function")
            throw new Error("toBSON is not a function");
          object = object.toBSON();
          if (object != null && typeof object !== "object")
            throw new Error("toBSON function did not return an object");
        }
        for (key in object) {
          value = object[key];
          if (value && value.toBSON) {
            if (typeof value.toBSON !== "function")
              throw new Error("toBSON is not a function");
            value = value.toBSON();
          }
          type = typeof value;
          if (typeof key === "string" && ignoreKeys.indexOf(key) === -1) {
            if (key.match(regexp) != null) {
              throw Error("key " + key + " must not contain null bytes");
            }
            if (checkKeys) {
              if (key[0] === "$") {
                throw Error("key " + key + " must not start with '$'");
              } else if (~key.indexOf(".")) {
                throw Error("key " + key + " must not contain '.'");
              }
            }
          }
          if (type === "string") {
            index2 = serializeString(buffer2, key, value, index2);
          } else if (type === "number") {
            index2 = serializeNumber(buffer2, key, value, index2);
          } else if (type === "bigint") {
            throw new TypeError("Unsupported type BigInt, please use Decimal128");
          } else if (type === "boolean") {
            index2 = serializeBoolean(buffer2, key, value, index2);
          } else if (value instanceof Date || isDate(value)) {
            index2 = serializeDate(buffer2, key, value, index2);
          } else if (value === void 0) {
            if (ignoreUndefined === false)
              index2 = serializeNull(buffer2, key, value, index2);
          } else if (value === null) {
            index2 = serializeNull(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            index2 = serializeObjectId(buffer2, key, value, index2);
          } else if (Buffer.isBuffer(value)) {
            index2 = serializeBuffer(buffer2, key, value, index2);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index2 = serializeRegExp(buffer2, key, value, index2);
          } else if (type === "object" && value["_bsontype"] == null) {
            index2 = serializeObject(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
          } else if (type === "object" && value["_bsontype"] === "Decimal128") {
            index2 = serializeDecimal128(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Long" || value["_bsontype"] === "Timestamp") {
            index2 = serializeLong(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Double") {
            index2 = serializeDouble(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Code") {
            index2 = serializeCode(buffer2, key, value, index2, checkKeys, depth, serializeFunctions, ignoreUndefined);
          } else if (typeof value === "function" && serializeFunctions) {
            index2 = serializeFunction(buffer2, key, value, index2, checkKeys, depth, serializeFunctions);
          } else if (value["_bsontype"] === "Binary") {
            index2 = serializeBinary(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Symbol") {
            index2 = serializeSymbol(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "DBRef") {
            index2 = serializeDBRef(buffer2, key, value, index2, depth, serializeFunctions);
          } else if (value["_bsontype"] === "BSONRegExp") {
            index2 = serializeBSONRegExp(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "Int32") {
            index2 = serializeInt32(buffer2, key, value, index2);
          } else if (value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            index2 = serializeMinMax(buffer2, key, value, index2);
          } else if (typeof value["_bsontype"] !== "undefined") {
            throw new TypeError("Unrecognized or invalid _bsontype: " + value["_bsontype"]);
          }
        }
      }
      path.pop();
      buffer2[index2++] = 0;
      var size = index2 - startingIndex;
      buffer2[startingIndex++] = size & 255;
      buffer2[startingIndex++] = size >> 8 & 255;
      buffer2[startingIndex++] = size >> 16 & 255;
      buffer2[startingIndex++] = size >> 24 & 255;
      return index2;
    };
    var BSON2 = {};
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_UNDEFINED = 6;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_DECIMAL128 = 19;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = serializeInto;
  }
});

// node_modules/bson/lib/bson/parser/calculate_size.js
var require_calculate_size = __commonJS({
  "node_modules/bson/lib/bson/parser/calculate_size.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_long().Long;
    var Double2 = require_double().Double;
    var Timestamp2 = require_timestamp().Timestamp;
    var ObjectID2 = require_objectid().ObjectID;
    var Symbol2 = require_symbol().Symbol;
    var BSONRegExp2 = require_regexp().BSONRegExp;
    var Code2 = require_code().Code;
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key().MinKey;
    var MaxKey2 = require_max_key().MaxKey;
    var DBRef2 = require_db_ref().DBRef;
    var Binary2 = require_binary().Binary;
    var normalizedFunctionString = require_utils().normalizedFunctionString;
    var isDate = function isDate2(d3) {
      return typeof d3 === "object" && Object.prototype.toString.call(d3) === "[object Date]";
    };
    var calculateObjectSize = function calculateObjectSize2(object, serializeFunctions, ignoreUndefined) {
      var totalLength = 4 + 1;
      if (Array.isArray(object)) {
        for (var i = 0; i < object.length; i++) {
          totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
        }
      } else {
        if (object.toBSON) {
          object = object.toBSON();
        }
        for (var key in object) {
          totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
        }
      }
      return totalLength;
    };
    function calculateElement(name2, value, serializeFunctions, isArray, ignoreUndefined) {
      if (value && value.toBSON) {
        value = value.toBSON();
      }
      switch (typeof value) {
        case "string":
          return 1 + Buffer.byteLength(name2, "utf8") + 1 + 4 + Buffer.byteLength(value, "utf8") + 1;
        case "number":
          if (Math.floor(value) === value && value >= BSON2.JS_INT_MIN && value <= BSON2.JS_INT_MAX) {
            if (value >= BSON2.BSON_INT32_MIN && value <= BSON2.BSON_INT32_MAX) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (4 + 1);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
            }
          } else {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          }
        case "undefined":
          if (isArray || !ignoreUndefined)
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1;
          return 0;
        case "boolean":
          return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (1 + 1);
        case "object":
          if (value == null || value instanceof MinKey2 || value instanceof MaxKey2 || value["_bsontype"] === "MinKey" || value["_bsontype"] === "MaxKey") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1;
          } else if (value instanceof ObjectID2 || value["_bsontype"] === "ObjectID" || value["_bsontype"] === "ObjectId") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (12 + 1);
          } else if (value instanceof Date || isDate(value)) {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(value)) {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (1 + 4 + 1) + value.length;
          } else if (value instanceof Long2 || value instanceof Double2 || value instanceof Timestamp2 || value["_bsontype"] === "Long" || value["_bsontype"] === "Double" || value["_bsontype"] === "Timestamp") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (8 + 1);
          } else if (value instanceof Decimal1282 || value["_bsontype"] === "Decimal128") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (16 + 1);
          } else if (value instanceof Code2 || value["_bsontype"] === "Code") {
            if (value.scope != null && Object.keys(value.scope).length > 0) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), "utf8") + 1;
            }
          } else if (value instanceof Binary2 || value["_bsontype"] === "Binary") {
            if (value.sub_type === Binary2.SUBTYPE_BYTE_ARRAY) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
            } else {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + (value.position + 1 + 4 + 1);
            }
          } else if (value instanceof Symbol2 || value["_bsontype"] === "Symbol") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + Buffer.byteLength(value.value, "utf8") + 4 + 1 + 1;
          } else if (value instanceof DBRef2 || value["_bsontype"] === "DBRef") {
            var ordered_values = {
              $ref: value.namespace,
              $id: value.oid
            };
            if (value.db != null) {
              ordered_values["$db"] = value.db;
            }
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
          } else if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else if (value instanceof BSONRegExp2 || value["_bsontype"] === "BSONRegExp") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.pattern, "utf8") + 1 + Buffer.byteLength(value.options, "utf8") + 1;
          } else {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
          }
        case "function":
          if (value instanceof RegExp || Object.prototype.toString.call(value) === "[object RegExp]" || String.call(value) === "[object RegExp]") {
            return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + Buffer.byteLength(value.source, "utf8") + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
          } else {
            if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
            } else if (serializeFunctions) {
              return (name2 != null ? Buffer.byteLength(name2, "utf8") + 1 : 0) + 1 + 4 + Buffer.byteLength(normalizedFunctionString(value), "utf8") + 1;
            }
          }
      }
      return 0;
    }
    var BSON2 = {};
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    module2.exports = calculateObjectSize;
  }
});

// node_modules/bson/lib/bson/bson.js
var require_bson = __commonJS({
  "node_modules/bson/lib/bson/bson.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Map2 = require_map();
    var Long2 = require_long();
    var Double2 = require_double();
    var Timestamp2 = require_timestamp();
    var ObjectID2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Int322 = require_int_32();
    var Code2 = require_code();
    var Decimal1282 = require_decimal128();
    var MinKey2 = require_min_key();
    var MaxKey2 = require_max_key();
    var DBRef2 = require_db_ref();
    var Binary2 = require_binary();
    var deserialize2 = require_deserializer();
    var serializer = require_serializer();
    var calculateObjectSize = require_calculate_size();
    var utils2 = require_utils();
    var MAXSIZE = 1024 * 1024 * 17;
    var buffer2 = utils2.allocBuffer(MAXSIZE);
    var BSON2 = function() {
    };
    BSON2.prototype.serialize = function serialize(object, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var minInternalBufferSize = typeof options2.minInternalBufferSize === "number" ? options2.minInternalBufferSize : MAXSIZE;
      if (buffer2.length < minInternalBufferSize) {
        buffer2 = utils2.allocBuffer(minInternalBufferSize);
      }
      var serializationIndex = serializer(buffer2, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
      var finishedBuffer = utils2.allocBuffer(serializationIndex);
      buffer2.copy(finishedBuffer, 0, 0, finishedBuffer.length);
      return finishedBuffer;
    };
    BSON2.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options2) {
      options2 = options2 || {};
      var checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      var startIndex = typeof options2.index === "number" ? options2.index : 0;
      var serializationIndex = serializer(finalBuffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
      return serializationIndex - 1;
    };
    BSON2.prototype.deserialize = function(buffer3, options2) {
      return deserialize2(buffer3, options2);
    };
    BSON2.prototype.calculateObjectSize = function(object, options2) {
      options2 = options2 || {};
      var serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      var ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : true;
      return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
    };
    BSON2.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options2) {
      options2 = options2 != null ? options2 : {};
      var index2 = startIndex;
      for (var i = 0; i < numberOfDocuments; i++) {
        var size = data[index2] | data[index2 + 1] << 8 | data[index2 + 2] << 16 | data[index2 + 3] << 24;
        options2["index"] = index2;
        documents[docStartIndex + i] = this.deserialize(data, options2);
        index2 = index2 + size;
      }
      return index2;
    };
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.BSON_DATA_NUMBER = 1;
    BSON2.BSON_DATA_STRING = 2;
    BSON2.BSON_DATA_OBJECT = 3;
    BSON2.BSON_DATA_ARRAY = 4;
    BSON2.BSON_DATA_BINARY = 5;
    BSON2.BSON_DATA_OID = 7;
    BSON2.BSON_DATA_BOOLEAN = 8;
    BSON2.BSON_DATA_DATE = 9;
    BSON2.BSON_DATA_NULL = 10;
    BSON2.BSON_DATA_REGEXP = 11;
    BSON2.BSON_DATA_CODE = 13;
    BSON2.BSON_DATA_SYMBOL = 14;
    BSON2.BSON_DATA_CODE_W_SCOPE = 15;
    BSON2.BSON_DATA_INT = 16;
    BSON2.BSON_DATA_TIMESTAMP = 17;
    BSON2.BSON_DATA_LONG = 18;
    BSON2.BSON_DATA_MIN_KEY = 255;
    BSON2.BSON_DATA_MAX_KEY = 127;
    BSON2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    BSON2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
    BSON2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
    BSON2.BSON_BINARY_SUBTYPE_UUID = 3;
    BSON2.BSON_BINARY_SUBTYPE_MD5 = 4;
    BSON2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
    module2.exports = BSON2;
    module2.exports.Code = Code2;
    module2.exports.Map = Map2;
    module2.exports.Symbol = Symbol2;
    module2.exports.BSON = BSON2;
    module2.exports.DBRef = DBRef2;
    module2.exports.Binary = Binary2;
    module2.exports.ObjectID = ObjectID2;
    module2.exports.Long = Long2;
    module2.exports.Timestamp = Timestamp2;
    module2.exports.Double = Double2;
    module2.exports.Int32 = Int322;
    module2.exports.MinKey = MinKey2;
    module2.exports.MaxKey = MaxKey2;
    module2.exports.BSONRegExp = BSONRegExp2;
    module2.exports.Decimal128 = Decimal1282;
  }
});

// node_modules/bson/index.js
var require_bson2 = __commonJS({
  "node_modules/bson/index.js"(exports2, module2) {
    init_shims();
    var BSON2 = require_bson();
    var Binary2 = require_binary();
    var Code2 = require_code();
    var DBRef2 = require_db_ref();
    var Decimal1282 = require_decimal128();
    var Double2 = require_double();
    var Int322 = require_int_32();
    var Long2 = require_long();
    var Map2 = require_map();
    var MaxKey2 = require_max_key();
    var MinKey2 = require_min_key();
    var ObjectId2 = require_objectid();
    var BSONRegExp2 = require_regexp();
    var Symbol2 = require_symbol();
    var Timestamp2 = require_timestamp();
    BSON2.BSON_INT32_MAX = 2147483647;
    BSON2.BSON_INT32_MIN = -2147483648;
    BSON2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
    BSON2.BSON_INT64_MIN = -Math.pow(2, 63);
    BSON2.JS_INT_MAX = 9007199254740992;
    BSON2.JS_INT_MIN = -9007199254740992;
    BSON2.Binary = Binary2;
    BSON2.Code = Code2;
    BSON2.DBRef = DBRef2;
    BSON2.Decimal128 = Decimal1282;
    BSON2.Double = Double2;
    BSON2.Int32 = Int322;
    BSON2.Long = Long2;
    BSON2.Map = Map2;
    BSON2.MaxKey = MaxKey2;
    BSON2.MinKey = MinKey2;
    BSON2.ObjectId = ObjectId2;
    BSON2.ObjectID = ObjectId2;
    BSON2.BSONRegExp = BSONRegExp2;
    BSON2.Symbol = Symbol2;
    BSON2.Timestamp = Timestamp2;
    module2.exports = BSON2;
  }
});

// node_modules/optional-require/index.js
var require_optional_require = __commonJS({
  "node_modules/optional-require/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var assert = __require("assert");
    function findModuleNotFound(err, name2) {
      const msg = err.message.split("\n")[0];
      return msg && (msg.includes(`'${name2}'`) || msg.includes(` ${name2} `) || msg.includes(` ${name2}. `) || msg.includes(` ${name2}, `));
    }
    function _optionalRequire(callerRequire, resolve3, path, message) {
      let opts;
      if (typeof message === "object") {
        opts = message;
        assert(!(opts.hasOwnProperty("notFound") && opts.hasOwnProperty("default")), "optionalRequire: options set with both `notFound` and `default`");
      } else {
        opts = { message };
      }
      try {
        return resolve3 ? callerRequire.resolve(path) : callerRequire(path);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" || !findModuleNotFound(e, path)) {
          if (typeof opts.fail === "function") {
            return opts.fail(e);
          }
          throw e;
        }
        if (opts.message) {
          const message2 = typeof opts.message === "string" ? `${opts.message} - ` : "";
          const r = resolve3 ? "resolved" : "found";
          optionalRequire.log(`${message2}optional module not ${r}`, path);
        }
        if (typeof opts.notFound === "function") {
          return opts.notFound(e);
        }
        return opts.default;
      }
    }
    var tryRequire = (callerRequire, path, message) => _optionalRequire(callerRequire, false, path, message);
    var tryResolve = (callerRequire, path, message) => _optionalRequire(callerRequire, true, path, message);
    function optionalRequire(callerRequire) {
      const x = (path, message) => tryRequire(callerRequire, path, message);
      x.resolve = (path, message) => tryResolve(callerRequire, path, message);
      return x;
    }
    optionalRequire.try = tryRequire;
    optionalRequire.tryResolve = tryResolve;
    optionalRequire.resolve = tryResolve;
    optionalRequire.log = (message, path) => console.log(`Just FYI: ${message}; Path "${path}"`);
    module2.exports = optionalRequire;
  }
});

// node_modules/mongodb/package.json
var require_package = __commonJS({
  "node_modules/mongodb/package.json"(exports2, module2) {
    module2.exports = {
      _from: "mongodb@^3.6.9",
      _id: "mongodb@3.6.9",
      _inBundle: false,
      _integrity: "sha512-1nSCKgSunzn/CXwgOWgbPHUWOO5OfERcuOWISmqd610jn0s8BU9K4879iJVabqgpPPbA6hO7rG48eq+fGED3Mg==",
      _location: "/mongodb",
      _phantomChildren: {},
      _requested: {
        type: "range",
        registry: true,
        raw: "mongodb@^3.6.9",
        name: "mongodb",
        escapedName: "mongodb",
        rawSpec: "^3.6.9",
        saveSpec: null,
        fetchSpec: "^3.6.9"
      },
      _requiredBy: [
        "#DEV:/",
        "#USER"
      ],
      _resolved: "https://registry.npmjs.org/mongodb/-/mongodb-3.6.9.tgz",
      _shasum: "4889cf529724267d393a18275d6cf19d71905b1d",
      _spec: "mongodb@^3.6.9",
      _where: "C:\\Users\\bmcaleavey\\Documents\\Ennis\\ABTL\\eop",
      bugs: {
        url: "https://github.com/mongodb/node-mongodb-native/issues"
      },
      bundleDependencies: false,
      dependencies: {
        bl: "^2.2.1",
        bson: "^1.1.4",
        denque: "^1.4.1",
        "optional-require": "^1.0.3",
        "safe-buffer": "^5.1.2",
        saslprep: "^1.0.0"
      },
      deprecated: false,
      description: "The official MongoDB driver for Node.js",
      devDependencies: {
        "@types/chai": "^4.2.16",
        "@types/mocha": "^8.2.2",
        "@types/node": "^14.14.37",
        "array-includes": "^3.1.3",
        chai: "^4.1.1",
        "chai-subset": "^1.6.0",
        chalk: "^2.4.2",
        co: "4.6.0",
        eslint: "^7.10.0",
        "eslint-config-prettier": "^6.11.0",
        "eslint-plugin-es": "^3.0.1",
        "eslint-plugin-prettier": "^3.1.3",
        jsdoc: "^3.5.5",
        "lodash.camelcase": "^4.3.0",
        mocha: "5.2.0",
        "mocha-sinon": "^2.1.0",
        "mongodb-extjson": "^2.1.1",
        "mongodb-mock-server": "^1.0.1",
        nyc: "^15.1.0",
        "object.entries": "^1.1.3",
        prettier: "^1.19.1",
        semver: "^5.5.0",
        sinon: "^4.3.0",
        "sinon-chai": "^3.2.0",
        snappy: "^6.3.4",
        "spec-xunit-file": "0.0.1-3",
        "standard-version": "^9.2.0",
        tslib: "^2.2.0",
        typescript: "^4.2.4",
        "util.promisify": "^1.0.1",
        "worker-farm": "^1.5.0",
        wtfnode: "^0.8.0",
        yargs: "^14.2.0"
      },
      engines: {
        node: ">=4"
      },
      files: [
        "index.js",
        "lib"
      ],
      homepage: "https://github.com/mongodb/node-mongodb-native",
      keywords: [
        "mongodb",
        "driver",
        "official"
      ],
      license: "Apache-2.0",
      main: "index.js",
      name: "mongodb",
      optionalDependencies: {
        saslprep: "^1.0.0"
      },
      peerDependenciesMeta: {
        kerberos: {
          optional: true
        },
        "mongodb-client-encryption": {
          optional: true
        },
        "mongodb-extjson": {
          optional: true
        },
        snappy: {
          optional: true
        },
        "bson-ext": {
          optional: true
        },
        aws4: {
          optional: true
        }
      },
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/mongodb/node-mongodb-native.git"
      },
      scripts: {
        "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
        "build:unified": "tsc -p test/functional/unified-spec-runner/tsconfig.unified.json",
        "check:atlas": "mocha --opts '{}' ./test/manual/atlas_connectivity.test.js",
        "check:bench": "node test/benchmarks/driverBench/",
        "check:coverage": "nyc npm run check:test",
        "check:kerberos": "mocha --opts '{}' -t 60000 test/manual/kerberos.test.js",
        "check:ldap": "mocha --opts '{}' test/manual/ldap.test.js",
        "check:lint": "eslint -v && eslint lib test",
        "check:test": "mocha --recursive test/functional test/unit",
        "check:tls": "mocha --opts '{}' test/manual/tls_support.test.js",
        format: "npm run check:lint -- --fix",
        release: "standard-version -i HISTORY.md",
        test: "npm run lint && mocha --recursive test/functional test/unit"
      },
      version: "3.6.9"
    };
  }
});

// node_modules/mongodb/lib/core/utils.js
var require_utils2 = __commonJS({
  "node_modules/mongodb/lib/core/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var os = __require("os");
    var crypto = __require("crypto");
    var requireOptional = require_optional_require()(__require);
    var uuidV4 = () => {
      const result = crypto.randomBytes(16);
      result[6] = result[6] & 15 | 64;
      result[8] = result[8] & 63 | 128;
      return result;
    };
    function relayEvents(listener, emitter, events) {
      events.forEach((eventName) => listener.on(eventName, (event) => emitter.emit(eventName, event)));
    }
    function retrieveKerberos() {
      let kerberos;
      try {
        kerberos = requireOptional("kerberos");
      } catch (err) {
        if (err.code === "MODULE_NOT_FOUND") {
          throw new Error("The `kerberos` module was not found. Please install it and try again.");
        }
        throw err;
      }
      return kerberos;
    }
    var noEJSONError = function() {
      throw new Error("The `mongodb-extjson` module was not found. Please install it and try again.");
    };
    function retrieveEJSON() {
      let EJSON = requireOptional("mongodb-extjson");
      if (!EJSON) {
        EJSON = {
          parse: noEJSONError,
          deserialize: noEJSONError,
          serialize: noEJSONError,
          stringify: noEJSONError,
          setBSONModule: noEJSONError,
          BSON: noEJSONError
        };
      }
      return EJSON;
    }
    function maxWireVersion(topologyOrServer) {
      if (topologyOrServer) {
        if (topologyOrServer.ismaster) {
          return topologyOrServer.ismaster.maxWireVersion;
        }
        if (typeof topologyOrServer.lastIsMaster === "function") {
          const lastIsMaster = topologyOrServer.lastIsMaster();
          if (lastIsMaster) {
            return lastIsMaster.maxWireVersion;
          }
        }
        if (topologyOrServer.description) {
          return topologyOrServer.description.maxWireVersion;
        }
      }
      return 0;
    }
    function collationNotSupported(server, cmd) {
      return cmd && cmd.collation && maxWireVersion(server) < 5;
    }
    function isPromiseLike(maybePromise) {
      return maybePromise && typeof maybePromise.then === "function";
    }
    function eachAsync(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = 0;
      for (idx = 0; idx < arr.length; ++idx) {
        awaiting++;
        eachFn(arr[idx], eachCallback);
      }
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
        }
      }
    }
    function eachAsyncSeries(arr, eachFn, callback) {
      arr = arr || [];
      let idx = 0;
      let awaiting = arr.length;
      if (awaiting === 0) {
        callback();
        return;
      }
      function eachCallback(err) {
        idx++;
        awaiting--;
        if (err) {
          callback(err);
          return;
        }
        if (idx === arr.length && awaiting <= 0) {
          callback();
          return;
        }
        eachFn(arr[idx], eachCallback);
      }
      eachFn(arr[idx], eachCallback);
    }
    function isUnifiedTopology(topology) {
      return topology.description != null;
    }
    function arrayStrictEqual(arr, arr2) {
      if (!Array.isArray(arr) || !Array.isArray(arr2)) {
        return false;
      }
      return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
    }
    function tagsStrictEqual(tags, tags2) {
      const tagsKeys = Object.keys(tags);
      const tags2Keys = Object.keys(tags2);
      return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
    }
    function errorStrictEqual(lhs, rhs) {
      if (lhs === rhs) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (lhs.constructor.name !== rhs.constructor.name) {
        return false;
      }
      if (lhs.message !== rhs.message) {
        return false;
      }
      return true;
    }
    function makeStateMachine(stateTable) {
      return function stateTransition(target, newState) {
        const legalStates = stateTable[target.s.state];
        if (legalStates && legalStates.indexOf(newState) < 0) {
          throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
        }
        target.emit("stateChanged", target.s.state, newState);
        target.s.state = newState;
      };
    }
    function makeClientMetadata(options2) {
      options2 = options2 || {};
      const metadata = {
        driver: {
          name: "nodejs",
          version: require_package().version
        },
        os: {
          type: os.type(),
          name: process.platform,
          architecture: process.arch,
          version: os.release()
        },
        platform: `'Node.js ${process.version}, ${os.endianness} (${options2.useUnifiedTopology ? "unified" : "legacy"})`
      };
      if (options2.driverInfo) {
        if (options2.driverInfo.name) {
          metadata.driver.name = `${metadata.driver.name}|${options2.driverInfo.name}`;
        }
        if (options2.driverInfo.version) {
          metadata.version = `${metadata.driver.version}|${options2.driverInfo.version}`;
        }
        if (options2.driverInfo.platform) {
          metadata.platform = `${metadata.platform}|${options2.driverInfo.platform}`;
        }
      }
      if (options2.appname) {
        const buffer2 = Buffer.from(options2.appname);
        metadata.application = {
          name: buffer2.length > 128 ? buffer2.slice(0, 128).toString("utf8") : options2.appname
        };
      }
      return metadata;
    }
    var noop4 = () => {
    };
    module2.exports = {
      uuidV4,
      relayEvents,
      collationNotSupported,
      retrieveEJSON,
      retrieveKerberos,
      maxWireVersion,
      isPromiseLike,
      eachAsync,
      eachAsyncSeries,
      isUnifiedTopology,
      arrayStrictEqual,
      tagsStrictEqual,
      errorStrictEqual,
      makeStateMachine,
      makeClientMetadata,
      noop: noop4
    };
  }
});

// node_modules/mongodb/lib/core/error.js
var require_error = __commonJS({
  "node_modules/mongodb/lib/core/error.js"(exports2, module2) {
    init_shims();
    "use strict";
    var kErrorLabels = Symbol("errorLabels");
    var MongoError = class extends Error {
      constructor(message) {
        if (message instanceof Error) {
          super(message.message);
          this.stack = message.stack;
        } else {
          if (typeof message === "string") {
            super(message);
          } else {
            super(message.message || message.errmsg || message.$err || "n/a");
            if (message.errorLabels) {
              this[kErrorLabels] = new Set(message.errorLabels);
            }
            for (var name2 in message) {
              if (name2 === "errorLabels" || name2 === "errmsg") {
                continue;
              }
              this[name2] = message[name2];
            }
          }
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "MongoError";
      }
      get errmsg() {
        return this.message;
      }
      static create(options2) {
        return new MongoError(options2);
      }
      hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          return false;
        }
        return this[kErrorLabels].has(label);
      }
      addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
          this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
      }
      get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
      }
    };
    var kBeforeHandshake = Symbol("beforeHandshake");
    function isNetworkErrorBeforeHandshake(err) {
      return err[kBeforeHandshake] === true;
    }
    var MongoNetworkError = class extends MongoError {
      constructor(message, options2) {
        super(message);
        this.name = "MongoNetworkError";
        if (options2 && typeof options2.beforeHandshake === "boolean") {
          this[kBeforeHandshake] = options2.beforeHandshake;
        }
      }
    };
    var MongoNetworkTimeoutError = class extends MongoNetworkError {
      constructor(message, options2) {
        super(message, options2);
        this.name = "MongoNetworkTimeoutError";
      }
    };
    var MongoParseError = class extends MongoError {
      constructor(message) {
        super(message);
        this.name = "MongoParseError";
      }
    };
    var MongoTimeoutError = class extends MongoError {
      constructor(message, reason) {
        if (reason && reason.error) {
          super(reason.error.message || reason.error);
        } else {
          super(message);
        }
        this.name = "MongoTimeoutError";
        if (reason) {
          this.reason = reason;
        }
      }
    };
    var MongoServerSelectionError = class extends MongoTimeoutError {
      constructor(message, reason) {
        super(message, reason);
        this.name = "MongoServerSelectionError";
      }
    };
    function makeWriteConcernResultObject(input) {
      const output = Object.assign({}, input);
      if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
      }
      return output;
    }
    var MongoWriteConcernError = class extends MongoError {
      constructor(message, result) {
        super(message);
        this.name = "MongoWriteConcernError";
        if (result && Array.isArray(result.errorLabels)) {
          this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
          this.result = makeWriteConcernResultObject(result);
        }
      }
    };
    var RETRYABLE_ERROR_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436
    ]);
    var RETRYABLE_WRITE_ERROR_CODES = new Set([
      11600,
      11602,
      10107,
      13435,
      13436,
      189,
      91,
      7,
      6,
      89,
      9001,
      262
    ]);
    function isRetryableWriteError(error3) {
      if (error3 instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error3.code) || RETRYABLE_WRITE_ERROR_CODES.has(error3.result.code);
      }
      return RETRYABLE_WRITE_ERROR_CODES.has(error3.code);
    }
    function isRetryableError(error3) {
      return RETRYABLE_ERROR_CODES.has(error3.code) || error3 instanceof MongoNetworkError || error3.message.match(/not master/) || error3.message.match(/node is recovering/);
    }
    var SDAM_RECOVERING_CODES = new Set([
      91,
      189,
      11600,
      11602,
      13436
    ]);
    var SDAM_NOTMASTER_CODES = new Set([
      10107,
      13435
    ]);
    var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
      11600,
      91
    ]);
    function isRecoveringError(err) {
      if (err.code && SDAM_RECOVERING_CODES.has(err.code)) {
        return true;
      }
      return err.message.match(/not master or secondary/) || err.message.match(/node is recovering/);
    }
    function isNotMasterError(err) {
      if (err.code && SDAM_NOTMASTER_CODES.has(err.code)) {
        return true;
      }
      if (isRecoveringError(err)) {
        return false;
      }
      return err.message.match(/not master/);
    }
    function isNodeShuttingDownError(err) {
      return err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code);
    }
    function isSDAMUnrecoverableError(error3) {
      if (error3 instanceof MongoParseError || error3 == null) {
        return true;
      }
      if (isRecoveringError(error3) || isNotMasterError(error3)) {
        return true;
      }
      return false;
    }
    module2.exports = {
      MongoError,
      MongoNetworkError,
      MongoNetworkTimeoutError,
      MongoParseError,
      MongoTimeoutError,
      MongoServerSelectionError,
      MongoWriteConcernError,
      isRetryableError,
      isSDAMUnrecoverableError,
      isNodeShuttingDownError,
      isRetryableWriteError,
      isNetworkErrorBeforeHandshake
    };
  }
});

// node_modules/mongodb/lib/core/connection/utils.js
var require_utils3 = __commonJS({
  "node_modules/mongodb/lib/core/connection/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var require_optional = require_optional_require()(__require);
    function debugOptions(debugFields, options2) {
      const finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    }
    function retrieveBSON() {
      const BSON2 = require_bson2();
      BSON2.native = false;
      const optionalBSON = require_optional("bson-ext");
      if (optionalBSON) {
        optionalBSON.native = true;
        return optionalBSON;
      }
      return BSON2;
    }
    function noSnappyWarning() {
      throw new Error("Attempted to use Snappy compression, but Snappy is not installed. Install or disable Snappy compression and try again.");
    }
    function retrieveSnappy() {
      let snappy = require_optional("snappy");
      if (!snappy) {
        snappy = {
          compress: noSnappyWarning,
          uncompress: noSnappyWarning,
          compressSync: noSnappyWarning,
          uncompressSync: noSnappyWarning
        };
      }
      return snappy;
    }
    module2.exports = {
      debugOptions,
      retrieveBSON,
      retrieveSnappy
    };
  }
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS({
  "node_modules/mongodb/lib/write_concern.js"(exports2, module2) {
    init_shims();
    "use strict";
    var kWriteConcernKeys = new Set(["w", "wtimeout", "j", "journal", "fsync"]);
    var utils2;
    var WriteConcern = class {
      constructor(w, wtimeout, j, fsync) {
        if (w != null) {
          this.w = w;
        }
        if (wtimeout != null) {
          this.wtimeout = wtimeout;
        }
        if (j != null) {
          this.j = j;
        }
        if (fsync != null) {
          this.fsync = fsync;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.writeConcern == null && options2.w == null && options2.wtimeout == null && options2.j == null && options2.journal == null && options2.fsync == null) {
          return;
        }
        if (options2.writeConcern) {
          if (typeof options2.writeConcern === "string") {
            return new WriteConcern(options2.writeConcern);
          }
          if (!Object.keys(options2.writeConcern).some((key) => kWriteConcernKeys.has(key))) {
            return;
          }
          return new WriteConcern(options2.writeConcern.w, options2.writeConcern.wtimeout, options2.writeConcern.j || options2.writeConcern.journal, options2.writeConcern.fsync);
        }
        if (!utils2)
          utils2 = require_utils4();
        utils2.emitWarningOnce(`Top-level use of w, wtimeout, j, and fsync is deprecated. Use writeConcern instead.`);
        return new WriteConcern(options2.w, options2.wtimeout, options2.j || options2.journal, options2.fsync);
      }
    };
    module2.exports = WriteConcern;
  }
});

// node_modules/mongodb/lib/async/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/mongodb/lib/async/async_iterator.js"(exports2) {
    init_shims();
    "use strict";
    function asyncIterator() {
      const cursor = this;
      return {
        next: function() {
          return Promise.resolve().then(() => cursor.next()).then((value) => {
            if (!value) {
              return cursor.close().then(() => ({ value, done: true }));
            }
            return { value, done: false };
          });
        }
      };
    }
    exports2.asyncIterator = asyncIterator;
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/mongodb/lib/utils.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var WriteConcern = require_write_concern();
    var shallowClone = function(obj) {
      var copy = {};
      for (var name2 in obj)
        copy[name2] = obj[name2];
      return copy;
    };
    var getSingleProperty = function(obj, name2, value) {
      Object.defineProperty(obj, name2, {
        enumerable: true,
        get: function() {
          return value;
        }
      });
    };
    var formatSortValue = exports2.formatSortValue = function(sortDirection) {
      var value = ("" + sortDirection).toLowerCase();
      switch (value) {
        case "ascending":
        case "asc":
        case "1":
          return 1;
        case "descending":
        case "desc":
        case "-1":
          return -1;
        default:
          throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
    };
    var formattedOrderClause = exports2.formattedOrderClause = function(sortValue) {
      var orderBy = new Map();
      if (sortValue == null)
        return null;
      if (Array.isArray(sortValue)) {
        if (sortValue.length === 0) {
          return null;
        }
        for (var i = 0; i < sortValue.length; i++) {
          if (sortValue[i].constructor === String) {
            orderBy.set(`${sortValue[i]}`, 1);
          } else {
            orderBy.set(`${sortValue[i][0]}`, formatSortValue(sortValue[i][1]));
          }
        }
      } else if (sortValue != null && typeof sortValue === "object") {
        if (sortValue instanceof Map) {
          orderBy = sortValue;
        } else {
          var sortKeys = Object.keys(sortValue);
          for (var k of sortKeys) {
            orderBy.set(k, sortValue[k]);
          }
        }
      } else if (typeof sortValue === "string") {
        orderBy.set(`${sortValue}`, 1);
      } else {
        throw new Error("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
      }
      return orderBy;
    };
    var checkCollectionName = function checkCollectionName2(collectionName) {
      if (typeof collectionName !== "string") {
        throw new MongoError("collection name must be a String");
      }
      if (!collectionName || collectionName.indexOf("..") !== -1) {
        throw new MongoError("collection names cannot be empty");
      }
      if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
        throw new MongoError("collection names must not contain '$'");
      }
      if (collectionName.match(/^\.|\.$/) != null) {
        throw new MongoError("collection names must not start or end with '.'");
      }
      if (collectionName.indexOf("\0") !== -1) {
        throw new MongoError("collection names cannot contain a null character");
      }
    };
    var handleCallback = function(callback, err, value1, value2) {
      try {
        if (callback == null)
          return;
        if (callback) {
          return value2 ? callback(err, value1, value2) : callback(err, value1);
        }
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
        return false;
      }
      return true;
    };
    var toError = function(error3) {
      if (error3 instanceof Error)
        return error3;
      var msg = error3.err || error3.errmsg || error3.errMessage || error3;
      var e = MongoError.create({ message: msg, driver: true });
      var keys = typeof error3 === "object" ? Object.keys(error3) : [];
      for (var i = 0; i < keys.length; i++) {
        try {
          e[keys[i]] = error3[keys[i]];
        } catch (err) {
        }
      }
      return e;
    };
    var normalizeHintField = function normalizeHintField2(hint) {
      var finalHint = null;
      if (typeof hint === "string") {
        finalHint = hint;
      } else if (Array.isArray(hint)) {
        finalHint = {};
        hint.forEach(function(param) {
          finalHint[param] = 1;
        });
      } else if (hint != null && typeof hint === "object") {
        finalHint = {};
        for (var name2 in hint) {
          finalHint[name2] = hint[name2];
        }
      }
      return finalHint;
    };
    var parseIndexOptions = function(fieldOrSpec) {
      var fieldHash = {};
      var indexes = [];
      var keys;
      if (typeof fieldOrSpec === "string") {
        indexes.push(fieldOrSpec + "_" + 1);
        fieldHash[fieldOrSpec] = 1;
      } else if (Array.isArray(fieldOrSpec)) {
        fieldOrSpec.forEach(function(f) {
          if (typeof f === "string") {
            indexes.push(f + "_" + 1);
            fieldHash[f] = 1;
          } else if (Array.isArray(f)) {
            indexes.push(f[0] + "_" + (f[1] || 1));
            fieldHash[f[0]] = f[1] || 1;
          } else if (isObject(f)) {
            keys = Object.keys(f);
            keys.forEach(function(k) {
              indexes.push(k + "_" + f[k]);
              fieldHash[k] = f[k];
            });
          } else {
          }
        });
      } else if (isObject(fieldOrSpec)) {
        keys = Object.keys(fieldOrSpec);
        keys.forEach(function(key) {
          indexes.push(key + "_" + fieldOrSpec[key]);
          fieldHash[key] = fieldOrSpec[key];
        });
      }
      return {
        name: indexes.join("_"),
        keys,
        fieldHash
      };
    };
    var isObject = exports2.isObject = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
    var debugOptions = function(debugFields, options2) {
      var finaloptions = {};
      debugFields.forEach(function(n) {
        finaloptions[n] = options2[n];
      });
      return finaloptions;
    };
    var decorateCommand = function(command, options2, exclude) {
      for (var name2 in options2) {
        if (exclude.indexOf(name2) === -1)
          command[name2] = options2[name2];
      }
      return command;
    };
    var mergeOptions = function(target, source) {
      for (var name2 in source) {
        target[name2] = source[name2];
      }
      return target;
    };
    var translateOptions = function(target, source) {
      var translations = {
        sslCA: "ca",
        sslCRL: "crl",
        sslValidate: "rejectUnauthorized",
        sslKey: "key",
        sslCert: "cert",
        sslPass: "passphrase",
        socketTimeoutMS: "socketTimeout",
        connectTimeoutMS: "connectionTimeout",
        replicaSet: "setName",
        rs_name: "setName",
        secondaryAcceptableLatencyMS: "acceptableLatency",
        connectWithNoPrimary: "secondaryOnlyConnectionAllowed",
        acceptableLatencyMS: "localThresholdMS"
      };
      for (var name2 in source) {
        if (translations[name2]) {
          target[translations[name2]] = source[name2];
        } else {
          target[name2] = source[name2];
        }
      }
      return target;
    };
    var filterOptions = function(options2, names) {
      var filterOptions2 = {};
      for (var name2 in options2) {
        if (names.indexOf(name2) !== -1)
          filterOptions2[name2] = options2[name2];
      }
      return filterOptions2;
    };
    var WRITE_CONCERN_KEYS = ["w", "j", "wtimeout", "fsync", "writeConcern"];
    function conditionallyMergeWriteConcern(target, source) {
      let found = false;
      for (const wcKey of WRITE_CONCERN_KEYS) {
        if (wcKey in target) {
          found = true;
          break;
        }
      }
      if (!found) {
        for (const wcKey of WRITE_CONCERN_KEYS) {
          if (source[wcKey]) {
            if (!("writeConcern" in target)) {
              target.writeConcern = {};
            }
            target.writeConcern[wcKey] = source[wcKey];
          }
        }
      }
      return target;
    }
    var executeLegacyOperation = (topology, operation, args, options2) => {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!Array.isArray(args)) {
        throw new TypeError("This method requires an array of arguments to apply");
      }
      options2 = options2 || {};
      const Promise2 = topology.s.promiseLibrary;
      let callback = args[args.length - 1];
      let session, opOptions, owner;
      if (!options2.skipSessions && topology.hasSessionSupport()) {
        opOptions = args[args.length - 2];
        if (opOptions == null || opOptions.session == null) {
          owner = Symbol();
          session = topology.startSession({ owner });
          const optionsIndex = args.length - 2;
          args[optionsIndex] = Object.assign({}, args[optionsIndex], { session });
        } else if (opOptions.session && opOptions.session.hasEnded) {
          throw new MongoError("Use of expired sessions is not permitted");
        }
      }
      const makeExecuteCallback = (resolve3, reject) => function executeCallback(err, result) {
        if (session && session.owner === owner && !options2.returnsCursor) {
          session.endSession(() => {
            delete opOptions.session;
            if (err)
              return reject(err);
            resolve3(result);
          });
        } else {
          if (err)
            return reject(err);
          resolve3(result);
        }
      };
      if (typeof callback === "function") {
        callback = args.pop();
        const handler = makeExecuteCallback((result) => callback(null, result), (err) => callback(err, null));
        args.push(handler);
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
          throw e;
        }
      }
      if (args[args.length - 1] != null) {
        throw new TypeError("final argument to `executeLegacyOperation` must be a callback");
      }
      return new Promise2(function(resolve3, reject) {
        const handler = makeExecuteCallback(resolve3, reject);
        args[args.length - 1] = handler;
        try {
          return operation.apply(null, args);
        } catch (e) {
          handler(e);
        }
      });
    };
    function applyRetryableWrites(target, db) {
      if (db && db.s.options.retryWrites) {
        target.retryWrites = true;
      }
      return target;
    }
    function applyWriteConcern(target, sources, options2) {
      options2 = options2 || {};
      const db = sources.db;
      const coll = sources.collection;
      if (options2.session && options2.session.inTransaction()) {
        if (target.writeConcern) {
          delete target.writeConcern;
        }
        return target;
      }
      const writeConcern = WriteConcern.fromOptions(options2);
      if (writeConcern) {
        return Object.assign(target, { writeConcern });
      }
      if (coll && coll.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });
      }
      if (db && db.writeConcern) {
        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });
      }
      return target;
    }
    function isPromiseLike(maybePromise2) {
      return maybePromise2 && typeof maybePromise2.then === "function";
    }
    function decorateWithCollation(command, target, options2) {
      const topology = target.s && target.s.topology || target.topology;
      if (!topology) {
        throw new TypeError('parameter "target" is missing a topology');
      }
      const capabilities = topology.capabilities();
      if (options2.collation && typeof options2.collation === "object") {
        if (capabilities && capabilities.commandsTakeCollation) {
          command.collation = options2.collation;
        } else {
          throw new MongoError(`Current topology does not support collation`);
        }
      }
    }
    function decorateWithReadConcern(command, coll, options2) {
      if (options2 && options2.session && options2.session.inTransaction()) {
        return;
      }
      let readConcern = Object.assign({}, command.readConcern || {});
      if (coll.s.readConcern) {
        Object.assign(readConcern, coll.s.readConcern);
      }
      if (Object.keys(readConcern).length > 0) {
        Object.assign(command, { readConcern });
      }
    }
    function decorateWithExplain(command, explain) {
      if (command.explain) {
        return command;
      }
      return { explain: command, verbosity: explain.verbosity };
    }
    var nodejsMajorVersion = +process.version.split(".")[0].substring(1);
    var emitProcessWarning = (msg) => nodejsMajorVersion <= 6 ? process.emitWarning(msg, "DeprecationWarning", MONGODB_WARNING_CODE) : process.emitWarning(msg, { type: "DeprecationWarning", code: MONGODB_WARNING_CODE });
    var emitConsoleWarning = (msg) => console.error(msg);
    var emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;
    function defaultMsgHandler(name2, option) {
      return `${name2} option [${option}] is deprecated and will be removed in a later version.`;
    }
    function deprecateOptions(config, fn) {
      if (process.noDeprecation === true) {
        return fn;
      }
      const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;
      const optionsWarned = new Set();
      function deprecated() {
        const options2 = arguments[config.optionsIndex];
        if (!isObject(options2) || Object.keys(options2).length === 0) {
          return fn.apply(this, arguments);
        }
        config.deprecatedOptions.forEach((deprecatedOption) => {
          if (Object.prototype.hasOwnProperty.call(options2, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {
            optionsWarned.add(deprecatedOption);
            const msg = msgHandler(config.name, deprecatedOption);
            emitDeprecationWarning(msg);
            if (this && this.getLogger) {
              const logger = this.getLogger();
              if (logger) {
                logger.warn(msg);
              }
            }
          }
        });
        return fn.apply(this, arguments);
      }
      Object.setPrototypeOf(deprecated, fn);
      if (fn.prototype) {
        deprecated.prototype = fn.prototype;
      }
      return deprecated;
    }
    var SUPPORTS = {};
    try {
      require_async_iterator();
      SUPPORTS.ASYNC_ITERATOR = true;
    } catch (e) {
      SUPPORTS.ASYNC_ITERATOR = false;
    }
    var MongoDBNamespace = class {
      constructor(db, collection) {
        this.db = db;
        this.collection = collection;
      }
      toString() {
        return this.collection ? `${this.db}.${this.collection}` : this.db;
      }
      withCollection(collection) {
        return new MongoDBNamespace(this.db, collection);
      }
      static fromString(namespace) {
        if (!namespace) {
          throw new Error(`Cannot parse namespace from "${namespace}"`);
        }
        const index2 = namespace.indexOf(".");
        return new MongoDBNamespace(namespace.substring(0, index2), namespace.substring(index2 + 1));
      }
    };
    function* makeCounter(seed) {
      let count = seed || 0;
      while (true) {
        const newCount = count;
        count += 1;
        yield newCount;
      }
    }
    function maybePromise(parent, callback, fn) {
      const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;
      let result;
      if (typeof callback !== "function") {
        result = new PromiseLibrary((resolve3, reject) => {
          callback = (err, res) => {
            if (err)
              return reject(err);
            resolve3(res);
          };
        });
      }
      fn(function(err, res) {
        if (err != null) {
          try {
            callback(err);
          } catch (error3) {
            return process.nextTick(() => {
              throw error3;
            });
          }
          return;
        }
        callback(err, res);
      });
      return result;
    }
    function now() {
      const hrtime = process.hrtime();
      return Math.floor(hrtime[0] * 1e3 + hrtime[1] / 1e6);
    }
    function calculateDurationInMs(started) {
      if (typeof started !== "number") {
        throw TypeError("numeric value required to calculate duration");
      }
      const elapsed = now() - started;
      return elapsed < 0 ? 0 : elapsed;
    }
    function makeInterruptableAsyncInterval(fn, options2) {
      let timerId;
      let lastCallTime;
      let lastWakeTime;
      let stopped = false;
      options2 = options2 || {};
      const interval = options2.interval || 1e3;
      const minInterval = options2.minInterval || 500;
      const immediate = typeof options2.immediate === "boolean" ? options2.immediate : false;
      const clock = typeof options2.clock === "function" ? options2.clock : now;
      function wake() {
        const currentTime = clock();
        const timeSinceLastWake = currentTime - lastWakeTime;
        const timeSinceLastCall = currentTime - lastCallTime;
        const timeUntilNextCall = interval - timeSinceLastCall;
        lastWakeTime = currentTime;
        if (timeSinceLastWake < minInterval) {
          return;
        }
        if (timeUntilNextCall > minInterval) {
          reschedule(minInterval);
        }
        if (timeUntilNextCall < 0) {
          executeAndReschedule();
        }
      }
      function stop() {
        stopped = true;
        if (timerId) {
          clearTimeout(timerId);
          timerId = null;
        }
        lastCallTime = 0;
        lastWakeTime = 0;
      }
      function reschedule(ms2) {
        if (stopped)
          return;
        clearTimeout(timerId);
        timerId = setTimeout(executeAndReschedule, ms2 || interval);
      }
      function executeAndReschedule() {
        lastWakeTime = 0;
        lastCallTime = clock();
        fn((err) => {
          if (err)
            throw err;
          reschedule(interval);
        });
      }
      if (immediate) {
        executeAndReschedule();
      } else {
        lastCallTime = clock();
        reschedule();
      }
      return { wake, stop };
    }
    function hasAtomicOperators(doc) {
      if (Array.isArray(doc)) {
        return doc.reduce((err, u) => err || hasAtomicOperators(u), null);
      }
      return Object.keys(typeof doc.toBSON !== "function" ? doc : doc.toBSON()).map((k) => k[0]).indexOf("$") >= 0;
    }
    var MONGODB_WARNING_CODE = "MONGODB DRIVER";
    function emitWarning(message) {
      if (process.emitWarning) {
        return nodejsMajorVersion <= 6 ? process.emitWarning(message, void 0, MONGODB_WARNING_CODE) : process.emitWarning(message, { code: MONGODB_WARNING_CODE });
      } else {
        return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);
      }
    }
    var emittedWarnings = new Set();
    function emitWarningOnce(message) {
      if (!emittedWarnings.has(message)) {
        emittedWarnings.add(message);
        return emitWarning(message);
      }
    }
    module2.exports = {
      filterOptions,
      mergeOptions,
      translateOptions,
      shallowClone,
      getSingleProperty,
      checkCollectionName,
      toError,
      formattedOrderClause,
      parseIndexOptions,
      normalizeHintField,
      handleCallback,
      decorateCommand,
      isObject,
      debugOptions,
      MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,
      conditionallyMergeWriteConcern,
      executeLegacyOperation,
      applyRetryableWrites,
      applyWriteConcern,
      isPromiseLike,
      decorateWithCollation,
      decorateWithReadConcern,
      decorateWithExplain,
      deprecateOptions,
      SUPPORTS,
      MongoDBNamespace,
      emitDeprecationWarning,
      makeCounter,
      maybePromise,
      now,
      calculateDurationInMs,
      makeInterruptableAsyncInterval,
      hasAtomicOperators,
      MONGODB_WARNING_CODE,
      emitWarning,
      emitWarningOnce
    };
  }
});

// node_modules/mongodb/lib/core/topologies/read_preference.js
var require_read_preference = __commonJS({
  "node_modules/mongodb/lib/core/topologies/read_preference.js"(exports2, module2) {
    init_shims();
    "use strict";
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var ReadPreference = function(mode, tags, options2) {
      if (!ReadPreference.isValid(mode)) {
        throw new TypeError(`Invalid read preference mode ${mode}`);
      }
      if (tags && !Array.isArray(tags)) {
        emitWarningOnce("ReadPreference tags must be an array, this will change in the next major version");
        const tagsHasMaxStalenessSeconds = typeof tags.maxStalenessSeconds !== "undefined";
        const tagsHasHedge = typeof tags.hedge !== "undefined";
        const tagsHasOptions = tagsHasMaxStalenessSeconds || tagsHasHedge;
        if (tagsHasOptions) {
          options2 = tags;
          tags = void 0;
        } else {
          tags = [tags];
        }
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options2 && options2.hedge;
      options2 = options2 || {};
      if (options2.maxStalenessSeconds != null) {
        if (options2.maxStalenessSeconds <= 0) {
          throw new TypeError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options2.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new TypeError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new TypeError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new TypeError("Primary read preference cannot be combined with hedge");
        }
      }
    };
    Object.defineProperty(ReadPreference.prototype, "preference", {
      enumerable: true,
      get: function() {
        return this.mode;
      }
    });
    ReadPreference.PRIMARY = "primary";
    ReadPreference.PRIMARY_PREFERRED = "primaryPreferred";
    ReadPreference.SECONDARY = "secondary";
    ReadPreference.SECONDARY_PREFERRED = "secondaryPreferred";
    ReadPreference.NEAREST = "nearest";
    var VALID_MODES = [
      ReadPreference.PRIMARY,
      ReadPreference.PRIMARY_PREFERRED,
      ReadPreference.SECONDARY,
      ReadPreference.SECONDARY_PREFERRED,
      ReadPreference.NEAREST,
      null
    ];
    ReadPreference.fromOptions = function(options2) {
      if (!options2)
        return null;
      const readPreference = options2.readPreference;
      if (!readPreference)
        return null;
      const readPreferenceTags = options2.readPreferenceTags;
      const maxStalenessSeconds = options2.maxStalenessSeconds;
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags);
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds || maxStalenessSeconds,
            hedge: readPreference.hedge
          });
        }
      }
      return readPreference;
    };
    ReadPreference.resolve = function(parent, options2) {
      options2 = options2 || {};
      const session = options2.session;
      const inheritedReadPreference = parent && parent.readPreference;
      let readPreference;
      if (options2.readPreference) {
        readPreference = ReadPreference.fromOptions(options2);
      } else if (session && session.inTransaction() && session.transaction.options.readPreference) {
        readPreference = session.transaction.options.readPreference;
      } else if (inheritedReadPreference != null) {
        readPreference = inheritedReadPreference;
      } else {
        readPreference = ReadPreference.primary;
      }
      return typeof readPreference === "string" ? new ReadPreference(readPreference) : readPreference;
    };
    ReadPreference.translate = function(options2) {
      if (options2.readPreference == null)
        return options2;
      const r = options2.readPreference;
      if (typeof r === "string") {
        options2.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options2.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new TypeError("Invalid read preference: " + r);
      }
      return options2;
    };
    ReadPreference.isValid = function(mode) {
      return VALID_MODES.indexOf(mode) !== -1;
    };
    ReadPreference.prototype.isValid = function(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    };
    var needSlaveOk = ["primaryPreferred", "secondary", "secondaryPreferred", "nearest"];
    ReadPreference.prototype.slaveOk = function() {
      return needSlaveOk.indexOf(this.mode) !== -1;
    };
    ReadPreference.prototype.equals = function(readPreference) {
      return readPreference.mode === this.mode;
    };
    ReadPreference.prototype.toJSON = function() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    };
    ReadPreference.primary = new ReadPreference("primary");
    ReadPreference.primaryPreferred = new ReadPreference("primaryPreferred");
    ReadPreference.secondary = new ReadPreference("secondary");
    ReadPreference.secondaryPreferred = new ReadPreference("secondaryPreferred");
    ReadPreference.nearest = new ReadPreference("nearest");
    module2.exports = ReadPreference;
  }
});

// node_modules/mongodb/lib/core/sdam/common.js
var require_common = __commonJS({
  "node_modules/mongodb/lib/core/sdam/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    var STATE_CLOSING = "closing";
    var STATE_CLOSED = "closed";
    var STATE_CONNECTING = "connecting";
    var STATE_CONNECTED = "connected";
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    function serverType(server) {
      let description = server.s.description || server.s.serverDescription;
      if (description.topologyType === TopologyType.Single)
        return description.servers[0].type;
      return description.type;
    }
    var TOPOLOGY_DEFAULTS = {
      useUnifiedTopology: true,
      localThresholdMS: 15,
      serverSelectionTimeoutMS: 3e4,
      heartbeatFrequencyMS: 1e4,
      minHeartbeatFrequencyMS: 500
    };
    function drainTimerQueue(queue) {
      queue.forEach(clearTimeout);
      queue.clear();
    }
    function clearAndRemoveTimerFrom(timer, timers) {
      clearTimeout(timer);
      return timers.delete(timer);
    }
    module2.exports = {
      STATE_CLOSING,
      STATE_CLOSED,
      STATE_CONNECTING,
      STATE_CONNECTED,
      TOPOLOGY_DEFAULTS,
      TopologyType,
      ServerType,
      serverType,
      drainTimerQueue,
      clearAndRemoveTimerFrom
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server_description.js
var require_server_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var arrayStrictEqual = require_utils2().arrayStrictEqual;
    var tagsStrictEqual = require_utils2().tagsStrictEqual;
    var errorStrictEqual = require_utils2().errorStrictEqual;
    var ServerType = require_common().ServerType;
    var now = require_utils4().now;
    var WRITABLE_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.Standalone,
      ServerType.Mongos
    ]);
    var DATA_BEARING_SERVER_TYPES = new Set([
      ServerType.RSPrimary,
      ServerType.RSSecondary,
      ServerType.Mongos,
      ServerType.Standalone
    ]);
    var ISMASTER_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "compression",
      "me",
      "hosts",
      "passives",
      "arbiters",
      "tags",
      "setName",
      "setVersion",
      "electionId",
      "primary",
      "logicalSessionTimeoutMinutes",
      "saslSupportedMechs",
      "__nodejs_mock_server__",
      "$clusterTime"
    ];
    var ServerDescription = class {
      constructor(address, ismaster, options2) {
        options2 = options2 || {};
        ismaster = Object.assign({
          minWireVersion: 0,
          maxWireVersion: 0,
          hosts: [],
          passives: [],
          arbiters: [],
          tags: []
        }, ismaster);
        this.address = address;
        this.error = options2.error;
        this.roundTripTime = options2.roundTripTime || -1;
        this.lastUpdateTime = now();
        this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;
        this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;
        this.type = parseServerType(ismaster);
        this.topologyVersion = options2.topologyVersion || ismaster.topologyVersion;
        ISMASTER_FIELDS.forEach((field) => {
          if (typeof ismaster[field] !== "undefined")
            this[field] = ismaster[field];
        });
        if (this.me)
          this.me = this.me.toLowerCase();
        this.hosts = this.hosts.map((host2) => host2.toLowerCase());
        this.passives = this.passives.map((host2) => host2.toLowerCase());
        this.arbiters = this.arbiters.map((host2) => host2.toLowerCase());
      }
      get allHosts() {
        return this.hosts.concat(this.arbiters).concat(this.passives);
      }
      get isReadable() {
        return this.type === ServerType.RSSecondary || this.isWritable;
      }
      get isDataBearing() {
        return DATA_BEARING_SERVER_TYPES.has(this.type);
      }
      get isWritable() {
        return WRITABLE_SERVER_TYPES.has(this.type);
      }
      get host() {
        const chopLength = `:${this.port}`.length;
        return this.address.slice(0, -chopLength);
      }
      get port() {
        const port2 = this.address.split(":").pop();
        return port2 ? Number.parseInt(port2, 10) : port2;
      }
      equals(other) {
        const topologyVersionsEqual = this.topologyVersion === other.topologyVersion || compareTopologyVersion(this.topologyVersion, other.topologyVersion) === 0;
        return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
      }
    };
    function parseServerType(ismaster) {
      if (!ismaster || !ismaster.ok) {
        return ServerType.Unknown;
      }
      if (ismaster.isreplicaset) {
        return ServerType.RSGhost;
      }
      if (ismaster.msg && ismaster.msg === "isdbgrid") {
        return ServerType.Mongos;
      }
      if (ismaster.setName) {
        if (ismaster.hidden) {
          return ServerType.RSOther;
        } else if (ismaster.ismaster) {
          return ServerType.RSPrimary;
        } else if (ismaster.secondary) {
          return ServerType.RSSecondary;
        } else if (ismaster.arbiterOnly) {
          return ServerType.RSArbiter;
        } else {
          return ServerType.RSOther;
        }
      }
      return ServerType.Standalone;
    }
    function compareTopologyVersion(lhs, rhs) {
      if (lhs == null || rhs == null) {
        return -1;
      }
      if (lhs.processId.equals(rhs.processId)) {
        if (lhs.counter === rhs.counter) {
          return 0;
        } else if (lhs.counter < rhs.counter) {
          return -1;
        }
        return 1;
      }
      return -1;
    }
    module2.exports = {
      ServerDescription,
      parseServerType,
      compareTopologyVersion
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/constants.js
var require_constants = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/constants.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MIN_SUPPORTED_SERVER_VERSION = "2.6";
    var MAX_SUPPORTED_SERVER_VERSION = "4.4";
    var MIN_SUPPORTED_WIRE_VERSION = 2;
    var MAX_SUPPORTED_WIRE_VERSION = 9;
    module2.exports = {
      MIN_SUPPORTED_SERVER_VERSION,
      MAX_SUPPORTED_SERVER_VERSION,
      MIN_SUPPORTED_WIRE_VERSION,
      MAX_SUPPORTED_WIRE_VERSION
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology_description.js
var require_topology_description = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var ServerDescription = require_server_description().ServerDescription;
    var WIRE_CONSTANTS = require_constants();
    var TopologyType = require_common().TopologyType;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var TopologyDescription = class {
      constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options2) {
        options2 = options2 || {};
        this.type = topologyType || TopologyType.Unknown;
        this.setName = setName || null;
        this.maxSetVersion = maxSetVersion || null;
        this.maxElectionId = maxElectionId || null;
        this.servers = serverDescriptions || new Map();
        this.stale = false;
        this.compatible = true;
        this.compatibilityError = null;
        this.logicalSessionTimeoutMinutes = null;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 0;
        this.localThresholdMS = options2.localThresholdMS || 0;
        this.commonWireVersion = commonWireVersion || null;
        Object.defineProperty(this, "options", { value: options2, enumberable: false });
        for (const serverDescription of this.servers.values()) {
          if (serverDescription.type === ServerType.Unknown)
            continue;
          if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
          }
          if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
            this.compatible = false;
            this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
            break;
          }
        }
        this.logicalSessionTimeoutMinutes = null;
        for (const addressServerTuple of this.servers) {
          const server = addressServerTuple[1];
          if (server.isReadable) {
            if (server.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = null;
              break;
            }
            if (this.logicalSessionTimeoutMinutes == null) {
              this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
              continue;
            }
            this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
          }
        }
      }
      updateFromSrvPollingEvent(ev) {
        const newAddresses = ev.addresses();
        const serverDescriptions = new Map(this.servers);
        for (const server of this.servers) {
          if (newAddresses.has(server[0])) {
            newAddresses.delete(server[0]);
          } else {
            serverDescriptions.delete(server[0]);
          }
        }
        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {
          return this;
        }
        for (const address of newAddresses) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);
      }
      update(serverDescription) {
        const address = serverDescription.address;
        let topologyType = this.type;
        let setName = this.setName;
        let maxSetVersion = this.maxSetVersion;
        let maxElectionId = this.maxElectionId;
        let commonWireVersion = this.commonWireVersion;
        if (serverDescription.setName && setName && serverDescription.setName !== setName) {
          serverDescription = new ServerDescription(address, null);
        }
        const serverType = serverDescription.type;
        let serverDescriptions = new Map(this.servers);
        if (serverDescription.maxWireVersion !== 0) {
          if (commonWireVersion == null) {
            commonWireVersion = serverDescription.maxWireVersion;
          } else {
            commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
          }
        }
        serverDescriptions.set(address, serverDescription);
        if (topologyType === TopologyType.Single) {
          return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
        }
        if (topologyType === TopologyType.Unknown) {
          if (serverType === ServerType.Standalone && this.servers.size !== 1) {
            serverDescriptions.delete(address);
          } else {
            topologyType = topologyTypeForServerType(serverType);
          }
        }
        if (topologyType === TopologyType.Sharded) {
          if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {
            serverDescriptions.delete(address);
          }
        }
        if (topologyType === TopologyType.ReplicaSetNoPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
          }
          if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);
            topologyType = result[0], setName = result[1];
          }
        }
        if (topologyType === TopologyType.ReplicaSetWithPrimary) {
          if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {
            serverDescriptions.delete(address);
            topologyType = checkHasPrimary(serverDescriptions);
          } else if (serverType === ServerType.RSPrimary) {
            const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);
            topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];
          } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {
            topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);
          } else {
            topologyType = checkHasPrimary(serverDescriptions);
          }
        }
        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);
      }
      get error() {
        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
        if (descriptionsWithError.length > 0) {
          return descriptionsWithError[0].error;
        }
        return void 0;
      }
      get hasKnownServers() {
        return Array.from(this.servers.values()).some((sd) => sd.type !== ServerType.Unknown);
      }
      get hasDataBearingServers() {
        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
      }
      hasServer(address) {
        return this.servers.has(address);
      }
    };
    function topologyTypeForServerType(serverType) {
      if (serverType === ServerType.Standalone) {
        return TopologyType.Single;
      }
      if (serverType === ServerType.Mongos) {
        return TopologyType.Sharded;
      }
      if (serverType === ServerType.RSPrimary) {
        return TopologyType.ReplicaSetWithPrimary;
      }
      if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function compareObjectId(oid1, oid2) {
      if (oid1 == null) {
        return -1;
      }
      if (oid2 == null) {
        return 1;
      }
      if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {
        const oid1Buffer = oid1.id;
        const oid2Buffer = oid2.id;
        return oid1Buffer.compare(oid2Buffer);
      }
      const oid1String = oid1.toString();
      const oid2String = oid2.toString();
      return oid1String.localeCompare(oid2String);
    }
    function updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
      for (const address of serverDescriptions.keys()) {
        const server = serverDescriptions.get(address);
        if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {
          serverDescriptions.set(address, new ServerDescription(server.address));
          break;
        }
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      const currentAddresses = Array.from(serverDescriptions.keys());
      const responseAddresses = serverDescription.allHosts;
      currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
        serverDescriptions.delete(address);
      });
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    function updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      if (setName == null) {
        throw new TypeError("setName is required");
      }
      if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return checkHasPrimary(serverDescriptions);
    }
    function updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {
      let topologyType = TopologyType.ReplicaSetNoPrimary;
      setName = setName || serverDescription.setName;
      if (setName !== serverDescription.setName) {
        serverDescriptions.delete(serverDescription.address);
        return [topologyType, setName];
      }
      serverDescription.allHosts.forEach((address) => {
        if (!serverDescriptions.has(address)) {
          serverDescriptions.set(address, new ServerDescription(address));
        }
      });
      if (serverDescription.me && serverDescription.address !== serverDescription.me) {
        serverDescriptions.delete(serverDescription.address);
      }
      return [topologyType, setName];
    }
    function checkHasPrimary(serverDescriptions) {
      for (const addr of serverDescriptions.keys()) {
        if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {
          return TopologyType.ReplicaSetWithPrimary;
        }
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    module2.exports = {
      TopologyDescription
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/shared.js
var require_shared = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/shared.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var MESSAGE_HEADER_SIZE = 16;
    var COMPRESSION_DETAILS_SIZE = 9;
    var opcodes = {
      OP_REPLY: 1,
      OP_UPDATE: 2001,
      OP_INSERT: 2002,
      OP_QUERY: 2004,
      OP_GETMORE: 2005,
      OP_DELETE: 2006,
      OP_KILL_CURSORS: 2007,
      OP_COMPRESSED: 2012,
      OP_MSG: 2013
    };
    var getReadPreference = function(cmd, options2) {
      var readPreference = cmd.readPreference || new ReadPreference("primary");
      if (options2.readPreference) {
        readPreference = options2.readPreference;
      }
      if (typeof readPreference === "string") {
        readPreference = new ReadPreference(readPreference);
      }
      if (!(readPreference instanceof ReadPreference)) {
        throw new MongoError("read preference must be a ReadPreference instance");
      }
      return readPreference;
    };
    var parseHeader = function(message) {
      return {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
    };
    function applyCommonQueryOptions(queryOptions, options2) {
      Object.assign(queryOptions, {
        raw: typeof options2.raw === "boolean" ? options2.raw : false,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : false,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false
      });
      if (typeof options2.socketTimeout === "number") {
        queryOptions.socketTimeout = options2.socketTimeout;
      }
      if (options2.session) {
        queryOptions.session = options2.session;
      }
      if (typeof options2.documentsReturnedIn === "string") {
        queryOptions.documentsReturnedIn = options2.documentsReturnedIn;
      }
      return queryOptions;
    }
    function isSharded(topologyOrServer) {
      if (topologyOrServer.type === "mongos")
        return true;
      if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {
        return true;
      }
      if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {
        const servers = Array.from(topologyOrServer.description.servers.values());
        return servers.some((server) => server.type === ServerType.Mongos);
      }
      return false;
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    module2.exports = {
      getReadPreference,
      MESSAGE_HEADER_SIZE,
      COMPRESSION_DETAILS_SIZE,
      opcodes,
      parseHeader,
      applyCommonQueryOptions,
      isSharded,
      databaseNamespace,
      collectionNamespace
    };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/compression.js
var require_compression = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/compression.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Snappy = require_utils3().retrieveSnappy();
    var zlib3 = __require("zlib");
    var compressorIDs = {
      snappy: 1,
      zlib: 2
    };
    var uncompressibleCommands = new Set([
      "ismaster",
      "saslStart",
      "saslContinue",
      "getnonce",
      "authenticate",
      "createUser",
      "updateUser",
      "copydbSaslStart",
      "copydbgetnonce",
      "copydb"
    ]);
    function compress(self2, dataToBeCompressed, callback) {
      switch (self2.options.agreedCompressor) {
        case "snappy":
          Snappy.compress(dataToBeCompressed, callback);
          break;
        case "zlib":
          var zlibOptions = {};
          if (self2.options.zlibCompressionLevel) {
            zlibOptions.level = self2.options.zlibCompressionLevel;
          }
          zlib3.deflate(dataToBeCompressed, zlibOptions, callback);
          break;
        default:
          throw new Error('Attempt to compress message using unknown compressor "' + self2.options.agreedCompressor + '".');
      }
    }
    function decompress(compressorID, compressedData, callback) {
      if (compressorID < 0 || compressorID > compressorIDs.length) {
        throw new Error("Server sent message compressed using an unsupported compressor. (Received compressor ID " + compressorID + ")");
      }
      switch (compressorID) {
        case compressorIDs.snappy:
          Snappy.uncompress(compressedData, callback);
          break;
        case compressorIDs.zlib:
          zlib3.inflate(compressedData, callback);
          break;
        default:
          callback(null, compressedData);
      }
    }
    module2.exports = {
      compressorIDs,
      uncompressibleCommands,
      compress,
      decompress
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_shims();
    var buffer2 = __require("buffer");
    var Buffer2 = buffer2.Buffer;
    function copyProps(src3, dst) {
      for (var key in src3) {
        dst[key] = src3[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding3) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding3 === "string") {
          buf.fill(fill, encoding3);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/mongodb/lib/core/connection/commands.js
var require_commands = __commonJS({
  "node_modules/mongodb/lib/core/connection/commands.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var Buffer2 = require_safe_buffer().Buffer;
    var _requestId = 0;
    var opcodes = require_shared().opcodes;
    var OPTS_TAILABLE_CURSOR = 2;
    var OPTS_SLAVE = 4;
    var OPTS_OPLOG_REPLAY = 8;
    var OPTS_NO_CURSOR_TIMEOUT = 16;
    var OPTS_AWAIT_DATA = 32;
    var OPTS_EXHAUST = 64;
    var OPTS_PARTIAL = 128;
    var CURSOR_NOT_FOUND = 1;
    var QUERY_FAILURE = 2;
    var SHARD_CONFIG_STALE = 4;
    var AWAIT_CAPABLE = 8;
    var Query = function(bson, ns, query, options2) {
      var self2 = this;
      if (ns == null)
        throw new Error("ns must be specified for query");
      if (query == null)
        throw new Error("query must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new Error("namespace cannot contain a null character");
      }
      this.bson = bson;
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options2.numberToSkip || 0;
      this.numberToReturn = options2.numberToReturn || 0;
      this.returnFieldSelector = options2.returnFieldSelector || null;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options2.pre32Limit;
      this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : true;
      this.batchSize = self2.numberToReturn;
      this.tailable = false;
      this.slaveOk = typeof options2.slaveOk === "boolean" ? options2.slaveOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    };
    Query.prototype.incRequestId = function() {
      this.requestId = _requestId++;
    };
    Query.nextRequestId = function() {
      return _requestId + 1;
    };
    Query.prototype.toBin = function() {
      var self2 = this;
      var buffers = [];
      var projection = null;
      var flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.slaveOk) {
        flags |= OPTS_SLAVE;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (self2.batchSize !== self2.numberToReturn)
        self2.numberToReturn = self2.batchSize;
      var header = Buffer2.alloc(4 * 4 + 4 + Buffer2.byteLength(self2.ns) + 1 + 4 + 4);
      buffers.push(header);
      var query = self2.bson.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (self2.returnFieldSelector && Object.keys(self2.returnFieldSelector).length > 0) {
        projection = self2.bson.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      var totalLength = header.length + query.length + (projection ? projection.length : 0);
      var index2 = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index2 + 3] = this.requestId >> 24 & 255;
      header[index2 + 2] = this.requestId >> 16 & 255;
      header[index2 + 1] = this.requestId >> 8 & 255;
      header[index2] = this.requestId & 255;
      index2 = index2 + 4;
      header[index2 + 3] = 0 >> 24 & 255;
      header[index2 + 2] = 0 >> 16 & 255;
      header[index2 + 1] = 0 >> 8 & 255;
      header[index2] = 0 & 255;
      index2 = index2 + 4;
      header[index2 + 3] = opcodes.OP_QUERY >> 24 & 255;
      header[index2 + 2] = opcodes.OP_QUERY >> 16 & 255;
      header[index2 + 1] = opcodes.OP_QUERY >> 8 & 255;
      header[index2] = opcodes.OP_QUERY & 255;
      index2 = index2 + 4;
      header[index2 + 3] = flags >> 24 & 255;
      header[index2 + 2] = flags >> 16 & 255;
      header[index2 + 1] = flags >> 8 & 255;
      header[index2] = flags & 255;
      index2 = index2 + 4;
      index2 = index2 + header.write(this.ns, index2, "utf8") + 1;
      header[index2 - 1] = 0;
      header[index2 + 3] = this.numberToSkip >> 24 & 255;
      header[index2 + 2] = this.numberToSkip >> 16 & 255;
      header[index2 + 1] = this.numberToSkip >> 8 & 255;
      header[index2] = this.numberToSkip & 255;
      index2 = index2 + 4;
      header[index2 + 3] = this.numberToReturn >> 24 & 255;
      header[index2 + 2] = this.numberToReturn >> 16 & 255;
      header[index2 + 1] = this.numberToReturn >> 8 & 255;
      header[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      return buffers;
    };
    Query.getRequestId = function() {
      return ++_requestId;
    };
    var GetMore = function(bson, ns, cursorId, opts) {
      opts = opts || {};
      this.numberToReturn = opts.numberToReturn || 0;
      this.requestId = _requestId++;
      this.bson = bson;
      this.ns = ns;
      this.cursorId = cursorId;
    };
    GetMore.prototype.toBin = function() {
      var length = 4 + Buffer2.byteLength(this.ns) + 1 + 4 + 8 + 4 * 4;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_GETMORE >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_GETMORE >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_GETMORE >> 8 & 255;
      _buffer[index2] = opcodes.OP_GETMORE & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      index2 = index2 + _buffer.write(this.ns, index2, "utf8") + 1;
      _buffer[index2 - 1] = 0;
      _buffer[index2 + 3] = this.numberToReturn >> 24 & 255;
      _buffer[index2 + 2] = this.numberToReturn >> 16 & 255;
      _buffer[index2 + 1] = this.numberToReturn >> 8 & 255;
      _buffer[index2] = this.numberToReturn & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getLowBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getLowBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getLowBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getLowBits() & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorId.getHighBits() >> 24 & 255;
      _buffer[index2 + 2] = this.cursorId.getHighBits() >> 16 & 255;
      _buffer[index2 + 1] = this.cursorId.getHighBits() >> 8 & 255;
      _buffer[index2] = this.cursorId.getHighBits() & 255;
      index2 = index2 + 4;
      return _buffer;
    };
    var KillCursor = function(bson, ns, cursorIds) {
      this.ns = ns;
      this.requestId = _requestId++;
      this.cursorIds = cursorIds;
    };
    KillCursor.prototype.toBin = function() {
      var length = 4 + 4 + 4 * 4 + this.cursorIds.length * 8;
      var index2 = 0;
      var _buffer = Buffer2.alloc(length);
      _buffer[index2 + 3] = length >> 24 & 255;
      _buffer[index2 + 2] = length >> 16 & 255;
      _buffer[index2 + 1] = length >> 8 & 255;
      _buffer[index2] = length & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.requestId >> 24 & 255;
      _buffer[index2 + 2] = this.requestId >> 16 & 255;
      _buffer[index2 + 1] = this.requestId >> 8 & 255;
      _buffer[index2] = this.requestId & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = opcodes.OP_KILL_CURSORS >> 24 & 255;
      _buffer[index2 + 2] = opcodes.OP_KILL_CURSORS >> 16 & 255;
      _buffer[index2 + 1] = opcodes.OP_KILL_CURSORS >> 8 & 255;
      _buffer[index2] = opcodes.OP_KILL_CURSORS & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = 0 >> 24 & 255;
      _buffer[index2 + 2] = 0 >> 16 & 255;
      _buffer[index2 + 1] = 0 >> 8 & 255;
      _buffer[index2] = 0 & 255;
      index2 = index2 + 4;
      _buffer[index2 + 3] = this.cursorIds.length >> 24 & 255;
      _buffer[index2 + 2] = this.cursorIds.length >> 16 & 255;
      _buffer[index2 + 1] = this.cursorIds.length >> 8 & 255;
      _buffer[index2] = this.cursorIds.length & 255;
      index2 = index2 + 4;
      for (var i = 0; i < this.cursorIds.length; i++) {
        _buffer[index2 + 3] = this.cursorIds[i].getLowBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getLowBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getLowBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getLowBits() & 255;
        index2 = index2 + 4;
        _buffer[index2 + 3] = this.cursorIds[i].getHighBits() >> 24 & 255;
        _buffer[index2 + 2] = this.cursorIds[i].getHighBits() >> 16 & 255;
        _buffer[index2 + 1] = this.cursorIds[i].getHighBits() >> 8 & 255;
        _buffer[index2] = this.cursorIds[i].getHighBits() & 255;
        index2 = index2 + 4;
      }
      return _buffer;
    };
    var Response3 = function(bson, message, msgHeader, msgBody, opts) {
      opts = opts || { promoteLongs: true, promoteValues: true, promoteBuffers: false };
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.bson = bson;
      this.opts = opts;
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.cursorId = new Long2(msgBody.readInt32LE(4), msgBody.readInt32LE(8));
      this.startingFrom = msgBody.readInt32LE(12);
      this.numberReturned = msgBody.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
      this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
      this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
    };
    Response3.prototype.isParsed = function() {
      return this.parsed;
    };
    Response3.prototype.parse = function(options2) {
      if (this.parsed)
        return;
      options2 = options2 || {};
      var raw = options2.raw || false;
      var documentsReturnedIn = options2.documentsReturnedIn || null;
      var promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
      var promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
      var promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
      var bsonSize, _options;
      _options = {
        promoteLongs,
        promoteValues,
        promoteBuffers
      };
      this.index = 20;
      for (var i = 0; i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = this.bson.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    };
    module2.exports = {
      Query,
      GetMore,
      Response: Response3,
      KillCursor
    };
  }
});

// node_modules/mongodb/lib/core/connection/msg.js
var require_msg = __commonJS({
  "node_modules/mongodb/lib/core/connection/msg.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var opcodes = require_shared().opcodes;
    var databaseNamespace = require_shared().databaseNamespace;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var _requestId = 0;
    var OPTS_CHECKSUM_PRESENT = 1;
    var OPTS_MORE_TO_COME = 2;
    var OPTS_EXHAUST_ALLOWED = 1 << 16;
    var Msg = class {
      constructor(bson, ns, command, options2) {
        if (command == null)
          throw new Error("query must be specified for query");
        this.bson = bson;
        this.ns = ns;
        this.command = command;
        this.command.$db = databaseNamespace(ns);
        if (options2.readPreference && options2.readPreference.mode !== ReadPreference.PRIMARY) {
          this.command.$readPreference = options2.readPreference.toJSON();
        }
        this.options = options2 || {};
        this.requestId = options2.requestId ? options2.requestId : Msg.getRequestId();
        this.serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
        this.ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
        this.checkKeys = typeof options2.checkKeys === "boolean" ? options2.checkKeys : false;
        this.maxBsonSize = options2.maxBsonSize || 1024 * 1024 * 16;
        this.checksumPresent = false;
        this.moreToCome = options2.moreToCome || false;
        this.exhaustAllowed = typeof options2.exhaustAllowed === "boolean" ? options2.exhaustAllowed : false;
      }
      toBin() {
        const buffers = [];
        let flags = 0;
        if (this.checksumPresent) {
          flags |= OPTS_CHECKSUM_PRESENT;
        }
        if (this.moreToCome) {
          flags |= OPTS_MORE_TO_COME;
        }
        if (this.exhaustAllowed) {
          flags |= OPTS_EXHAUST_ALLOWED;
        }
        const header = Buffer2.alloc(4 * 4 + 4);
        buffers.push(header);
        let totalLength = header.length;
        const command = this.command;
        totalLength += this.makeDocumentSegment(buffers, command);
        header.writeInt32LE(totalLength, 0);
        header.writeInt32LE(this.requestId, 4);
        header.writeInt32LE(0, 8);
        header.writeInt32LE(opcodes.OP_MSG, 12);
        header.writeUInt32LE(flags, 16);
        return buffers;
      }
      makeDocumentSegment(buffers, document2) {
        const payloadTypeBuffer = Buffer2.alloc(1);
        payloadTypeBuffer[0] = 0;
        const documentBuffer = this.serializeBson(document2);
        buffers.push(payloadTypeBuffer);
        buffers.push(documentBuffer);
        return payloadTypeBuffer.length + documentBuffer.length;
      }
      serializeBson(document2) {
        return this.bson.serialize(document2, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
      }
    };
    Msg.getRequestId = function() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    };
    var BinMsg = class {
      constructor(bson, message, msgHeader, msgBody, opts) {
        opts = opts || { promoteLongs: true, promoteValues: true, promoteBuffers: false };
        this.parsed = false;
        this.raw = message;
        this.data = msgBody;
        this.bson = bson;
        this.opts = opts;
        this.length = msgHeader.length;
        this.requestId = msgHeader.requestId;
        this.responseTo = msgHeader.responseTo;
        this.opCode = msgHeader.opCode;
        this.fromCompressed = msgHeader.fromCompressed;
        this.responseFlags = msgBody.readInt32LE(0);
        this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
        this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
        this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
        this.promoteLongs = typeof opts.promoteLongs === "boolean" ? opts.promoteLongs : true;
        this.promoteValues = typeof opts.promoteValues === "boolean" ? opts.promoteValues : true;
        this.promoteBuffers = typeof opts.promoteBuffers === "boolean" ? opts.promoteBuffers : false;
        this.documents = [];
      }
      isParsed() {
        return this.parsed;
      }
      parse(options2) {
        if (this.parsed)
          return;
        options2 = options2 || {};
        this.index = 4;
        const raw = options2.raw || false;
        const documentsReturnedIn = options2.documentsReturnedIn || null;
        const promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : this.opts.promoteLongs;
        const promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : this.opts.promoteValues;
        const promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : this.opts.promoteBuffers;
        const _options = {
          promoteLongs,
          promoteValues,
          promoteBuffers
        };
        while (this.index < this.data.length) {
          const payloadType = this.data.readUInt8(this.index++);
          if (payloadType === 1) {
            throw new MongoError("OP_MSG Payload Type 1 detected unsupported protocol");
          } else if (payloadType === 0) {
            const bsonSize = this.data.readUInt32LE(this.index);
            const bin = this.data.slice(this.index, this.index + bsonSize);
            this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));
            this.index += bsonSize;
          }
        }
        if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
          const fieldsAsRaw = {};
          fieldsAsRaw[documentsReturnedIn] = true;
          _options.fieldsAsRaw = fieldsAsRaw;
          const doc = this.bson.deserialize(this.documents[0], _options);
          this.documents = [doc];
        }
        this.parsed = true;
      }
    };
    module2.exports = { Msg, BinMsg };
  }
});

// node_modules/mongodb/lib/core/connection/logger.js
var require_logger = __commonJS({
  "node_modules/mongodb/lib/core/connection/logger.js"(exports2, module2) {
    init_shims();
    "use strict";
    var f = __require("util").format;
    var MongoError = require_error().MongoError;
    var classFilters = {};
    var filteredClasses = {};
    var level = null;
    var pid = process.pid;
    var currentLogger = null;
    var Logger = function(className, options2) {
      if (!(this instanceof Logger))
        return new Logger(className, options2);
      options2 = options2 || {};
      this.className = className;
      if (options2.logger) {
        currentLogger = options2.logger;
      } else if (currentLogger == null) {
        currentLogger = console.log;
      }
      if (options2.loggerLevel) {
        level = options2.loggerLevel || "error";
      }
      if (filteredClasses[this.className] == null)
        classFilters[this.className] = true;
    };
    Logger.prototype.debug = function(message, object) {
      if (this.isDebug() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "DEBUG", this.className, pid, dateTime, message);
        var state = {
          type: "debug",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    };
    Logger.prototype.warn = function(message, object) {
      if (this.isWarn() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "WARN", this.className, pid, dateTime, message);
        var state = {
          type: "warn",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.info = function(message, object) {
      if (this.isInfo() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "INFO", this.className, pid, dateTime, message);
        var state = {
          type: "info",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.error = function(message, object) {
      if (this.isError() && (Object.keys(filteredClasses).length > 0 && filteredClasses[this.className] || Object.keys(filteredClasses).length === 0 && classFilters[this.className])) {
        var dateTime = new Date().getTime();
        var msg = f("[%s-%s:%s] %s %s", "ERROR", this.className, pid, dateTime, message);
        var state = {
          type: "error",
          message,
          className: this.className,
          pid,
          date: dateTime
        };
        if (object)
          state.meta = object;
        currentLogger(msg, state);
      }
    }, Logger.prototype.isInfo = function() {
      return level === "info" || level === "debug";
    }, Logger.prototype.isError = function() {
      return level === "error" || level === "info" || level === "debug";
    }, Logger.prototype.isWarn = function() {
      return level === "error" || level === "warn" || level === "info" || level === "debug";
    }, Logger.prototype.isDebug = function() {
      return level === "debug";
    };
    Logger.reset = function() {
      level = "error";
      filteredClasses = {};
    };
    Logger.currentLogger = function() {
      return currentLogger;
    };
    Logger.setCurrentLogger = function(logger) {
      if (typeof logger !== "function")
        throw new MongoError("current logger must be a function");
      currentLogger = logger;
    };
    Logger.filter = function(type, values) {
      if (type === "class" && Array.isArray(values)) {
        filteredClasses = {};
        values.forEach(function(x) {
          filteredClasses[x] = true;
        });
      }
    };
    Logger.setLevel = function(_level) {
      if (_level !== "info" && _level !== "error" && _level !== "debug" && _level !== "warn") {
        throw new Error(f("%s is an illegal logging level", _level));
      }
      level = _level;
    };
    module2.exports = Logger;
  }
});

// node_modules/mongodb/lib/core/connection/command_result.js
var require_command_result = __commonJS({
  "node_modules/mongodb/lib/core/connection/command_result.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandResult = function(result, connection2, message) {
      this.result = result;
      this.connection = connection2;
      this.message = message;
    };
    CommandResult.prototype.toJSON = function() {
      let result = Object.assign({}, this, this.result);
      delete result.message;
      return result;
    };
    CommandResult.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    module2.exports = CommandResult;
  }
});

// node_modules/mongodb/lib/core/connection/connection.js
var require_connection = __commonJS({
  "node_modules/mongodb/lib/core/connection/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var crypto = __require("crypto");
    var debugOptions = require_utils3().debugOptions;
    var parseHeader = require_shared().parseHeader;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoError = require_error().MongoError;
    var Logger = require_logger();
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var Buffer2 = require_safe_buffer().Buffer;
    var Query = require_commands().Query;
    var CommandResult = require_command_result();
    var _id = 0;
    var DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;
    var DEBUG_FIELDS = [
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "checkServerIdentity"
    ];
    var connectionAccountingSpy = void 0;
    var connectionAccounting = false;
    var connections = {};
    var Connection = class extends EventEmitter {
      constructor(socket, options2) {
        super();
        options2 = options2 || {};
        if (!options2.bson) {
          throw new TypeError("must pass in valid bson parser");
        }
        this.id = _id++;
        this.options = options2;
        this.logger = Logger("Connection", options2);
        this.bson = options2.bson;
        this.tag = options2.tag;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;
        this.port = options2.port || 27017;
        this.host = options2.host || "localhost";
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
        this.keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
        this.connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : 3e4;
        if (this.keepAliveInitialDelay > this.socketTimeout) {
          this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);
        }
        if (this.logger.isDebug()) {
          this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options2))}]`);
        }
        this.responseOptions = {
          promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
          promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
          promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false
        };
        this.flushing = false;
        this.queue = [];
        this.writeStream = null;
        this.destroyed = false;
        this.timedOut = false;
        const hash2 = crypto.createHash("sha1");
        hash2.update(this.address);
        this.hashedName = hash2.digest("hex");
        this.workItems = [];
        this.socket = socket;
        this.socket.once("error", errorHandler(this));
        this.socket.once("timeout", timeoutHandler(this));
        this.socket.once("close", closeHandler(this));
        this.socket.on("data", dataHandler(this));
        if (connectionAccounting) {
          addConnection(this.id, this);
        }
      }
      setSocketTimeout(value) {
        if (this.socket) {
          this.socket.setTimeout(value);
        }
      }
      resetSocketTimeout() {
        if (this.socket) {
          this.socket.setTimeout(this.socketTimeout);
        }
      }
      static enableConnectionAccounting(spy) {
        if (spy) {
          connectionAccountingSpy = spy;
        }
        connectionAccounting = true;
        connections = {};
      }
      static disableConnectionAccounting() {
        connectionAccounting = false;
        connectionAccountingSpy = void 0;
      }
      static connections() {
        return connections;
      }
      get address() {
        return `${this.host}:${this.port}`;
      }
      unref() {
        if (this.socket == null) {
          this.once("connect", () => this.socket.unref());
          return;
        }
        this.socket.unref();
      }
      flush(err) {
        while (this.workItems.length > 0) {
          const workItem = this.workItems.shift();
          if (workItem.cb) {
            workItem.cb(err);
          }
        }
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({ force: false }, options2);
        if (connectionAccounting) {
          deleteConnection(this.id);
        }
        if (this.socket == null) {
          this.destroyed = true;
          return;
        }
        if (options2.force || this.timedOut) {
          this.socket.destroy();
          this.destroyed = true;
          if (typeof callback === "function")
            callback(null, null);
          return;
        }
        this.socket.end((err) => {
          this.destroyed = true;
          if (typeof callback === "function")
            callback(err, null);
        });
      }
      write(buffer2) {
        if (this.logger.isDebug()) {
          if (!Array.isArray(buffer2)) {
            this.logger.debug(`writing buffer [${buffer2.toString("hex")}] to ${this.address}`);
          } else {
            for (let i = 0; i < buffer2.length; i++)
              this.logger.debug(`writing buffer [${buffer2[i].toString("hex")}] to ${this.address}`);
          }
        }
        if (this.socket.destroyed === false) {
          if (!Array.isArray(buffer2)) {
            this.socket.write(buffer2, "binary");
            return true;
          }
          for (let i = 0; i < buffer2.length; i++) {
            this.socket.write(buffer2[i], "binary");
          }
          return true;
        }
        return false;
      }
      toString() {
        return "" + this.id;
      }
      toJSON() {
        return { id: this.id, host: this.host, port: this.port };
      }
      isConnected() {
        if (this.destroyed)
          return false;
        return !this.socket.destroyed && this.socket.writable;
      }
      command(ns, command, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        const conn = this;
        const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        const bson = conn.options.bson;
        const query = new Query(bson, ns, command, {
          numberToSkip: 0,
          numberToReturn: 1
        });
        const noop4 = () => {
        };
        function _callback(err, result) {
          callback(err, result);
          callback = noop4;
        }
        function errorHandler2(err) {
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          if (err == null) {
            err = new MongoError(`runCommand failed for connection to '${conn.address}'`);
          }
          conn.on("error", noop4);
          _callback(err);
        }
        function messageHandler(msg) {
          if (msg.responseTo !== query.requestId) {
            return;
          }
          conn.resetSocketTimeout();
          CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.removeListener(eventName, errorHandler2));
          conn.removeListener("message", messageHandler);
          msg.parse({ promoteValues: true });
          const response = msg.documents[0];
          if (response.ok === 0 || response.$err || response.errmsg || response.code) {
            _callback(new MongoError(response));
            return;
          }
          _callback(void 0, new CommandResult(response, this, msg));
        }
        conn.setSocketTimeout(socketTimeout);
        CONNECTION_ERROR_EVENTS.forEach((eventName) => conn.once(eventName, errorHandler2));
        conn.on("message", messageHandler);
        conn.write(query.toBin());
      }
    };
    var CONNECTION_ERROR_EVENTS = ["error", "close", "timeout", "parseError"];
    function deleteConnection(id) {
      delete connections[id];
      if (connectionAccountingSpy) {
        connectionAccountingSpy.deleteConnection(id);
      }
    }
    function addConnection(id, connection2) {
      connections[id] = connection2;
      if (connectionAccountingSpy) {
        connectionAccountingSpy.addConnection(id, connection2);
      }
    }
    function errorHandler(conn) {
      return function(err) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);
        }
        conn.emit("error", new MongoNetworkError(err), conn);
      };
    }
    function timeoutHandler(conn) {
      return function() {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);
        }
        conn.timedOut = true;
        conn.emit("timeout", new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {
          beforeHandshake: conn.ismaster == null
        }), conn);
      };
    }
    function closeHandler(conn) {
      return function(hadError) {
        if (connectionAccounting)
          deleteConnection(conn.id);
        if (conn.logger.isDebug()) {
          conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);
        }
        if (!hadError) {
          conn.emit("close", new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);
        }
      };
    }
    function processMessage(conn, message) {
      const msgHeader = parseHeader(message);
      if (msgHeader.opCode !== OP_COMPRESSED) {
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);
        return;
      }
      msgHeader.fromCompressed = true;
      let index2 = MESSAGE_HEADER_SIZE;
      msgHeader.opCode = message.readInt32LE(index2);
      index2 += 4;
      msgHeader.length = message.readInt32LE(index2);
      index2 += 4;
      const compressorID = message[index2];
      index2++;
      decompress(compressorID, message.slice(index2), (err, decompressedMsgBody) => {
        if (err) {
          conn.emit("error", err);
          return;
        }
        if (decompressedMsgBody.length !== msgHeader.length) {
          conn.emit("error", new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response3;
        conn.emit("message", new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);
      });
    }
    function dataHandler(conn) {
      return function(data) {
        while (data.length > 0) {
          if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {
            const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;
            if (remainingBytesToRead > data.length) {
              data.copy(conn.buffer, conn.bytesRead);
              conn.bytesRead = conn.bytesRead + data.length;
              data = Buffer2.alloc(0);
            } else {
              data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);
              data = data.slice(remainingBytesToRead);
              const emitBuffer = conn.buffer;
              conn.buffer = null;
              conn.sizeOfMessage = 0;
              conn.bytesRead = 0;
              conn.stubBuffer = null;
              processMessage(conn, emitBuffer);
            }
          } else {
            if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {
              if (conn.stubBuffer.length + data.length > 4) {
                const newData = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newData, 0);
                data.copy(newData, conn.stubBuffer.length);
                data = newData;
                conn.buffer = null;
                conn.sizeOfMessage = 0;
                conn.bytesRead = 0;
                conn.stubBuffer = null;
              } else {
                const newStubBuffer = Buffer2.alloc(conn.stubBuffer.length + data.length);
                conn.stubBuffer.copy(newStubBuffer, 0);
                data.copy(newStubBuffer, conn.stubBuffer.length);
                data = Buffer2.alloc(0);
              }
            } else {
              if (data.length > 4) {
                const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
                if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: "",
                    bin: conn.buffer,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: conn.bytesRead,
                      stubBuffer: conn.stubBuffer
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  return;
                }
                if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {
                  conn.buffer = Buffer2.alloc(sizeOfMessage);
                  data.copy(conn.buffer, 0);
                  conn.bytesRead = data.length;
                  conn.sizeOfMessage = sizeOfMessage;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {
                  const emitBuffer = data;
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                  processMessage(conn, emitBuffer);
                } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {
                  const errorObject = {
                    err: "socketHandler",
                    trace: null,
                    bin: data,
                    parseState: {
                      sizeOfMessage,
                      bytesRead: 0,
                      buffer: null,
                      stubBuffer: null
                    }
                  };
                  conn.emit("parseError", errorObject, conn);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = Buffer2.alloc(0);
                } else {
                  const emitBuffer = data.slice(0, sizeOfMessage);
                  conn.buffer = null;
                  conn.sizeOfMessage = 0;
                  conn.bytesRead = 0;
                  conn.stubBuffer = null;
                  data = data.slice(sizeOfMessage);
                  processMessage(conn, emitBuffer);
                }
              } else {
                conn.stubBuffer = Buffer2.alloc(data.length);
                data.copy(conn.stubBuffer, 0);
                data = Buffer2.alloc(0);
              }
            }
          }
        }
      };
    }
    module2.exports = Connection;
  }
});

// node_modules/mongodb/lib/core/connection/apm.js
var require_apm = __commonJS({
  "node_modules/mongodb/lib/core/connection/apm.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Msg = require_msg().Msg;
    var KillCursor = require_commands().KillCursor;
    var GetMore = require_commands().GetMore;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var SENSITIVE_COMMANDS = new Set([
      "authenticate",
      "saslStart",
      "saslContinue",
      "getnonce",
      "createUser",
      "updateUser",
      "copydbgetnonce",
      "copydbsaslstart",
      "copydb"
    ]);
    var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
    var namespace = (command) => command.ns;
    var databaseName = (command) => command.ns.split(".")[0];
    var collectionName = (command) => command.ns.split(".")[1];
    var generateConnectionId = (pool) => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;
    var maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;
    var isLegacyPool = (pool) => pool.s && pool.queue;
    var LEGACY_FIND_QUERY_MAP = {
      $query: "filter",
      $orderby: "sort",
      $hint: "hint",
      $comment: "comment",
      $maxScan: "maxScan",
      $max: "max",
      $min: "min",
      $returnKey: "returnKey",
      $showDiskLoc: "showRecordId",
      $maxTimeMS: "maxTimeMS",
      $snapshot: "snapshot"
    };
    var LEGACY_FIND_OPTIONS_MAP = {
      numberToSkip: "skip",
      numberToReturn: "batchSize",
      returnFieldsSelector: "projection"
    };
    var OP_QUERY_KEYS = [
      "tailable",
      "oplogReplay",
      "noCursorTimeout",
      "awaitData",
      "partial",
      "exhaust"
    ];
    var extractCommand = (command) => {
      if (command instanceof GetMore) {
        return {
          getMore: command.cursorId,
          collection: collectionName(command),
          batchSize: command.numberToReturn
        };
      }
      if (command instanceof KillCursor) {
        return {
          killCursors: collectionName(command),
          cursors: command.cursorIds
        };
      }
      if (command instanceof Msg) {
        return command.command;
      }
      if (command.query && command.query.$query) {
        let result;
        if (command.ns === "admin.$cmd") {
          result = Object.assign({}, command.query.$query);
        } else {
          result = { find: collectionName(command) };
          Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
            if (typeof command.query[key] !== "undefined")
              result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];
          });
        }
        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
          if (typeof command[key] !== "undefined")
            result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];
        });
        OP_QUERY_KEYS.forEach((key) => {
          if (command[key])
            result[key] = command[key];
        });
        if (typeof command.pre32Limit !== "undefined") {
          result.limit = command.pre32Limit;
        }
        if (command.query.$explain) {
          return { explain: result };
        }
        return result;
      }
      return command.query ? command.query : command;
    };
    var extractReply = (command, reply) => {
      if (command instanceof GetMore) {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            nextBatch: reply.message.documents
          }
        };
      }
      if (command instanceof KillCursor) {
        return {
          ok: 1,
          cursorsUnknown: command.cursorIds
        };
      }
      if (command.query && typeof command.query.$query !== "undefined") {
        return {
          ok: 1,
          cursor: {
            id: reply.message.cursorId,
            ns: namespace(command),
            firstBatch: reply.message.documents
          }
        };
      }
      return reply && reply.result ? reply.result : reply;
    };
    var extractConnectionDetails = (pool) => {
      if (isLegacyPool(pool)) {
        return {
          connectionId: generateConnectionId(pool)
        };
      }
      const connection2 = pool;
      return {
        address: connection2.address,
        connectionId: connection2.id
      };
    };
    var CommandStartedEvent = class {
      constructor(pool, command) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        if (SENSITIVE_COMMANDS.has(commandName)) {
          this.commandObj = {};
          this.commandObj[commandName] = true;
        }
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          databaseName: databaseName(command),
          commandName,
          command: cmd
        });
      }
    };
    var CommandSucceededEvent = class {
      constructor(pool, command, reply, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          reply: maybeRedact(commandName, extractReply(command, reply))
        });
      }
    };
    var CommandFailedEvent = class {
      constructor(pool, command, error3, started) {
        const cmd = extractCommand(command);
        const commandName = extractCommandName(cmd);
        const connectionDetails = extractConnectionDetails(pool);
        Object.assign(this, connectionDetails, {
          requestId: command.requestId,
          commandName,
          duration: calculateDurationInMs(started),
          failure: maybeRedact(commandName, error3)
        });
      }
    };
    module2.exports = {
      CommandStartedEvent,
      CommandSucceededEvent,
      CommandFailedEvent
    };
  }
});

// node_modules/mongodb/lib/core/auth/auth_provider.js
var require_auth_provider = __commonJS({
  "node_modules/mongodb/lib/core/auth/auth_provider.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthContext = class {
      constructor(connection2, credentials, options2) {
        this.connection = connection2;
        this.credentials = credentials;
        this.options = options2;
      }
    };
    var AuthProvider = class {
      constructor(bson) {
        this.bson = bson;
      }
      prepare(handshakeDoc, context, callback) {
        callback(void 0, handshakeDoc);
      }
      auth(context, callback) {
        callback(new TypeError("`auth` method must be overridden by subclass"));
      }
    };
    module2.exports = { AuthContext, AuthProvider };
  }
});

// node_modules/mongodb/lib/core/auth/mongocr.js
var require_mongocr = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongocr.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = __require("crypto");
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCR = class extends AuthProvider {
      auth(authContext, callback) {
        const connection2 = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const source = credentials.source;
        connection2.command(`${source}.$cmd`, { getnonce: 1 }, (err, result) => {
          let nonce = null;
          let key = null;
          if (err == null) {
            const r = result.result;
            nonce = r.nonce;
            let md5 = crypto.createHash("md5");
            md5.update(username + ":mongo:" + password, "utf8");
            const hash_password = md5.digest("hex");
            md5 = crypto.createHash("md5");
            md5.update(nonce + username + hash_password, "utf8");
            key = md5.digest("hex");
          }
          const authenticateCommand = {
            authenticate: 1,
            user: username,
            nonce,
            key
          };
          connection2.command(`${source}.$cmd`, authenticateCommand, callback);
        });
      }
    };
    module2.exports = MongoCR;
  }
});

// node_modules/mongodb/lib/core/auth/x509.js
var require_x509 = __commonJS({
  "node_modules/mongodb/lib/core/auth/x509.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var X509 = class extends AuthProvider {
      prepare(handshakeDoc, authContext, callback) {
        const credentials = authContext.credentials;
        Object.assign(handshakeDoc, {
          speculativeAuthenticate: x509AuthenticateCommand(credentials)
        });
        callback(void 0, handshakeDoc);
      }
      auth(authContext, callback) {
        const connection2 = authContext.connection;
        const credentials = authContext.credentials;
        const response = authContext.response;
        if (response.speculativeAuthenticate) {
          return callback();
        }
        connection2.command("$external.$cmd", x509AuthenticateCommand(credentials), callback);
      }
    };
    function x509AuthenticateCommand(credentials) {
      const command = { authenticate: 1, mechanism: "MONGODB-X509" };
      if (credentials.username) {
        Object.assign(command, { user: credentials.username });
      }
      return command;
    }
    module2.exports = X509;
  }
});

// node_modules/mongodb/lib/core/auth/plain.js
var require_plain = __commonJS({
  "node_modules/mongodb/lib/core/auth/plain.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var AuthProvider = require_auth_provider().AuthProvider;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var Plain = class extends AuthProvider {
      auth(authContext, callback) {
        const connection2 = authContext.connection;
        const credentials = authContext.credentials;
        const username = credentials.username;
        const password = credentials.password;
        const payload = new Binary2(`\0${username}\0${password}`);
        const command = {
          saslStart: 1,
          mechanism: "PLAIN",
          payload,
          autoAuthorize: 1
        };
        connection2.command("$external.$cmd", command, callback);
      }
    };
    module2.exports = Plain;
  }
});

// node_modules/mongodb/lib/core/auth/gssapi.js
var require_gssapi = __commonJS({
  "node_modules/mongodb/lib/core/auth/gssapi.js"(exports2, module2) {
    init_shims();
    "use strict";
    var dns = __require("dns");
    var AuthProvider = require_auth_provider().AuthProvider;
    var retrieveKerberos = require_utils2().retrieveKerberos;
    var MongoError = require_error().MongoError;
    var kerberos;
    var GSSAPI = class extends AuthProvider {
      auth(authContext, callback) {
        const connection2 = authContext.connection;
        const credentials = authContext.credentials;
        if (credentials == null)
          return callback(new MongoError("credentials required"));
        const username = credentials.username;
        function externalCommand(command, cb) {
          return connection2.command("$external.$cmd", command, cb);
        }
        makeKerberosClient(authContext, (err, client2) => {
          if (err)
            return callback(err);
          if (client2 == null)
            return callback(new MongoError("gssapi client missing"));
          client2.step("", (err2, payload) => {
            if (err2)
              return callback(err2);
            externalCommand(saslStart(payload), (err3, response) => {
              if (err3)
                return callback(err3);
              const result = response.result;
              negotiate(client2, 10, result.payload, (err4, payload2) => {
                if (err4)
                  return callback(err4);
                externalCommand(saslContinue(payload2, result.conversationId), (err5, response2) => {
                  if (err5)
                    return callback(err5);
                  const result2 = response2.result;
                  finalize(client2, username, result2.payload, (err6, payload3) => {
                    if (err6)
                      return callback(err6);
                    externalCommand({
                      saslContinue: 1,
                      conversationId: result2.conversationId,
                      payload: payload3
                    }, (err7, result3) => {
                      if (err7)
                        return callback(err7);
                      callback(void 0, result3);
                    });
                  });
                });
              });
            });
          });
        });
      }
    };
    module2.exports = GSSAPI;
    function makeKerberosClient(authContext, callback) {
      const host2 = authContext.options.host;
      const port2 = authContext.options.port;
      const credentials = authContext.credentials;
      if (!host2 || !port2 || !credentials) {
        return callback(new MongoError(`Connection must specify: ${host2 ? "host" : ""}, ${port2 ? "port" : ""}, ${credentials ? "host" : "credentials"}.`));
      }
      if (kerberos == null) {
        try {
          kerberos = retrieveKerberos();
        } catch (e) {
          return callback(e);
        }
      }
      const username = credentials.username;
      const password = credentials.password;
      const mechanismProperties = credentials.mechanismProperties;
      const serviceName = mechanismProperties["gssapiservicename"] || mechanismProperties["gssapiServiceName"] || "mongodb";
      performGssapiCanonicalizeHostName(host2, mechanismProperties, (err, host3) => {
        if (err)
          return callback(err);
        const initOptions = {};
        if (password != null) {
          Object.assign(initOptions, { user: username, password });
        }
        kerberos.initializeClient(`${serviceName}${process.platform === "win32" ? "/" : "@"}${host3}`, initOptions, (err2, client2) => {
          if (err2)
            return callback(new MongoError(err2));
          callback(null, client2);
        });
      });
    }
    function saslStart(payload) {
      return {
        saslStart: 1,
        mechanism: "GSSAPI",
        payload,
        autoAuthorize: 1
      };
    }
    function saslContinue(payload, conversationId) {
      return {
        saslContinue: 1,
        conversationId,
        payload
      };
    }
    function negotiate(client2, retries, payload, callback) {
      client2.step(payload, (err, response) => {
        if (err && retries === 0)
          return callback(err);
        if (err)
          return negotiate(client2, retries - 1, payload, callback);
        callback(void 0, response || "");
      });
    }
    function finalize(client2, user, payload, callback) {
      client2.unwrap(payload, (err, response) => {
        if (err)
          return callback(err);
        client2.wrap(response || "", { user }, (err2, wrapped) => {
          if (err2)
            return callback(err2);
          callback(void 0, wrapped);
        });
      });
    }
    function performGssapiCanonicalizeHostName(host2, mechanismProperties, callback) {
      const canonicalizeHostName = typeof mechanismProperties.gssapiCanonicalizeHostName === "boolean" ? mechanismProperties.gssapiCanonicalizeHostName : false;
      if (!canonicalizeHostName)
        return callback(void 0, host2);
      dns.resolveCname(host2, (err, r) => {
        if (err)
          return callback(err);
        if (Array.isArray(r) && r.length > 0) {
          return callback(void 0, r[0]);
        }
        callback(void 0, host2);
      });
    }
  }
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS({
  "node_modules/memory-pager/index.js"(exports2, module2) {
    init_shims();
    module2.exports = Pager;
    function Pager(pageSize, opts) {
      if (!(this instanceof Pager))
        return new Pager(pageSize, opts);
      this.length = 0;
      this.updates = [];
      this.path = new Uint16Array(4);
      this.pages = new Array(32768);
      this.maxPages = this.pages.length;
      this.level = 0;
      this.pageSize = pageSize || 1024;
      this.deduplicate = opts ? opts.deduplicate : null;
      this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
    }
    Pager.prototype.updated = function(page2) {
      while (this.deduplicate && page2.buffer[page2.deduplicate] === this.deduplicate[page2.deduplicate]) {
        page2.deduplicate++;
        if (page2.deduplicate === this.deduplicate.length) {
          page2.deduplicate = 0;
          if (page2.buffer.equals && page2.buffer.equals(this.deduplicate))
            page2.buffer = this.deduplicate;
          break;
        }
      }
      if (page2.updated || !this.updates)
        return;
      page2.updated = true;
      this.updates.push(page2);
    };
    Pager.prototype.lastUpdate = function() {
      if (!this.updates || !this.updates.length)
        return null;
      var page2 = this.updates.pop();
      page2.updated = false;
      return page2;
    };
    Pager.prototype._array = function(i, noAllocate) {
      if (i >= this.maxPages) {
        if (noAllocate)
          return;
        grow(this, i);
      }
      factor(i, this.path);
      var arr = this.pages;
      for (var j = this.level; j > 0; j--) {
        var p = this.path[j];
        var next = arr[p];
        if (!next) {
          if (noAllocate)
            return;
          next = arr[p] = new Array(32768);
        }
        arr = next;
      }
      return arr;
    };
    Pager.prototype.get = function(i, noAllocate) {
      var arr = this._array(i, noAllocate);
      var first = this.path[0];
      var page2 = arr && arr[first];
      if (!page2 && !noAllocate) {
        page2 = arr[first] = new Page(i, alloc(this.pageSize));
        if (i >= this.length)
          this.length = i + 1;
      }
      if (page2 && page2.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
        page2.buffer = copy(page2.buffer);
        page2.deduplicate = 0;
      }
      return page2;
    };
    Pager.prototype.set = function(i, buf) {
      var arr = this._array(i, false);
      var first = this.path[0];
      if (i >= this.length)
        this.length = i + 1;
      if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
        arr[first] = void 0;
        return;
      }
      if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
        buf = this.deduplicate;
      }
      var page2 = arr[first];
      var b = truncate(buf, this.pageSize);
      if (page2)
        page2.buffer = b;
      else
        arr[first] = new Page(i, b);
    };
    Pager.prototype.toBuffer = function() {
      var list2 = new Array(this.length);
      var empty2 = alloc(this.pageSize);
      var ptr = 0;
      while (ptr < list2.length) {
        var arr = this._array(ptr, true);
        for (var i = 0; i < 32768 && ptr < list2.length; i++) {
          list2[ptr++] = arr && arr[i] ? arr[i].buffer : empty2;
        }
      }
      return Buffer.concat(list2);
    };
    function grow(pager, index2) {
      while (pager.maxPages < index2) {
        var old = pager.pages;
        pager.pages = new Array(32768);
        pager.pages[0] = old;
        pager.level++;
        pager.maxPages *= 32768;
      }
    }
    function truncate(buf, len) {
      if (buf.length === len)
        return buf;
      if (buf.length > len)
        return buf.slice(0, len);
      var cpy = alloc(len);
      buf.copy(cpy);
      return cpy;
    }
    function alloc(size) {
      if (Buffer.alloc)
        return Buffer.alloc(size);
      var buf = new Buffer(size);
      buf.fill(0);
      return buf;
    }
    function copy(buf) {
      var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
      buf.copy(cpy);
      return cpy;
    }
    function Page(i, buf) {
      this.offset = i * buf.length;
      this.buffer = buf;
      this.updated = false;
      this.deduplicate = 0;
    }
    function factor(n, out) {
      n = (n - (out[0] = n & 32767)) / 32768;
      n = (n - (out[1] = n & 32767)) / 32768;
      out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
    }
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS({
  "node_modules/sparse-bitfield/index.js"(exports2, module2) {
    init_shims();
    var pager = require_memory_pager();
    module2.exports = Bitfield;
    function Bitfield(opts) {
      if (!(this instanceof Bitfield))
        return new Bitfield(opts);
      if (!opts)
        opts = {};
      if (Buffer.isBuffer(opts))
        opts = { buffer: opts };
      this.pageOffset = opts.pageOffset || 0;
      this.pageSize = opts.pageSize || 1024;
      this.pages = opts.pages || pager(this.pageSize);
      this.byteLength = this.pages.length * this.pageSize;
      this.length = 8 * this.byteLength;
      if (!powerOfTwo(this.pageSize))
        throw new Error("The page size should be a power of two");
      this._trackUpdates = !!opts.trackUpdates;
      this._pageMask = this.pageSize - 1;
      if (opts.buffer) {
        for (var i = 0; i < opts.buffer.length; i += this.pageSize) {
          this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
        }
        this.byteLength = opts.buffer.length;
        this.length = 8 * this.byteLength;
      }
    }
    Bitfield.prototype.get = function(i) {
      var o = i & 7;
      var j = (i - o) / 8;
      return !!(this.getByte(j) & 128 >> o);
    };
    Bitfield.prototype.getByte = function(i) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page2 = this.pages.get(j, true);
      return page2 ? page2.buffer[o + this.pageOffset] : 0;
    };
    Bitfield.prototype.set = function(i, v) {
      var o = i & 7;
      var j = (i - o) / 8;
      var b = this.getByte(j);
      return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
    };
    Bitfield.prototype.toBuffer = function() {
      var all = alloc(this.pages.length * this.pageSize);
      for (var i = 0; i < this.pages.length; i++) {
        var next = this.pages.get(i, true);
        var allOffset = i * this.pageSize;
        if (next)
          next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
      }
      return all;
    };
    Bitfield.prototype.setByte = function(i, b) {
      var o = i & this._pageMask;
      var j = (i - o) / this.pageSize;
      var page2 = this.pages.get(j, false);
      o += this.pageOffset;
      if (page2.buffer[o] === b)
        return false;
      page2.buffer[o] = b;
      if (i >= this.byteLength) {
        this.byteLength = i + 1;
        this.length = this.byteLength * 8;
      }
      if (this._trackUpdates)
        this.pages.updated(page2);
      return true;
    };
    function alloc(n) {
      if (Buffer.alloc)
        return Buffer.alloc(n);
      var b = new Buffer(n);
      b.fill(0);
      return b;
    }
    function powerOfTwo(x) {
      return !(x & x - 1);
    }
  }
});

// node_modules/saslprep/lib/memory-code-points.js
var require_memory_code_points = __commonJS({
  "node_modules/saslprep/lib/memory-code-points.js"(exports2, module2) {
    init_shims();
    "use strict";
    var fs2 = __require("fs");
    var path = __require("path");
    var bitfield = require_sparse_bitfield();
    var memory = fs2.readFileSync(path.resolve(__dirname, "../code-points.mem"));
    var offset = 0;
    function read2() {
      const size = memory.readUInt32BE(offset);
      offset += 4;
      const codepoints = memory.slice(offset, offset + size);
      offset += size;
      return bitfield({ buffer: codepoints });
    }
    var unassigned_code_points = read2();
    var commonly_mapped_to_nothing = read2();
    var non_ASCII_space_characters = read2();
    var prohibited_characters = read2();
    var bidirectional_r_al = read2();
    var bidirectional_l = read2();
    module2.exports = {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/saslprep/index.js
var require_saslprep = __commonJS({
  "node_modules/saslprep/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    } = require_memory_code_points();
    module2.exports = saslprep;
    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    var getCodePoint = (character) => character.codePointAt(0);
    var first = (x) => x[0];
    var last = (x) => x[x.length - 1];
    function toCodePoints(input) {
      const codepoints = [];
      const size = input.length;
      for (let i = 0; i < size; i += 1) {
        const before = input.charCodeAt(i);
        if (before >= 55296 && before <= 56319 && size > i + 1) {
          const next = input.charCodeAt(i + 1);
          if (next >= 56320 && next <= 57343) {
            codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
            i += 1;
            continue;
          }
        }
        codepoints.push(before);
      }
      return codepoints;
    }
    function saslprep(input, opts = {}) {
      if (typeof input !== "string") {
        throw new TypeError("Expected string.");
      }
      if (input.length === 0) {
        return "";
      }
      const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
      const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
      const normalized_map = toCodePoints(normalized_input);
      const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
      if (hasProhibited) {
        throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
      }
      if (opts.allowUnassigned !== true) {
        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
        if (hasUnassigned) {
          throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
        }
      }
      const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
      const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
      if (hasBidiRAL && hasBidiL) {
        throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
      const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
      if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
      }
      return normalized_input;
    }
  }
});

// node_modules/mongodb/lib/core/auth/scram.js
var require_scram = __commonJS({
  "node_modules/mongodb/lib/core/auth/scram.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = __require("crypto");
    var Buffer2 = require_safe_buffer().Buffer;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var AuthProvider = require_auth_provider().AuthProvider;
    var emitWarningOnce = require_utils4().emitWarning;
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var saslprep;
    try {
      saslprep = require_saslprep();
    } catch (e) {
    }
    var ScramSHA = class extends AuthProvider {
      constructor(bson, cryptoMethod) {
        super(bson);
        this.cryptoMethod = cryptoMethod || "sha1";
      }
      prepare(handshakeDoc, authContext, callback) {
        const cryptoMethod = this.cryptoMethod;
        if (cryptoMethod === "sha256" && saslprep == null) {
          emitWarningOnce("Warning: no saslprep library specified. Passwords will not be sanitized");
        }
        crypto.randomBytes(24, (err, nonce) => {
          if (err) {
            return callback(err);
          }
          Object.assign(authContext, { nonce });
          const credentials = authContext.credentials;
          const request = Object.assign({}, handshakeDoc, {
            speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {
              db: credentials.source
            })
          });
          callback(void 0, request);
        });
      }
      auth(authContext, callback) {
        const response = authContext.response;
        if (response && response.speculativeAuthenticate) {
          continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);
          return;
        }
        executeScram(this.cryptoMethod, authContext, callback);
      }
    };
    function cleanUsername(username) {
      return username.replace("=", "=3D").replace(",", "=2C");
    }
    function clientFirstMessageBare(username, nonce) {
      return Buffer2.concat([
        Buffer2.from("n=", "utf8"),
        Buffer2.from(username, "utf8"),
        Buffer2.from(",r=", "utf8"),
        Buffer2.from(nonce.toString("base64"), "utf8")
      ]);
    }
    function makeFirstMessage(cryptoMethod, credentials, nonce) {
      const username = cleanUsername(credentials.username);
      const mechanism = cryptoMethod === "sha1" ? "SCRAM-SHA-1" : "SCRAM-SHA-256";
      return {
        saslStart: 1,
        mechanism,
        payload: new Binary2(Buffer2.concat([Buffer2.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
        autoAuthorize: 1,
        options: { skipEmptyExchange: true }
      };
    }
    function executeScram(cryptoMethod, authContext, callback) {
      const connection2 = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
      connection2.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        continueScramConversation(cryptoMethod, result.result, authContext, callback);
      });
    }
    function continueScramConversation(cryptoMethod, response, authContext, callback) {
      const connection2 = authContext.connection;
      const credentials = authContext.credentials;
      const nonce = authContext.nonce;
      const db = credentials.source;
      const username = cleanUsername(credentials.username);
      const password = credentials.password;
      let processedPassword;
      if (cryptoMethod === "sha256") {
        processedPassword = saslprep ? saslprep(password) : password;
      } else {
        try {
          processedPassword = passwordDigest(username, password);
        } catch (e) {
          return callback(e);
        }
      }
      const payload = Buffer2.isBuffer(response.payload) ? new Binary2(response.payload) : response.payload;
      const dict = parsePayload(payload.value());
      const iterations = parseInt(dict.i, 10);
      if (iterations && iterations < 4096) {
        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);
        return;
      }
      const salt = dict.s;
      const rnonce = dict.r;
      if (rnonce.startsWith("nonce")) {
        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);
        return;
      }
      const withoutProof = `c=biws,r=${rnonce}`;
      const saltedPassword = HI(processedPassword, Buffer2.from(salt, "base64"), iterations, cryptoMethod);
      const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
      const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
      const storedKey = H(cryptoMethod, clientKey);
      const authMessage = [
        clientFirstMessageBare(username, nonce),
        payload.value().toString("base64"),
        withoutProof
      ].join(",");
      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
      const clientProof = `p=${xor(clientKey, clientSignature)}`;
      const clientFinal = [withoutProof, clientProof].join(",");
      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
      const saslContinueCmd = {
        saslContinue: 1,
        conversationId: response.conversationId,
        payload: new Binary2(Buffer2.from(clientFinal))
      };
      connection2.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {
        const err = resolveError(_err, result);
        if (err) {
          return callback(err);
        }
        const r = result.result;
        const parsedResponse = parsePayload(r.payload.value());
        if (!compareDigest(Buffer2.from(parsedResponse.v, "base64"), serverSignature)) {
          callback(new MongoError("Server returned an invalid signature"));
          return;
        }
        if (!r || r.done !== false) {
          return callback(err, r);
        }
        const retrySaslContinueCmd = {
          saslContinue: 1,
          conversationId: r.conversationId,
          payload: Buffer2.alloc(0)
        };
        connection2.command(`${db}.$cmd`, retrySaslContinueCmd, callback);
      });
    }
    function parsePayload(payload) {
      const dict = {};
      const parts = payload.split(",");
      for (let i = 0; i < parts.length; i++) {
        const valueParts = parts[i].split("=");
        dict[valueParts[0]] = valueParts[1];
      }
      return dict;
    }
    function passwordDigest(username, password) {
      if (typeof username !== "string") {
        throw new MongoError("username must be a string");
      }
      if (typeof password !== "string") {
        throw new MongoError("password must be a string");
      }
      if (password.length === 0) {
        throw new MongoError("password cannot be empty");
      }
      const md5 = crypto.createHash("md5");
      md5.update(`${username}:mongo:${password}`, "utf8");
      return md5.digest("hex");
    }
    function xor(a, b) {
      if (!Buffer2.isBuffer(a)) {
        a = Buffer2.from(a);
      }
      if (!Buffer2.isBuffer(b)) {
        b = Buffer2.from(b);
      }
      const length = Math.max(a.length, b.length);
      const res = [];
      for (let i = 0; i < length; i += 1) {
        res.push(a[i] ^ b[i]);
      }
      return Buffer2.from(res).toString("base64");
    }
    function H(method, text) {
      return crypto.createHash(method).update(text).digest();
    }
    function HMAC(method, key, text) {
      return crypto.createHmac(method, key).update(text).digest();
    }
    var _hiCache = {};
    var _hiCacheCount = 0;
    function _hiCachePurge() {
      _hiCache = {};
      _hiCacheCount = 0;
    }
    var hiLengthMap = {
      sha256: 32,
      sha1: 20
    };
    function HI(data, salt, iterations, cryptoMethod) {
      const key = [data, salt.toString("base64"), iterations].join("_");
      if (_hiCache[key] !== void 0) {
        return _hiCache[key];
      }
      const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
      if (_hiCacheCount >= 200) {
        _hiCachePurge();
      }
      _hiCache[key] = saltedData;
      _hiCacheCount += 1;
      return saltedData;
    }
    function compareDigest(lhs, rhs) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      if (typeof crypto.timingSafeEqual === "function") {
        return crypto.timingSafeEqual(lhs, rhs);
      }
      let result = 0;
      for (let i = 0; i < lhs.length; i++) {
        result |= lhs[i] ^ rhs[i];
      }
      return result === 0;
    }
    function resolveError(err, result) {
      if (err)
        return err;
      const r = result.result;
      if (r.$err || r.errmsg)
        return new MongoError(r);
    }
    var ScramSHA1 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha1");
      }
    };
    var ScramSHA256 = class extends ScramSHA {
      constructor(bson) {
        super(bson, "sha256");
      }
    };
    module2.exports = { ScramSHA1, ScramSHA256 };
  }
});

// node_modules/mongodb/lib/core/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongo_credentials.js"(exports2, module2) {
    init_shims();
    "use strict";
    function getDefaultAuthMechanism(ismaster) {
      if (ismaster) {
        if (Array.isArray(ismaster.saslSupportedMechs)) {
          return ismaster.saslSupportedMechs.indexOf("SCRAM-SHA-256") >= 0 ? "scram-sha-256" : "scram-sha-1";
        }
        if (ismaster.maxWireVersion >= 3) {
          return "scram-sha-1";
        }
      }
      return "mongocr";
    }
    var MongoCredentials = class {
      constructor(options2) {
        options2 = options2 || {};
        this.username = options2.username;
        this.password = options2.password;
        this.source = options2.source || options2.db;
        this.mechanism = options2.mechanism || "default";
        this.mechanismProperties = options2.mechanismProperties || {};
        if (/MONGODB-AWS/i.test(this.mechanism)) {
          if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
            this.username = process.env.AWS_ACCESS_KEY_ID;
          }
          if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
            this.password = process.env.AWS_SECRET_ACCESS_KEY;
          }
          if (!this.mechanismProperties.AWS_SESSION_TOKEN && process.env.AWS_SESSION_TOKEN) {
            this.mechanismProperties.AWS_SESSION_TOKEN = process.env.AWS_SESSION_TOKEN;
          }
        }
        Object.freeze(this.mechanismProperties);
        Object.freeze(this);
      }
      equals(other) {
        return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
      }
      resolveAuthMechanism(ismaster) {
        if (/DEFAULT/i.test(this.mechanism)) {
          return new MongoCredentials({
            username: this.username,
            password: this.password,
            source: this.source,
            mechanism: getDefaultAuthMechanism(ismaster),
            mechanismProperties: this.mechanismProperties
          });
        }
        return this;
      }
    };
    module2.exports = { MongoCredentials };
  }
});

// node_modules/mongodb/lib/core/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS({
  "node_modules/mongodb/lib/core/auth/mongodb_aws.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AuthProvider = require_auth_provider().AuthProvider;
    var MongoCredentials = require_mongo_credentials().MongoCredentials;
    var MongoError = require_error().MongoError;
    var crypto = __require("crypto");
    var http3 = __require("http");
    var maxWireVersion = require_utils2().maxWireVersion;
    var url = __require("url");
    var aws4;
    try {
      aws4 = __require("aws4");
    } catch (e) {
    }
    var ASCII_N = 110;
    var AWS_RELATIVE_URI = "http://169.254.170.2";
    var AWS_EC2_URI = "http://169.254.169.254";
    var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
    var MongoDBAWS = class extends AuthProvider {
      auth(authContext, callback) {
        const connection2 = authContext.connection;
        const credentials = authContext.credentials;
        if (maxWireVersion(connection2) < 9) {
          callback(new MongoError("MONGODB-AWS authentication requires MongoDB version 4.4 or later"));
          return;
        }
        if (aws4 == null) {
          callback(new MongoError("MONGODB-AWS authentication requires the `aws4` module, please install it as a dependency of your project"));
          return;
        }
        if (credentials.username == null) {
          makeTempCredentials(credentials, (err, tempCredentials) => {
            if (err)
              return callback(err);
            authContext.credentials = tempCredentials;
            this.auth(authContext, callback);
          });
          return;
        }
        const username = credentials.username;
        const password = credentials.password;
        const db = credentials.source;
        const token = credentials.mechanismProperties.AWS_SESSION_TOKEN;
        const bson = this.bson;
        crypto.randomBytes(32, (err, nonce) => {
          if (err) {
            callback(err);
            return;
          }
          const saslStart = {
            saslStart: 1,
            mechanism: "MONGODB-AWS",
            payload: bson.serialize({ r: nonce, p: ASCII_N })
          };
          connection2.command(`${db}.$cmd`, saslStart, (err2, result) => {
            if (err2)
              return callback(err2);
            const res = result.result;
            const serverResponse = bson.deserialize(res.payload.buffer);
            const host2 = serverResponse.h;
            const serverNonce = serverResponse.s.buffer;
            if (serverNonce.length !== 64) {
              callback(new MongoError(`Invalid server nonce length ${serverNonce.length}, expected 64`));
              return;
            }
            if (serverNonce.compare(nonce, 0, nonce.length, 0, nonce.length) !== 0) {
              callback(new MongoError("Server nonce does not begin with client nonce"));
              return;
            }
            if (host2.length < 1 || host2.length > 255 || host2.indexOf("..") !== -1) {
              callback(new MongoError(`Server returned an invalid host: "${host2}"`));
              return;
            }
            const body = "Action=GetCallerIdentity&Version=2011-06-15";
            const options2 = aws4.sign({
              method: "POST",
              host: host2,
              region: deriveRegion(serverResponse.h),
              service: "sts",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": body.length,
                "X-MongoDB-Server-Nonce": serverNonce.toString("base64"),
                "X-MongoDB-GS2-CB-Flag": "n"
              },
              path: "/",
              body
            }, {
              accessKeyId: username,
              secretAccessKey: password,
              token
            });
            const authorization = options2.headers.Authorization;
            const date = options2.headers["X-Amz-Date"];
            const payload = { a: authorization, d: date };
            if (token) {
              payload.t = token;
            }
            const saslContinue = {
              saslContinue: 1,
              conversationId: 1,
              payload: bson.serialize(payload)
            };
            connection2.command(`${db}.$cmd`, saslContinue, (err3) => {
              if (err3)
                return callback(err3);
              callback();
            });
          });
        });
      }
    };
    function makeTempCredentials(credentials, callback) {
      function done(creds) {
        if (creds.AccessKeyId == null || creds.SecretAccessKey == null || creds.Token == null) {
          callback(new MongoError("Could not obtain temporary MONGODB-AWS credentials"));
          return;
        }
        callback(void 0, new MongoCredentials({
          username: creds.AccessKeyId,
          password: creds.SecretAccessKey,
          source: credentials.source,
          mechanism: "MONGODB-AWS",
          mechanismProperties: {
            AWS_SESSION_TOKEN: creds.Token
          }
        }));
      }
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, (err, res) => {
          if (err)
            return callback(err);
          done(res);
        });
        return;
      }
      request(`${AWS_EC2_URI}/latest/api/token`, { method: "PUT", json: false, headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 } }, (err, token) => {
        if (err)
          return callback(err);
        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, { json: false, headers: { "X-aws-ec2-metadata-token": token } }, (err2, roleName) => {
          if (err2)
            return callback(err2);
          request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, { headers: { "X-aws-ec2-metadata-token": token } }, (err3, creds) => {
            if (err3)
              return callback(err3);
            done(creds);
          });
        });
      });
    }
    function deriveRegion(host2) {
      const parts = host2.split(".");
      if (parts.length === 1 || parts[1] === "amazonaws") {
        return "us-east-1";
      }
      return parts[1];
    }
    function request(uri2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = Object.assign({
        method: "GET",
        timeout: 1e4,
        json: true
      }, url.parse(uri2), options2);
      const req = http3.request(options2, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d3) => data += d3);
        res.on("end", () => {
          if (options2.json === false) {
            callback(void 0, data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            callback(void 0, parsed);
          } catch (err) {
            callback(new MongoError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.on("error", (err) => callback(err));
      req.end();
    }
    module2.exports = MongoDBAWS;
  }
});

// node_modules/mongodb/lib/core/auth/defaultAuthProviders.js
var require_defaultAuthProviders = __commonJS({
  "node_modules/mongodb/lib/core/auth/defaultAuthProviders.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoCR = require_mongocr();
    var X509 = require_x509();
    var Plain = require_plain();
    var GSSAPI = require_gssapi();
    var ScramSHA1 = require_scram().ScramSHA1;
    var ScramSHA256 = require_scram().ScramSHA256;
    var MongoDBAWS = require_mongodb_aws();
    function defaultAuthProviders(bson) {
      return {
        "mongodb-aws": new MongoDBAWS(bson),
        mongocr: new MongoCR(bson),
        x509: new X509(bson),
        plain: new Plain(bson),
        gssapi: new GSSAPI(bson),
        "scram-sha-1": new ScramSHA1(bson),
        "scram-sha-256": new ScramSHA256(bson)
      };
    }
    module2.exports = { defaultAuthProviders };
  }
});

// node_modules/mongodb/lib/core/connection/connect.js
var require_connect = __commonJS({
  "node_modules/mongodb/lib/core/connection/connect.js"(exports2, module2) {
    init_shims();
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var Connection = require_connection();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var defaultAuthProviders = require_defaultAuthProviders().defaultAuthProviders;
    var AuthContext = require_auth_provider().AuthContext;
    var WIRE_CONSTANTS = require_constants();
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
    var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
    var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
    var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
    var AUTH_PROVIDERS;
    function connect2(options2, cancellationToken, callback) {
      if (typeof cancellationToken === "function") {
        callback = cancellationToken;
        cancellationToken = void 0;
      }
      const ConnectionType = options2 && options2.connectionType ? options2.connectionType : Connection;
      if (AUTH_PROVIDERS == null) {
        AUTH_PROVIDERS = defaultAuthProviders(options2.bson);
      }
      const family = options2.family !== void 0 ? options2.family : 0;
      makeConnection(family, options2, cancellationToken, (err, socket) => {
        if (err) {
          callback(err, socket);
          return;
        }
        performInitialHandshake(new ConnectionType(socket, options2), options2, callback);
      });
    }
    function isModernConnectionType(conn) {
      return !(conn instanceof Connection);
    }
    function checkSupportedServer(ismaster, options2) {
      const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === "number" && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;
      const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === "number" && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;
      if (serverVersionHighEnough) {
        if (serverVersionLowEnough) {
          return null;
        }
        const message2 = `Server at ${options2.host}:${options2.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        return new MongoError(message2);
      }
      const message = `Server at ${options2.host}:${options2.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;
      return new MongoError(message);
    }
    function performInitialHandshake(conn, options2, _callback) {
      const callback = function(err, ret) {
        if (err && conn) {
          conn.destroy();
        }
        _callback(err, ret);
      };
      const credentials = options2.credentials;
      if (credentials) {
        if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {
          callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));
          return;
        }
      }
      const authContext = new AuthContext(conn, credentials, options2);
      prepareHandshakeDocument(authContext, (err, handshakeDoc) => {
        if (err) {
          return callback(err);
        }
        const handshakeOptions = Object.assign({}, options2);
        if (options2.connectTimeoutMS || options2.connectionTimeout) {
          handshakeOptions.socketTimeout = options2.connectTimeoutMS || options2.connectionTimeout;
        }
        const start = new Date().getTime();
        conn.command("admin.$cmd", handshakeDoc, handshakeOptions, (err2, result) => {
          if (err2) {
            callback(err2);
            return;
          }
          const response = result.result;
          if (response.ok === 0) {
            callback(new MongoError(response));
            return;
          }
          const supportedServerErr = checkSupportedServer(response, options2);
          if (supportedServerErr) {
            callback(supportedServerErr);
            return;
          }
          if (!isModernConnectionType(conn)) {
            if (response.compression) {
              const agreedCompressors = handshakeDoc.compression.filter((compressor) => response.compression.indexOf(compressor) !== -1);
              if (agreedCompressors.length) {
                conn.agreedCompressor = agreedCompressors[0];
              }
              if (options2.compression && options2.compression.zlibCompressionLevel) {
                conn.zlibCompressionLevel = options2.compression.zlibCompressionLevel;
              }
            }
          }
          conn.ismaster = response;
          conn.lastIsMasterMS = new Date().getTime() - start;
          if (!response.arbiterOnly && credentials) {
            Object.assign(authContext, { response });
            const resolvedCredentials = credentials.resolveAuthMechanism(response);
            const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];
            authProvider.auth(authContext, (err3) => {
              if (err3)
                return callback(err3);
              callback(void 0, conn);
            });
            return;
          }
          callback(void 0, conn);
        });
      });
    }
    function prepareHandshakeDocument(authContext, callback) {
      const options2 = authContext.options;
      const compressors = options2.compression && options2.compression.compressors ? options2.compression.compressors : [];
      const handshakeDoc = {
        ismaster: true,
        client: options2.metadata || makeClientMetadata(options2),
        compression: compressors
      };
      const credentials = authContext.credentials;
      if (credentials) {
        if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {
          Object.assign(handshakeDoc, {
            saslSupportedMechs: `${credentials.source}.${credentials.username}`
          });
          AUTH_PROVIDERS["scram-sha-256"].prepare(handshakeDoc, authContext, callback);
          return;
        }
        const authProvider = AUTH_PROVIDERS[credentials.mechanism];
        authProvider.prepare(handshakeDoc, authContext, callback);
        return;
      }
      callback(void 0, handshakeDoc);
    }
    var LEGAL_SSL_SOCKET_OPTIONS = [
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "NPNProtocols",
      "ALPNProtocols",
      "servername",
      "ecdhCurve",
      "secureProtocol",
      "secureContext",
      "session",
      "minDHSize",
      "crl",
      "rejectUnauthorized"
    ];
    function parseConnectOptions(family, options2) {
      const host2 = typeof options2.host === "string" ? options2.host : "localhost";
      if (host2.indexOf("/") !== -1) {
        return { path: host2 };
      }
      const result = {
        family,
        host: host2,
        port: typeof options2.port === "number" ? options2.port : 27017,
        rejectUnauthorized: false
      };
      return result;
    }
    function parseSslOptions(family, options2) {
      const result = parseConnectOptions(family, options2);
      for (const name2 in options2) {
        if (options2[name2] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name2) !== -1) {
          result[name2] = options2[name2];
        }
      }
      if (options2.checkServerIdentity === false) {
        result.checkServerIdentity = function() {
          return void 0;
        };
      } else if (typeof options2.checkServerIdentity === "function") {
        result.checkServerIdentity = options2.checkServerIdentity;
      }
      if (result.servername == null && !net.isIP(result.host)) {
        result.servername = result.host;
      }
      return result;
    }
    var SOCKET_ERROR_EVENTS = new Set(["error", "close", "timeout", "parseError"]);
    function makeConnection(family, options2, cancellationToken, _callback) {
      const useSsl = typeof options2.ssl === "boolean" ? options2.ssl : false;
      const keepAlive = typeof options2.keepAlive === "boolean" ? options2.keepAlive : true;
      let keepAliveInitialDelay = typeof options2.keepAliveInitialDelay === "number" ? options2.keepAliveInitialDelay : 12e4;
      const noDelay = typeof options2.noDelay === "boolean" ? options2.noDelay : true;
      const connectionTimeout = typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 3e4;
      const socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
      const rejectUnauthorized = typeof options2.rejectUnauthorized === "boolean" ? options2.rejectUnauthorized : true;
      if (keepAliveInitialDelay > socketTimeout) {
        keepAliveInitialDelay = Math.round(socketTimeout / 2);
      }
      let socket;
      const callback = function(err, ret) {
        if (err && socket) {
          socket.destroy();
        }
        _callback(err, ret);
      };
      try {
        if (useSsl) {
          socket = tls.connect(parseSslOptions(family, options2));
          if (typeof socket.disableRenegotiation === "function") {
            socket.disableRenegotiation();
          }
        } else {
          socket = net.createConnection(parseConnectOptions(family, options2));
        }
      } catch (err) {
        return callback(err);
      }
      socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
      socket.setTimeout(connectionTimeout);
      socket.setNoDelay(noDelay);
      const connectEvent = useSsl ? "secureConnect" : "connect";
      let cancellationHandler;
      function errorHandler(eventName) {
        return (err) => {
          SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
          if (cancellationHandler) {
            cancellationToken.removeListener("cancel", cancellationHandler);
          }
          socket.removeListener(connectEvent, connectHandler);
          callback(connectionFailureError(eventName, err));
        };
      }
      function connectHandler() {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler) {
          cancellationToken.removeListener("cancel", cancellationHandler);
        }
        if (socket.authorizationError && rejectUnauthorized) {
          return callback(socket.authorizationError);
        }
        socket.setTimeout(socketTimeout);
        callback(null, socket);
      }
      SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
      if (cancellationToken) {
        cancellationHandler = errorHandler("cancel");
        cancellationToken.once("cancel", cancellationHandler);
      }
      socket.once(connectEvent, connectHandler);
    }
    function connectionFailureError(type, err) {
      switch (type) {
        case "error":
          return new MongoNetworkError(err);
        case "timeout":
          return new MongoNetworkTimeoutError(`connection timed out`);
        case "close":
          return new MongoNetworkError(`connection closed`);
        case "cancel":
          return new MongoNetworkError(`connection establishment was cancelled`);
        default:
          return new MongoNetworkError(`unknown network error`);
      }
    }
    module2.exports = connect2;
  }
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS({
  "node_modules/mongodb/lib/read_concern.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadConcern = class {
      constructor(level) {
        if (level != null) {
          this.level = level;
        }
      }
      static fromOptions(options2) {
        if (options2 == null) {
          return;
        }
        if (options2.readConcern) {
          if (options2.readConcern instanceof ReadConcern) {
            return options2.readConcern;
          }
          return new ReadConcern(options2.readConcern.level);
        }
        if (options2.level) {
          return new ReadConcern(options2.level);
        }
      }
      static get MAJORITY() {
        return "majority";
      }
      static get AVAILABLE() {
        return "available";
      }
      static get LINEARIZABLE() {
        return "linearizable";
      }
      static get SNAPSHOT() {
        return "snapshot";
      }
    };
    module2.exports = ReadConcern;
  }
});

// node_modules/mongodb/lib/core/transactions.js
var require_transactions = __commonJS({
  "node_modules/mongodb/lib/core/transactions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var ReadPreference = require_read_preference();
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var TxnState;
    var stateMachine;
    (() => {
      const NO_TRANSACTION = "NO_TRANSACTION";
      const STARTING_TRANSACTION = "STARTING_TRANSACTION";
      const TRANSACTION_IN_PROGRESS = "TRANSACTION_IN_PROGRESS";
      const TRANSACTION_COMMITTED = "TRANSACTION_COMMITTED";
      const TRANSACTION_COMMITTED_EMPTY = "TRANSACTION_COMMITTED_EMPTY";
      const TRANSACTION_ABORTED = "TRANSACTION_ABORTED";
      TxnState = {
        NO_TRANSACTION,
        STARTING_TRANSACTION,
        TRANSACTION_IN_PROGRESS,
        TRANSACTION_COMMITTED,
        TRANSACTION_COMMITTED_EMPTY,
        TRANSACTION_ABORTED
      };
      stateMachine = {
        [NO_TRANSACTION]: [NO_TRANSACTION, STARTING_TRANSACTION],
        [STARTING_TRANSACTION]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_IN_PROGRESS]: [
          TRANSACTION_IN_PROGRESS,
          TRANSACTION_COMMITTED,
          TRANSACTION_ABORTED
        ],
        [TRANSACTION_COMMITTED]: [
          TRANSACTION_COMMITTED,
          TRANSACTION_COMMITTED_EMPTY,
          STARTING_TRANSACTION,
          NO_TRANSACTION
        ],
        [TRANSACTION_ABORTED]: [STARTING_TRANSACTION, NO_TRANSACTION],
        [TRANSACTION_COMMITTED_EMPTY]: [TRANSACTION_COMMITTED_EMPTY, NO_TRANSACTION]
      };
    })();
    var Transaction = class {
      constructor(options2) {
        options2 = options2 || {};
        this.state = TxnState.NO_TRANSACTION;
        this.options = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern) {
          if (writeConcern.w <= 0) {
            throw new MongoError("Transactions do not support unacknowledged write concern");
          }
          this.options.writeConcern = writeConcern;
        }
        if (options2.readConcern) {
          this.options.readConcern = ReadConcern.fromOptions(options2);
        }
        if (options2.readPreference) {
          this.options.readPreference = ReadPreference.fromOptions(options2);
        }
        if (options2.maxCommitTimeMS) {
          this.options.maxTimeMS = options2.maxCommitTimeMS;
        }
        this._pinnedServer = void 0;
        this._recoveryToken = void 0;
      }
      get server() {
        return this._pinnedServer;
      }
      get recoveryToken() {
        return this._recoveryToken;
      }
      get isPinned() {
        return !!this.server;
      }
      get isActive() {
        return [TxnState.STARTING_TRANSACTION, TxnState.TRANSACTION_IN_PROGRESS].indexOf(this.state) !== -1;
      }
      transition(nextState) {
        const nextStates = stateMachine[this.state];
        if (nextStates && nextStates.indexOf(nextState) !== -1) {
          this.state = nextState;
          if (this.state === TxnState.NO_TRANSACTION || this.state === TxnState.STARTING_TRANSACTION) {
            this.unpinServer();
          }
          return;
        }
        throw new MongoError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
      }
      pinServer(server) {
        if (this.isActive) {
          this._pinnedServer = server;
        }
      }
      unpinServer() {
        this._pinnedServer = void 0;
      }
    };
    function isTransactionCommand(command) {
      return !!(command.commitTransaction || command.abortTransaction);
    }
    module2.exports = { TxnState, Transaction, isTransactionCommand };
  }
});

// node_modules/mongodb/lib/core/topologies/shared.js
var require_shared2 = __commonJS({
  "node_modules/mongodb/lib/core/topologies/shared.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_read_preference();
    var TopologyType = require_common().TopologyType;
    var MongoError = require_error().MongoError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MMAPv1_RETRY_WRITES_ERROR_CODE = 20;
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    function createCompressionInfo(options2) {
      if (!options2.compression || !options2.compression.compressors) {
        return [];
      }
      options2.compression.compressors.forEach(function(compressor) {
        if (compressor !== "snappy" && compressor !== "zlib") {
          throw new Error("compressors must be at least one of snappy or zlib");
        }
      });
      return options2.compression.compressors;
    }
    function clone2(object) {
      return JSON.parse(JSON.stringify(object));
    }
    var getPreviousDescription = function(self2) {
      if (!self2.s.serverDescription) {
        self2.s.serverDescription = {
          address: self2.name,
          arbiters: [],
          hosts: [],
          passives: [],
          type: "Unknown"
        };
      }
      return self2.s.serverDescription;
    };
    var emitServerDescriptionChanged = function(self2, description) {
      if (self2.listeners("serverDescriptionChanged").length > 0) {
        self2.emit("serverDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var getPreviousTopologyDescription = function(self2) {
      if (!self2.s.topologyDescription) {
        self2.s.topologyDescription = {
          topologyType: "Unknown",
          servers: [
            {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            }
          ]
        };
      }
      return self2.s.topologyDescription;
    };
    var emitTopologyDescriptionChanged = function(self2, description) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        self2.emit("topologyDescriptionChanged", {
          topologyId: self2.s.topologyId !== -1 ? self2.s.topologyId : self2.id,
          address: self2.name,
          previousDescription: getPreviousTopologyDescription(self2),
          newDescription: description
        });
        self2.s.serverDescription = description;
      }
    };
    var changedIsMaster = function(self2, currentIsmaster, ismaster) {
      var currentType = getTopologyType(self2, currentIsmaster);
      var newType = getTopologyType(self2, ismaster);
      if (newType !== currentType)
        return true;
      return false;
    };
    var getTopologyType = function(self2, ismaster) {
      if (!ismaster) {
        ismaster = self2.ismaster;
      }
      if (!ismaster)
        return "Unknown";
      if (ismaster.ismaster && ismaster.msg === "isdbgrid")
        return "Mongos";
      if (ismaster.ismaster && !ismaster.hosts)
        return "Standalone";
      if (ismaster.ismaster)
        return "RSPrimary";
      if (ismaster.secondary)
        return "RSSecondary";
      if (ismaster.arbiterOnly)
        return "RSArbiter";
      return "Unknown";
    };
    var inquireServerState = function(self2) {
      return function(callback) {
        if (self2.s.state === "destroyed")
          return;
        var start = new Date().getTime();
        emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: self2.name });
        self2.command("admin.$cmd", { ismaster: true }, { monitoring: true }, function(err, r) {
          if (!err) {
            self2.emit("ismaster", r, self2);
            var latencyMS = new Date().getTime() - start;
            emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
              durationMS: latencyMS,
              reply: r.result,
              connectionId: self2.name
            });
            if (changedIsMaster(self2, self2.s.ismaster, r.result)) {
              emitServerDescriptionChanged(self2, {
                address: self2.name,
                arbiters: [],
                hosts: [],
                passives: [],
                type: !self2.s.inTopology ? "Standalone" : getTopologyType(self2)
              });
            }
            self2.s.ismaster = r.result;
            self2.s.isMasterLatencyMS = latencyMS;
          } else {
            emitSDAMEvent(self2, "serverHeartbeatFailed", {
              durationMS: latencyMS,
              failure: err,
              connectionId: self2.name
            });
          }
          if (typeof callback === "function") {
            return callback(err, r);
          }
          self2.s.inquireServerStateTimeout = setTimeout(inquireServerState(self2), self2.s.haInterval);
        });
      };
    };
    var cloneOptions = function(options2) {
      var opts = {};
      for (var name2 in options2) {
        opts[name2] = options2[name2];
      }
      return opts;
    };
    function Interval(fn, time) {
      var timer = false;
      this.start = function() {
        if (!this.isRunning()) {
          timer = setInterval(fn, time);
        }
        return this;
      };
      this.stop = function() {
        clearInterval(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function Timeout(fn, time) {
      var timer = false;
      var func = () => {
        if (timer) {
          clearTimeout(timer);
          timer = false;
          fn();
        }
      };
      this.start = function() {
        if (!this.isRunning()) {
          timer = setTimeout(func, time);
        }
        return this;
      };
      this.stop = function() {
        clearTimeout(timer);
        timer = false;
        return this;
      };
      this.isRunning = function() {
        return timer !== false;
      };
    }
    function diff(previous, current) {
      var diff2 = {
        servers: []
      };
      if (!previous) {
        previous = { servers: [] };
      }
      for (var i = 0; i < previous.servers.length; i++) {
        var found = false;
        for (var j = 0; j < current.servers.length; j++) {
          if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: previous.servers[i].address,
            from: previous.servers[i].type,
            to: "Unknown"
          });
        }
      }
      for (j = 0; j < current.servers.length; j++) {
        found = false;
        for (i = 0; i < previous.servers.length; i++) {
          if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {
            found = true;
            break;
          }
        }
        if (!found) {
          diff2.servers.push({
            address: current.servers[j].address,
            from: "Unknown",
            to: current.servers[j].type
          });
        }
      }
      for (i = 0; i < previous.servers.length; i++) {
        var prevServer = previous.servers[i];
        for (j = 0; j < current.servers.length; j++) {
          var currServer = current.servers[j];
          if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
            if (prevServer.type !== currServer.type) {
              diff2.servers.push({
                address: prevServer.address,
                from: prevServer.type,
                to: currServer.type
              });
            }
          }
        }
      }
      return diff2;
    }
    function resolveClusterTime(topology, $clusterTime) {
      if (topology.clusterTime == null) {
        topology.clusterTime = $clusterTime;
      } else {
        if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {
          topology.clusterTime = $clusterTime;
        }
      }
    }
    var SessionMixins = {
      endSessions: function(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
    };
    function topologyType(topology) {
      if (topology.description) {
        return topology.description.type;
      }
      if (topology.type === "mongos") {
        return TopologyType.Sharded;
      } else if (topology.type === "replset") {
        return TopologyType.ReplicaSetWithPrimary;
      }
      return TopologyType.Single;
    }
    var RETRYABLE_WIRE_VERSION = 6;
    var isRetryableWritesSupported = function(topology) {
      const maxWireVersion2 = topology.lastIsMaster().maxWireVersion;
      if (maxWireVersion2 < RETRYABLE_WIRE_VERSION) {
        return false;
      }
      if (!topology.logicalSessionTimeoutMinutes) {
        return false;
      }
      if (topologyType(topology) === TopologyType.Single) {
        return false;
      }
      return true;
    };
    var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
    function getMMAPError(err) {
      if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes("Transaction numbers")) {
        return err;
      }
      const newErr = new MongoError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError: err
      });
      return newErr;
    }
    function legacyIsRetryableWriteError(err, topology) {
      if (!(err instanceof MongoError)) {
        return false;
      }
      if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {
        err.addErrorLabel("RetryableWriteError");
      }
      return err.hasErrorLabel("RetryableWriteError");
    }
    module2.exports = {
      SessionMixins,
      resolveClusterTime,
      inquireServerState,
      getTopologyType,
      emitServerDescriptionChanged,
      emitTopologyDescriptionChanged,
      cloneOptions,
      createCompressionInfo,
      clone: clone2,
      diff,
      Interval,
      Timeout,
      isRetryableWritesSupported,
      getMMAPError,
      topologyType,
      legacyIsRetryableWriteError
    };
  }
});

// node_modules/mongodb/lib/core/sessions.js
var require_sessions = __commonJS({
  "node_modules/mongodb/lib/core/sessions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var retrieveBSON = require_utils3().retrieveBSON;
    var EventEmitter = __require("events");
    var BSON2 = retrieveBSON();
    var Binary2 = BSON2.Binary;
    var uuidV4 = require_utils2().uuidV4;
    var MongoError = require_error().MongoError;
    var isRetryableError = require_error().isRetryableError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Transaction = require_transactions().Transaction;
    var TxnState = require_transactions().TxnState;
    var isPromiseLike = require_utils2().isPromiseLike;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var minWireVersionForShardedTransactions = 8;
    function assertAlive(session, callback) {
      if (session.serverSession == null) {
        const error3 = new MongoError("Cannot use a session that has ended");
        if (typeof callback === "function") {
          callback(error3, null);
          return false;
        }
        throw error3;
      }
      return true;
    }
    var kServerSession = Symbol("serverSession");
    var ClientSession = class extends EventEmitter {
      constructor(topology, sessionPool, options2, clientOptions) {
        super();
        if (topology == null) {
          throw new Error("ClientSession requires a topology");
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
          throw new Error("ClientSession requires a ServerSessionPool");
        }
        options2 = options2 || {};
        clientOptions = clientOptions || {};
        this.topology = topology;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this[kServerSession] = void 0;
        this.supports = {
          causalConsistency: typeof options2.causalConsistency !== "undefined" ? options2.causalConsistency : true
        };
        this.clusterTime = options2.initialClusterTime;
        this.operationTime = null;
        this.explicit = !!options2.explicit;
        this.owner = options2.owner;
        this.defaultTransactionOptions = Object.assign({}, options2.defaultTransactionOptions);
        this.transaction = new Transaction();
      }
      get id() {
        return this.serverSession.id;
      }
      get serverSession() {
        if (this[kServerSession] == null) {
          this[kServerSession] = this.sessionPool.acquire();
        }
        return this[kServerSession];
      }
      endSession(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        const session = this;
        return maybePromise(this, callback, (done) => {
          if (session.hasEnded) {
            return done();
          }
          function completeEndSession() {
            session.sessionPool.release(session.serverSession);
            session[kServerSession] = void 0;
            session.hasEnded = true;
            session.emit("ended", session);
            done();
          }
          if (session.serverSession && session.inTransaction()) {
            session.abortTransaction((err) => {
              if (err)
                return done(err);
              completeEndSession();
            });
            return;
          }
          completeEndSession();
        });
      }
      advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
          this.operationTime = operationTime;
          return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
          this.operationTime = operationTime;
        }
      }
      equals(session) {
        if (!(session instanceof ClientSession)) {
          return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
      }
      incrementTransactionNumber() {
        this.serverSession.txnNumber++;
      }
      inTransaction() {
        return this.transaction.isActive;
      }
      startTransaction(options2) {
        assertAlive(this);
        if (this.inTransaction()) {
          throw new MongoError("Transaction already in progress");
        }
        const topologyMaxWireVersion = maxWireVersion(this.topology);
        if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
          throw new MongoError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
        }
        this.incrementTransactionNumber();
        this.transaction = new Transaction(Object.assign({}, this.clientOptions, options2 || this.defaultTransactionOptions));
        this.transaction.transition(TxnState.STARTING_TRANSACTION);
      }
      commitTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "commitTransaction", done));
      }
      abortTransaction(callback) {
        return maybePromise(this, callback, (done) => endTransaction(this, "abortTransaction", done));
      }
      toBSON() {
        throw new Error("ClientSession cannot be serialized to BSON.");
      }
      withTransaction(fn, options2) {
        const startTime = now();
        return attemptTransaction(this, startTime, fn, options2);
      }
    };
    var MAX_WITH_TRANSACTION_TIMEOUT = 12e4;
    var UNSATISFIABLE_WRITE_CONCERN_CODE = 100;
    var UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;
    var MAX_TIME_MS_EXPIRED_CODE = 50;
    var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
      "CannotSatisfyWriteConcern",
      "UnknownReplWriteConcern",
      "UnsatisfiableWriteConcern"
    ]);
    function hasNotTimedOut(startTime, max) {
      return calculateDurationInMs(startTime) < max;
    }
    function isUnknownTransactionCommitResult(err) {
      return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;
    }
    function isMaxTimeMSExpiredError(err) {
      if (err == null)
        return false;
      return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;
    }
    function attemptTransactionCommit(session, startTime, fn, options2) {
      return session.commitTransaction().catch((err) => {
        if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
          if (err.hasErrorLabel("UnknownTransactionCommitResult")) {
            return attemptTransactionCommit(session, startTime, fn, options2);
          }
          if (err.hasErrorLabel("TransientTransactionError")) {
            return attemptTransaction(session, startTime, fn, options2);
          }
        }
        throw err;
      });
    }
    var USER_EXPLICIT_TXN_END_STATES = new Set([
      TxnState.NO_TRANSACTION,
      TxnState.TRANSACTION_COMMITTED,
      TxnState.TRANSACTION_ABORTED
    ]);
    function userExplicitlyEndedTransaction(session) {
      return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
    }
    function attemptTransaction(session, startTime, fn, options2) {
      session.startTransaction(options2);
      let promise;
      try {
        promise = fn(session);
      } catch (err) {
        promise = Promise.reject(err);
      }
      if (!isPromiseLike(promise)) {
        session.abortTransaction();
        throw new TypeError("Function provided to `withTransaction` must return a Promise");
      }
      return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
          return;
        }
        return attemptTransactionCommit(session, startTime, fn, options2);
      }).catch((err) => {
        function maybeRetryOrThrow(err2) {
          if (err2 instanceof MongoError && err2.hasErrorLabel("TransientTransactionError") && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
            return attemptTransaction(session, startTime, fn, options2);
          }
          if (isMaxTimeMSExpiredError(err2)) {
            err2.addErrorLabel("UnknownTransactionCommitResult");
          }
          throw err2;
        }
        if (session.transaction.isActive) {
          return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
      });
    }
    function endTransaction(session, commandName, callback) {
      if (!assertAlive(session, callback)) {
        return;
      }
      let txnState = session.transaction.state;
      if (txnState === TxnState.NO_TRANSACTION) {
        callback(new MongoError("No transaction started"));
        return;
      }
      if (commandName === "commitTransaction") {
        if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call commitTransaction after calling abortTransaction"));
          return;
        }
      } else {
        if (txnState === TxnState.STARTING_TRANSACTION) {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
          callback(null, null);
          return;
        }
        if (txnState === TxnState.TRANSACTION_ABORTED) {
          callback(new MongoError("Cannot call abortTransaction twice"));
          return;
        }
        if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {
          callback(new MongoError("Cannot call abortTransaction after calling commitTransaction"));
          return;
        }
      }
      const command = { [commandName]: 1 };
      let writeConcern;
      if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
      } else if (session.clientOptions && session.clientOptions.w) {
        writeConcern = { w: session.clientOptions.w };
      }
      if (txnState === TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 1e4 }, writeConcern, { w: "majority" });
      }
      if (writeConcern) {
        Object.assign(command, { writeConcern });
      }
      if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
      }
      function commandHandler(e, r) {
        if (commandName === "commitTransaction") {
          session.transaction.transition(TxnState.TRANSACTION_COMMITTED);
          if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {
            if (isUnknownTransactionCommitResult(e)) {
              e.addErrorLabel("UnknownTransactionCommitResult");
              session.transaction.unpinServer();
            }
          }
        } else {
          session.transaction.transition(TxnState.TRANSACTION_ABORTED);
        }
        callback(e, r);
      }
      function transactionError(err) {
        return commandName === "commitTransaction" ? err : null;
      }
      if (session.transaction.recoveryToken && supportsRecoveryToken(session)) {
        command.recoveryToken = session.transaction.recoveryToken;
      }
      session.topology.command("admin.$cmd", command, { session }, (err, reply) => {
        if (err && isRetryableError(err)) {
          if (command.commitTransaction) {
            session.transaction.unpinServer();
            command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
              w: "majority"
            });
          }
          return session.topology.command("admin.$cmd", command, { session }, (_err, _reply) => commandHandler(transactionError(_err), _reply));
        }
        commandHandler(transactionError(err), reply);
      });
    }
    function supportsRecoveryToken(session) {
      const topology = session.topology;
      return !!topology.s.options.useRecoveryToken;
    }
    var ServerSession = class {
      constructor() {
        this.id = { id: new Binary2(uuidV4(), Binary2.SUBTYPE_UUID) };
        this.lastUse = now();
        this.txnNumber = 0;
        this.isDirty = false;
      }
      hasTimedOut(sessionTimeoutMinutes) {
        const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 864e5 % 36e5 / 6e4);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
      }
    };
    var ServerSessionPool = class {
      constructor(topology) {
        if (topology == null) {
          throw new Error("ServerSessionPool requires a topology");
        }
        this.topology = topology;
        this.sessions = [];
      }
      endAllPooledSessions(callback) {
        if (this.sessions.length) {
          this.topology.endSessions(this.sessions.map((session) => session.id), () => {
            this.sessions = [];
            if (typeof callback === "function") {
              callback();
            }
          });
          return;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const session = this.sessions.shift();
          if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            return session;
          }
        }
        return new ServerSession();
      }
      release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        while (this.sessions.length) {
          const pooledSession = this.sessions[this.sessions.length - 1];
          if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
            this.sessions.pop();
          } else {
            break;
          }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
          if (session.isDirty) {
            return;
          }
          this.sessions.unshift(session);
        }
      }
    };
    function commandSupportsReadConcern(command, options2) {
      if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {
        return true;
      }
      if (command.mapReduce && options2 && options2.out && (options2.out.inline === 1 || options2.out === "inline")) {
        return true;
      }
      return false;
    }
    function applySession(session, command, options2) {
      if (session.hasEnded) {
        return new MongoError("Cannot use a session that has ended");
      }
      if (options2 && options2.writeConcern && options2.writeConcern.w === 0) {
        return;
      }
      const serverSession = session.serverSession;
      serverSession.lastUse = now();
      command.lsid = serverSession.id;
      const inTransaction = session.inTransaction() || isTransactionCommand(command);
      const isRetryableWrite = options2.willRetryWrite;
      const shouldApplyReadConcern = commandSupportsReadConcern(command, options2);
      if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {
        command.txnNumber = BSON2.Long.fromNumber(serverSession.txnNumber);
      }
      if (!inTransaction) {
        if (session.transaction.state !== TxnState.NO_TRANSACTION) {
          session.transaction.transition(TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        return;
      }
      if (options2.readPreference && !options2.readPreference.equals(ReadPreference.primary)) {
        return new MongoError(`Read preference in a transaction must be primary, not: ${options2.readPreference.mode}`);
      }
      command.autocommit = false;
      if (session.transaction.state === TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;
        if (readConcern) {
          command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
          command.readConcern = command.readConcern || {};
          Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
      }
    }
    function updateSessionFromResponse(session, document2) {
      if (document2.$clusterTime) {
        resolveClusterTime(session, document2.$clusterTime);
      }
      if (document2.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document2.operationTime);
      }
      if (document2.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document2.recoveryToken;
      }
    }
    module2.exports = {
      ClientSession,
      ServerSession,
      ServerSessionPool,
      TxnState,
      applySession,
      updateSessionFromResponse,
      commandSupportsReadConcern
    };
  }
});

// node_modules/mongodb/lib/core/connection/pool.js
var require_pool = __commonJS({
  "node_modules/mongodb/lib/core/connection/pool.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits = __require("util").inherits;
    var EventEmitter = __require("events").EventEmitter;
    var MongoError = require_error().MongoError;
    var MongoTimeoutError = require_error().MongoTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var Logger = require_logger();
    var f = __require("util").format;
    var Msg = require_msg().Msg;
    var CommandResult = require_command_result();
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var apm = require_apm();
    var Buffer2 = require_safe_buffer().Buffer;
    var connect2 = require_connect();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var eachAsync = require_utils2().eachAsync;
    var makeStateMachine = require_utils2().makeStateMachine;
    var now = require_utils4().now;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var DRAINING = "draining";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    var stateTransition = makeStateMachine({
      [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],
      [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],
      [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],
      [DRAINING]: [DRAINING, DESTROYING, DESTROYED],
      [DESTROYING]: [DESTROYING, DESTROYED],
      [DESTROYED]: [DESTROYED]
    });
    var CONNECTION_EVENTS = new Set([
      "error",
      "close",
      "timeout",
      "parseError",
      "connect",
      "message"
    ]);
    var _id = 0;
    var Pool = function(topology, options2) {
      EventEmitter.call(this);
      this.topology = topology;
      this.s = {
        state: DISCONNECTED,
        cancellationToken: new EventEmitter()
      };
      this.s.cancellationToken.setMaxListeners(Infinity);
      this.options = Object.assign({
        host: "localhost",
        port: 27017,
        size: 5,
        minSize: 0,
        connectionTimeout: 3e4,
        socketTimeout: 0,
        keepAlive: true,
        keepAliveInitialDelay: 12e4,
        noDelay: true,
        ssl: false,
        checkServerIdentity: true,
        ca: null,
        crl: null,
        cert: null,
        key: null,
        passphrase: null,
        rejectUnauthorized: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        reconnect: true,
        reconnectInterval: 1e3,
        reconnectTries: 30,
        domainsEnabled: false,
        legacyCompatMode: true
      }, options2);
      this.id = _id++;
      this.retriesLeft = this.options.reconnectTries;
      this.reconnectId = null;
      this.reconnectError = null;
      if (!options2.bson || options2.bson && (typeof options2.bson.serialize !== "function" || typeof options2.bson.deserialize !== "function")) {
        throw new Error("must pass in valid bson parser");
      }
      this.logger = Logger("Pool", options2);
      this.availableConnections = [];
      this.inUseConnections = [];
      this.connectingConnections = 0;
      this.executing = false;
      this.queue = [];
      this.numberOfConsecutiveTimeouts = 0;
      this.connectionIndex = 0;
      const pool = this;
      this._messageHandler = messageHandler(this);
      this._connectionCloseHandler = function(err) {
        const connection2 = this;
        connectionFailureHandler(pool, "close", err, connection2);
      };
      this._connectionErrorHandler = function(err) {
        const connection2 = this;
        connectionFailureHandler(pool, "error", err, connection2);
      };
      this._connectionTimeoutHandler = function(err) {
        const connection2 = this;
        connectionFailureHandler(pool, "timeout", err, connection2);
      };
      this._connectionParseErrorHandler = function(err) {
        const connection2 = this;
        connectionFailureHandler(pool, "parseError", err, connection2);
      };
    };
    inherits(Pool, EventEmitter);
    Object.defineProperty(Pool.prototype, "size", {
      enumerable: true,
      get: function() {
        return this.options.size;
      }
    });
    Object.defineProperty(Pool.prototype, "minSize", {
      enumerable: true,
      get: function() {
        return this.options.minSize;
      }
    });
    Object.defineProperty(Pool.prototype, "connectionTimeout", {
      enumerable: true,
      get: function() {
        return this.options.connectionTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "socketTimeout", {
      enumerable: true,
      get: function() {
        return this.options.socketTimeout;
      }
    });
    Object.defineProperty(Pool.prototype, "state", {
      enumerable: true,
      get: function() {
        return this.s.state;
      }
    });
    function resetPoolState(pool) {
      pool.inUseConnections = [];
      pool.availableConnections = [];
      pool.connectingConnections = 0;
      pool.executing = false;
      pool.numberOfConsecutiveTimeouts = 0;
      pool.connectionIndex = 0;
      pool.retriesLeft = pool.options.reconnectTries;
      pool.reconnectId = null;
    }
    function connectionFailureHandler(pool, event, err, conn) {
      if (conn) {
        if (conn._connectionFailHandled) {
          return;
        }
        conn._connectionFailHandled = true;
        conn.destroy();
        removeConnection(pool, conn);
        conn.flush(err);
      }
      if (event === "timeout") {
        pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;
        if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {
          pool.numberOfConsecutiveTimeouts = 0;
          pool.destroy(true);
          return pool.emit("close", pool);
        }
      }
      if (pool.socketCount() === 0) {
        if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {
          if (pool.options.reconnect) {
            stateTransition(pool, DISCONNECTED);
          }
        }
        event = event === "error" ? "close" : event;
        pool.emit(event, err);
      }
      if (!pool.reconnectId && pool.options.reconnect) {
        pool.reconnectError = err;
        pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);
      }
      const totalConnections = totalConnectionCount(pool);
      if (totalConnections < pool.minSize) {
        createConnection(pool);
      }
    }
    function attemptReconnect(pool, callback) {
      return function() {
        pool.emit("attemptReconnect", pool);
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Cannot create connection when pool is destroyed"));
          }
          return;
        }
        pool.retriesLeft = pool.retriesLeft - 1;
        if (pool.retriesLeft <= 0) {
          pool.destroy();
          const error3 = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);
          pool.emit("reconnectFailed", error3);
          if (typeof callback === "function") {
            callback(error3);
          }
          return;
        }
        pool.reconnectId = null;
        createConnection(pool, (err, conn) => {
          if (err == null) {
            pool.reconnectId = null;
            pool.retriesLeft = pool.options.reconnectTries;
            pool.emit("reconnect", pool);
          }
          if (typeof callback === "function") {
            callback(err, conn);
          }
        });
      };
    }
    function moveConnectionBetween(connection2, from, to) {
      var index2 = from.indexOf(connection2);
      if (index2 !== -1) {
        from.splice(index2, 1);
        to.push(connection2);
      }
    }
    function messageHandler(self2) {
      return function(message, connection2) {
        var workItem = null;
        for (var i = 0; i < connection2.workItems.length; i++) {
          if (connection2.workItems[i].requestId === message.responseTo) {
            workItem = connection2.workItems[i];
            connection2.workItems.splice(i, 1);
          }
        }
        if (workItem && workItem.monitoring) {
          moveConnectionBetween(connection2, self2.inUseConnections, self2.availableConnections);
        }
        self2.numberOfConsecutiveTimeouts = 0;
        if (workItem && workItem.socketTimeout) {
          connection2.resetSocketTimeout();
        }
        if (self2.logger.isDebug()) {
          self2.logger.debug(f("message [%s] received from %s:%s", message.raw.toString("hex"), self2.options.host, self2.options.port));
        }
        function handleOperationCallback(self3, cb, err, result) {
          if (!self3.options.domainsEnabled) {
            return process.nextTick(function() {
              return cb(err, result);
            });
          }
          cb(err, result);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
        if (workItem && !workItem.immediateRelease) {
          try {
            message.parse(workItem);
          } catch (err) {
            return handleOperationCallback(self2, workItem.cb, new MongoError(err));
          }
          if (message.documents[0]) {
            const document2 = message.documents[0];
            const session = workItem.session;
            if (session) {
              updateSessionFromResponse(session, document2);
            }
            if (self2.topology && document2.$clusterTime) {
              self2.topology.clusterTime = document2.$clusterTime;
            }
          }
          if (workItem.command && message.documents[0]) {
            const responseDoc = message.documents[0];
            if (responseDoc.writeConcernError) {
              const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);
              return handleOperationCallback(self2, workItem.cb, err);
            }
            if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {
              return handleOperationCallback(self2, workItem.cb, new MongoError(responseDoc));
            }
          }
          message.hashedName = connection2.hashedName;
          handleOperationCallback(self2, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection2, message));
        }
      };
    }
    Pool.prototype.socketCount = function() {
      return this.availableConnections.length + this.inUseConnections.length;
    };
    function totalConnectionCount(pool) {
      return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;
    }
    Pool.prototype.allConnections = function() {
      return this.availableConnections.concat(this.inUseConnections);
    };
    Pool.prototype.get = function() {
      return this.allConnections()[0];
    };
    Pool.prototype.isConnected = function() {
      if (this.state === DESTROYED || this.state === DESTROYING) {
        return false;
      }
      var connections = this.availableConnections.concat(this.inUseConnections);
      for (var i = 0; i < connections.length; i++) {
        if (connections[i].isConnected())
          return true;
      }
      return false;
    };
    Pool.prototype.isDestroyed = function() {
      return this.state === DESTROYED || this.state === DESTROYING;
    };
    Pool.prototype.isDisconnected = function() {
      return this.state === DISCONNECTED;
    };
    Pool.prototype.connect = function(callback) {
      if (this.state !== DISCONNECTED) {
        throw new MongoError("connection in unlawful state " + this.state);
      }
      stateTransition(this, CONNECTING);
      createConnection(this, (err, conn) => {
        if (err) {
          if (typeof callback === "function") {
            this.destroy();
            callback(err);
            return;
          }
          if (this.state === CONNECTING) {
            this.emit("error", err);
          }
          this.destroy();
          return;
        }
        stateTransition(this, CONNECTED);
        if (this.minSize) {
          for (let i = 0; i < this.minSize; i++) {
            createConnection(this);
          }
        }
        if (typeof callback === "function") {
          callback(null, conn);
        } else {
          this.emit("connect", this, conn);
        }
      });
    };
    Pool.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.logout = function(dbName, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Pool.prototype.unref = function() {
      var connections = this.availableConnections.concat(this.inUseConnections);
      connections.forEach(function(c) {
        c.unref();
      });
    };
    function destroy(self2, connections, options2, callback) {
      stateTransition(self2, DESTROYING);
      self2.s.cancellationToken.emit("cancel");
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.on("error", () => {
        });
        conn.destroy(options2, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function")
            callback(err, null);
          return;
        }
        resetPoolState(self2);
        self2.queue = [];
        stateTransition(self2, DESTROYED);
        if (typeof callback === "function")
          callback(null, null);
      });
    }
    Pool.prototype.destroy = function(force, callback) {
      var self2 = this;
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      if (this.state === DESTROYED || self2.state === DESTROYING) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DRAINING);
      if (force) {
        var connections = self2.availableConnections.concat(self2.inUseConnections);
        while (self2.queue.length > 0) {
          var workItem = self2.queue.shift();
          if (typeof workItem.cb === "function") {
            workItem.cb(new MongoError("Pool was force destroyed"));
          }
        }
        return destroy(self2, connections, { force: true }, callback);
      }
      if (this.reconnectId) {
        clearTimeout(this.reconnectId);
      }
      function checkStatus() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        flushMonitoringOperations(self2.queue);
        if (self2.queue.length === 0) {
          var connections2 = self2.availableConnections.concat(self2.inUseConnections);
          for (var i = 0; i < connections2.length; i++) {
            if (connections2[i].workItems.length > 0) {
              return setTimeout(checkStatus, 1);
            }
          }
          destroy(self2, connections2, { force: false }, callback);
        } else {
          _execute(self2)();
          setTimeout(checkStatus, 1);
        }
      }
      checkStatus();
    };
    Pool.prototype.reset = function(callback) {
      if (this.s.state !== CONNECTED) {
        if (typeof callback === "function") {
          callback(new MongoError("pool is not connected, reset aborted"));
        }
        return;
      }
      this.s.cancellationToken.emit("cancel");
      const connections = this.availableConnections.concat(this.inUseConnections);
      eachAsync(connections, (conn, cb) => {
        for (const eventName of CONNECTION_EVENTS) {
          conn.removeAllListeners(eventName);
        }
        conn.destroy({ force: true }, cb);
      }, (err) => {
        if (err) {
          if (typeof callback === "function") {
            callback(err, null);
            return;
          }
        }
        resetPoolState(this);
        createConnection(this, () => {
          if (typeof callback === "function") {
            callback(null, null);
          }
        });
      });
    };
    function serializeCommand(self2, command, callback) {
      const originalCommandBuffer = command.toBin();
      const shouldCompress2 = !!self2.options.agreedCompressor;
      if (!shouldCompress2 || !canCompress(command)) {
        return callback(null, originalCommandBuffer);
      }
      const concatenatedOriginalCommandBuffer = Buffer2.concat(originalCommandBuffer);
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      compress(self2, messageToBeCompressed, function(err, compressedMessage) {
        if (err)
          return callback(err, null);
        const msgHeader = Buffer2.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
        const compressionDetails = Buffer2.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compressorIDs[self2.options.agreedCompressor], 8);
        return callback(null, [msgHeader, compressionDetails, compressedMessage]);
      });
    }
    Pool.prototype.write = function(command, options2, cb) {
      var self2 = this;
      if (typeof options2 === "function") {
        cb = options2;
      }
      options2 = options2 || {};
      if (!(typeof cb === "function") && !options2.noResponse) {
        throw new MongoError("write method must provide a callback");
      }
      if (this.state === DESTROYED || this.state === DESTROYING) {
        cb(new MongoError("pool destroyed"));
        return;
      }
      if (this.state === DRAINING) {
        cb(new MongoError("pool is draining, new operations prohibited"));
        return;
      }
      if (this.options.domainsEnabled && process.domain && typeof cb === "function") {
        var oldCb = cb;
        cb = process.domain.bind(function() {
          var args = new Array(arguments.length);
          for (var i = 0; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          process.nextTick(function() {
            oldCb.apply(null, args);
          });
        });
      }
      var operation = {
        cb,
        raw: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        fullResult: false
      };
      operation.promoteLongs = typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true;
      operation.promoteValues = typeof options2.promoteValues === "boolean" ? options2.promoteValues : true;
      operation.promoteBuffers = typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false;
      operation.raw = typeof options2.raw === "boolean" ? options2.raw : false;
      operation.immediateRelease = typeof options2.immediateRelease === "boolean" ? options2.immediateRelease : false;
      operation.documentsReturnedIn = options2.documentsReturnedIn;
      operation.command = typeof options2.command === "boolean" ? options2.command : false;
      operation.fullResult = typeof options2.fullResult === "boolean" ? options2.fullResult : false;
      operation.noResponse = typeof options2.noResponse === "boolean" ? options2.noResponse : false;
      operation.session = options2.session || null;
      operation.socketTimeout = options2.socketTimeout;
      operation.monitoring = options2.monitoring;
      operation.requestId = command.requestId;
      if (self2.options.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operation.started = now();
        operation.cb = (err, reply) => {
          if (err) {
            self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operation.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              self2.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operation.started));
            } else {
              self2.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operation.started));
            }
          }
          if (typeof cb === "function")
            cb(err, reply);
        };
      }
      serializeCommand(self2, command, (err, serializedBuffers) => {
        if (err)
          throw err;
        operation.buffer = serializedBuffers;
        if (options2.monitoring) {
          self2.queue.unshift(operation);
        } else {
          self2.queue.push(operation);
        }
        if (!self2.executing) {
          process.nextTick(function() {
            _execute(self2)();
          });
        }
      });
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function remove(connection2, connections) {
      for (var i = 0; i < connections.length; i++) {
        if (connections[i] === connection2) {
          connections.splice(i, 1);
          return true;
        }
      }
    }
    function removeConnection(self2, connection2) {
      if (remove(connection2, self2.availableConnections))
        return;
      if (remove(connection2, self2.inUseConnections))
        return;
    }
    function createConnection(pool, callback) {
      if (pool.state === DESTROYED || pool.state === DESTROYING) {
        if (typeof callback === "function") {
          callback(new MongoError("Cannot create connection when pool is destroyed"));
        }
        return;
      }
      pool.connectingConnections++;
      connect2(pool.options, pool.s.cancellationToken, (err, connection2) => {
        pool.connectingConnections--;
        if (err) {
          if (pool.logger.isDebug()) {
            pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          }
          if (!pool.reconnectId && pool.options.reconnect) {
            if (pool.state === CONNECTING && pool.options.legacyCompatMode) {
              callback(err);
              return;
            }
            pool.reconnectError = err;
            pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);
            return;
          }
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.state === DESTROYED || pool.state === DESTROYING) {
          if (typeof callback === "function") {
            callback(new MongoError("Pool was destroyed after connection creation"));
          }
          connection2.destroy();
          return;
        }
        connection2.on("error", pool._connectionErrorHandler);
        connection2.on("close", pool._connectionCloseHandler);
        connection2.on("timeout", pool._connectionTimeoutHandler);
        connection2.on("parseError", pool._connectionParseErrorHandler);
        connection2.on("message", pool._messageHandler);
        pool.availableConnections.push(connection2);
        if (typeof callback === "function") {
          callback(null, connection2);
        }
        _execute(pool)();
      });
    }
    function flushMonitoringOperations(queue) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].monitoring) {
          var workItem = queue[i];
          queue.splice(i, 1);
          workItem.cb(new MongoError({ message: "no connection available for monitoring", driver: true }));
        }
      }
    }
    function _execute(self2) {
      return function() {
        if (self2.state === DESTROYED)
          return;
        if (self2.executing)
          return;
        self2.executing = true;
        if (self2.connectingConnections > 0) {
          self2.executing = false;
          return;
        }
        while (true) {
          const totalConnections = totalConnectionCount(self2);
          if (self2.availableConnections.length === 0) {
            flushMonitoringOperations(self2.queue);
            if (totalConnections < self2.options.size && self2.queue.length > 0) {
              createConnection(self2);
            }
            break;
          }
          if (self2.queue.length === 0) {
            break;
          }
          var connection2 = null;
          const connections = self2.availableConnections.filter((conn) => conn.workItems.length === 0);
          if (connections.length === 0) {
            connection2 = self2.availableConnections[self2.connectionIndex++ % self2.availableConnections.length];
          } else {
            connection2 = connections[self2.connectionIndex++ % connections.length];
          }
          if (!connection2.isConnected()) {
            removeConnection(self2, connection2);
            flushMonitoringOperations(self2.queue);
            break;
          }
          var workItem = self2.queue.shift();
          if (workItem.monitoring) {
            var foundValidConnection = false;
            for (let i = 0; i < self2.availableConnections.length; i++) {
              if (self2.availableConnections[i].isConnected() && self2.availableConnections[i].workItems.length === 0) {
                foundValidConnection = true;
                connection2 = self2.availableConnections[i];
                break;
              }
            }
            if (!foundValidConnection) {
              self2.queue.unshift(workItem);
              if (totalConnections < self2.options.size && self2.queue.length > 0) {
                createConnection(self2);
              }
              setTimeout(() => _execute(self2)(), 10);
              break;
            }
          }
          if (totalConnections < self2.options.size) {
            if (connection2.workItems.length > 0) {
              self2.queue.unshift(workItem);
              createConnection(self2);
              break;
            }
          }
          var buffer2 = workItem.buffer;
          if (workItem.monitoring) {
            moveConnectionBetween(connection2, self2.availableConnections, self2.inUseConnections);
          }
          if (!workItem.noResponse) {
            connection2.workItems.push(workItem);
          }
          if (!workItem.immediateRelease && typeof workItem.socketTimeout === "number") {
            connection2.setSocketTimeout(workItem.socketTimeout);
          }
          var writeSuccessful = true;
          if (Array.isArray(buffer2)) {
            for (let i = 0; i < buffer2.length; i++) {
              writeSuccessful = connection2.write(buffer2[i]);
            }
          } else {
            writeSuccessful = connection2.write(buffer2);
          }
          if (workItem.noResponse && typeof workItem.cb === "function") {
            workItem.cb(null, null);
          }
          if (writeSuccessful === false) {
            self2.queue.unshift(workItem);
            removeConnection(self2, connection2);
            flushMonitoringOperations(self2.queue);
            break;
          }
        }
        self2.executing = false;
      };
    }
    Pool._execute = _execute;
    module2.exports = Pool;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/command.js
var require_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Query = require_commands().Query;
    var Msg = require_msg().Msg;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var isSharded = require_shared().isSharded;
    var databaseNamespace = require_shared().databaseNamespace;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var applySession = require_sessions().applySession;
    var MongoNetworkError = require_error().MongoNetworkError;
    var maxWireVersion = require_utils2().maxWireVersion;
    function isClientEncryptionEnabled(server) {
      const wireVersion = maxWireVersion(server);
      return wireVersion && server.autoEncrypter;
    }
    function command(server, ns, cmd, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (!isClientEncryptionEnabled(server)) {
        _command(server, ns, cmd, options2, callback);
        return;
      }
      const wireVersion = maxWireVersion(server);
      if (typeof wireVersion !== "number" || wireVersion < 8) {
        callback(new MongoError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      _cryptCommand(server, ns, cmd, options2, callback);
    }
    function _command(server, ns, cmd, options2, callback) {
      const bson = server.s.bson;
      const pool = server.s.pool;
      const readPreference = getReadPreference(cmd, options2);
      const shouldUseOpMsg = supportsOpMsg(server);
      const session = options2.session;
      const serverClusterTime = server.clusterTime;
      let clusterTime = serverClusterTime;
      let finalCmd = Object.assign({}, cmd);
      if (hasSessionSupport(server) && session) {
        const sessionClusterTime = session.clusterTime;
        if (serverClusterTime && serverClusterTime.clusterTime && sessionClusterTime && sessionClusterTime.clusterTime && sessionClusterTime.clusterTime.greaterThan(serverClusterTime.clusterTime)) {
          clusterTime = sessionClusterTime;
        }
        const err = applySession(session, finalCmd, options2);
        if (err) {
          return callback(err);
        }
      }
      if (clusterTime) {
        finalCmd.$clusterTime = clusterTime;
      }
      if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        finalCmd = {
          $query: finalCmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        command: true,
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false
      }, options2);
      commandOptions.slaveOk = readPreference.slaveOk();
      const cmdNs = `${databaseNamespace(ns)}.$cmd`;
      const message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);
      const inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));
      const commandResponseHandler = inTransaction ? function(err) {
        if (err && err instanceof MongoNetworkError && !err.hasErrorLabel("TransientTransactionError")) {
          err.addErrorLabel("TransientTransactionError");
        }
        if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel("TransientTransactionError")) {
          session.transaction.unpinServer();
        }
        return callback.apply(null, arguments);
      } : callback;
      try {
        pool.write(message, commandOptions, commandResponseHandler);
      } catch (err) {
        commandResponseHandler(err);
      }
    }
    function hasSessionSupport(topology) {
      if (topology == null)
        return false;
      if (topology.description) {
        return topology.description.maxWireVersion >= 6;
      }
      return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;
    }
    function supportsOpMsg(topologyOrServer) {
      const description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;
      if (description == null) {
        return false;
      }
      return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;
    }
    function _cryptCommand(server, ns, cmd, options2, callback) {
      const autoEncrypter = server.autoEncrypter;
      function commandResponseHandler(err, response) {
        if (err || response == null) {
          callback(err, response);
          return;
        }
        autoEncrypter.decrypt(response.result, options2, (err2, decrypted) => {
          if (err2) {
            callback(err2, null);
            return;
          }
          response.result = decrypted;
          response.message.documents = [decrypted];
          callback(null, response);
        });
      }
      autoEncrypter.encrypt(ns, cmd, options2, (err, encrypted) => {
        if (err) {
          callback(err, null);
          return;
        }
        _command(server, ns, encrypted, options2, commandResponseHandler);
      });
    }
    module2.exports = command;
  }
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS({
  "node_modules/mongodb/lib/explain.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var ExplainVerbosity = {
      queryPlanner: "queryPlanner",
      queryPlannerExtended: "queryPlannerExtended",
      executionStats: "executionStats",
      allPlansExecution: "allPlansExecution"
    };
    var Explain = class {
      constructor(verbosity) {
        if (typeof verbosity === "boolean") {
          this.verbosity = verbosity ? "allPlansExecution" : "queryPlanner";
        } else {
          this.verbosity = verbosity;
        }
      }
      static fromOptions(options2) {
        if (options2 == null || options2.explain === void 0) {
          return;
        }
        const explain = options2.explain;
        if (typeof explain === "boolean" || explain in ExplainVerbosity) {
          return new Explain(options2.explain);
        }
        throw new MongoError(`explain must be one of ${Object.keys(ExplainVerbosity)} or a boolean`);
      }
    };
    module2.exports = { Explain };
  }
});

// node_modules/mongodb/lib/core/wireprotocol/write_command.js
var require_write_command = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/write_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var collectionNamespace = require_shared().collectionNamespace;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function writeCommand(server, type, opsField, ns, ops, options2, callback) {
      if (ops.length === 0)
        throw new MongoError(`${type} must contain at least one document`);
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      const ordered = typeof options2.ordered === "boolean" ? options2.ordered : true;
      const writeConcern = options2.writeConcern;
      let writeCommand2 = {};
      writeCommand2[type] = collectionNamespace(ns);
      writeCommand2[opsField] = ops;
      writeCommand2.ordered = ordered;
      if (writeConcern && Object.keys(writeConcern).length > 0) {
        writeCommand2.writeConcern = writeConcern;
      }
      if (options2.collation) {
        for (let i = 0; i < writeCommand2[opsField].length; i++) {
          if (!writeCommand2[opsField][i].collation) {
            writeCommand2[opsField][i].collation = options2.collation;
          }
        }
      }
      if (options2.bypassDocumentValidation === true) {
        writeCommand2.bypassDocumentValidation = options2.bypassDocumentValidation;
      }
      const explain = Explain.fromOptions(options2);
      if (explain) {
        writeCommand2 = decorateWithExplain(writeCommand2, explain);
      }
      const commandOptions = Object.assign({
        checkKeys: type === "insert",
        numberToReturn: 1
      }, options2);
      command(server, ns, writeCommand2, commandOptions, callback);
    }
    module2.exports = writeCommand;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js
var require_kill_cursors = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/kill_cursors.js"(exports2, module2) {
    init_shims();
    "use strict";
    var KillCursor = require_commands().KillCursor;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var emitWarning = require_utils2().emitWarning;
    var command = require_command();
    function killCursors(server, ns, cursorState, callback) {
      callback = typeof callback === "function" ? callback : () => {
      };
      const cursorId = cursorState.cursorId;
      if (maxWireVersion(server) < 4) {
        const bson = server.s.bson;
        const pool = server.s.pool;
        const killCursor = new KillCursor(bson, ns, [cursorId]);
        const options3 = {
          immediateRelease: true,
          noResponse: true
        };
        if (typeof cursorState.session === "object") {
          options3.session = cursorState.session;
        }
        if (pool && pool.isConnected()) {
          try {
            pool.write(killCursor, options3, callback);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err, null);
            } else {
              emitWarning(err);
            }
          }
        }
        return;
      }
      const killCursorCmd = {
        killCursors: collectionNamespace(ns),
        cursors: [cursorId]
      };
      const options2 = {};
      if (typeof cursorState.session === "object")
        options2.session = cursorState.session;
      command(server, ns, killCursorCmd, options2, (err, result) => {
        if (err) {
          return callback(err);
        }
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (!Array.isArray(response.documents) || response.documents.length === 0) {
          return callback(new MongoError(`invalid killCursors result returned for cursor id ${cursorId}`));
        }
        callback(null, response.documents[0]);
      });
    }
    module2.exports = killCursors;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/get_more.js
var require_get_more = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/get_more.js"(exports2, module2) {
    init_shims();
    "use strict";
    var GetMore = require_commands().GetMore;
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var collectionNamespace = require_shared().collectionNamespace;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    function getMore(server, ns, cursorState, batchSize, options2, callback) {
      options2 = options2 || {};
      const wireVersion = maxWireVersion(server);
      function queryCallback(err, result) {
        if (err)
          return callback(err);
        const response = result.message;
        if (response.cursorNotFound) {
          return callback(new MongoNetworkError("cursor killed or timed out"), null);
        }
        if (wireVersion < 4) {
          const cursorId3 = typeof response.cursorId === "number" ? Long2.fromNumber(response.cursorId) : response.cursorId;
          cursorState.documents = response.documents;
          cursorState.cursorId = cursorId3;
          callback(null, null, response.connection);
          return;
        }
        if (response.documents[0].ok === 0) {
          return callback(new MongoError(response.documents[0]));
        }
        const cursorId2 = typeof response.documents[0].cursor.id === "number" ? Long2.fromNumber(response.documents[0].cursor.id) : response.documents[0].cursor.id;
        cursorState.documents = response.documents[0].cursor.nextBatch;
        cursorState.cursorId = cursorId2;
        callback(null, response.documents[0], response.connection);
      }
      if (wireVersion < 4) {
        const bson = server.s.bson;
        const getMoreOp = new GetMore(bson, ns, cursorState.cursorId, { numberToReturn: batchSize });
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        server.s.pool.write(getMoreOp, queryOptions, queryCallback);
        return;
      }
      const cursorId = cursorState.cursorId instanceof Long2 ? cursorState.cursorId : Long2.fromNumber(cursorState.cursorId);
      const getMoreCmd = {
        getMore: cursorId,
        collection: collectionNamespace(ns),
        batchSize: Math.abs(batchSize)
      };
      if (cursorState.cmd.tailable && typeof cursorState.cmd.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
      }
      const commandOptions = Object.assign({
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch"
      }, options2);
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, getMoreCmd, commandOptions, queryCallback);
    }
    module2.exports = getMore;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/query.js
var require_query = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/query.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Query = require_commands().Query;
    var MongoError = require_error().MongoError;
    var getReadPreference = require_shared().getReadPreference;
    var collectionNamespace = require_shared().collectionNamespace;
    var isSharded = require_shared().isSharded;
    var maxWireVersion = require_utils2().maxWireVersion;
    var applyCommonQueryOptions = require_shared().applyCommonQueryOptions;
    var command = require_command();
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var Explain = require_explain().Explain;
    function query(server, ns, cmd, cursorState, options2, callback) {
      options2 = options2 || {};
      if (cursorState.cursorId != null) {
        return callback();
      }
      if (cmd == null) {
        return callback(new MongoError(`command ${JSON.stringify(cmd)} does not return a cursor`));
      }
      if (maxWireVersion(server) < 4) {
        const query2 = prepareLegacyFindQuery(server, ns, cmd, cursorState, options2);
        const queryOptions = applyCommonQueryOptions({}, cursorState);
        if (typeof query2.documentsReturnedIn === "string") {
          queryOptions.documentsReturnedIn = query2.documentsReturnedIn;
        }
        server.s.pool.write(query2, queryOptions, callback);
        return;
      }
      const readPreference = getReadPreference(cmd, options2);
      let findCmd = prepareFindCommand(server, ns, cmd, cursorState, options2);
      const explain = Explain.fromOptions(options2);
      if (explain) {
        findCmd = decorateWithExplain(findCmd, explain);
      }
      cmd.virtual = false;
      const commandOptions = Object.assign({
        documentsReturnedIn: "firstBatch",
        numberToReturn: 1,
        slaveOk: readPreference.slaveOk()
      }, options2);
      if (cmd.readPreference) {
        commandOptions.readPreference = readPreference;
      }
      if (cursorState.session) {
        commandOptions.session = cursorState.session;
      }
      command(server, ns, findCmd, commandOptions, callback);
    }
    function prepareFindCommand(server, ns, cmd, cursorState) {
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      const findCmd = {
        find: collectionNamespace(ns)
      };
      if (cmd.query) {
        if (cmd.query["$query"]) {
          findCmd.filter = cmd.query["$query"];
        } else {
          findCmd.filter = cmd.query;
        }
      }
      let sortValue = cmd.sort;
      if (Array.isArray(sortValue)) {
        const sortObject = {};
        if (sortValue.length > 0 && !Array.isArray(sortValue[0])) {
          let sortDirection = sortValue[1];
          if (sortDirection === "asc") {
            sortDirection = 1;
          } else if (sortDirection === "desc") {
            sortDirection = -1;
          }
          sortObject[sortValue[0]] = sortDirection;
        } else {
          for (let i = 0; i < sortValue.length; i++) {
            let sortDirection = sortValue[i][1];
            if (sortDirection === "asc") {
              sortDirection = 1;
            } else if (sortDirection === "desc") {
              sortDirection = -1;
            }
            sortObject[sortValue[i][0]] = sortDirection;
          }
        }
        sortValue = sortObject;
      }
      if (typeof cmd.allowDiskUse === "boolean") {
        findCmd.allowDiskUse = cmd.allowDiskUse;
      }
      if (cmd.sort)
        findCmd.sort = sortValue;
      if (cmd.fields)
        findCmd.projection = cmd.fields;
      if (cmd.hint)
        findCmd.hint = cmd.hint;
      if (cmd.skip)
        findCmd.skip = cmd.skip;
      if (cmd.limit)
        findCmd.limit = cmd.limit;
      if (cmd.limit < 0) {
        findCmd.limit = Math.abs(cmd.limit);
        findCmd.singleBatch = true;
      }
      if (typeof cmd.batchSize === "number") {
        if (cmd.batchSize < 0) {
          if (cmd.limit !== 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
            findCmd.limit = Math.abs(cmd.batchSize);
          }
          findCmd.singleBatch = true;
        }
        findCmd.batchSize = Math.abs(cmd.batchSize);
      }
      if (cmd.comment)
        findCmd.comment = cmd.comment;
      if (cmd.maxScan)
        findCmd.maxScan = cmd.maxScan;
      if (cmd.maxTimeMS)
        findCmd.maxTimeMS = cmd.maxTimeMS;
      if (cmd.min)
        findCmd.min = cmd.min;
      if (cmd.max)
        findCmd.max = cmd.max;
      findCmd.returnKey = cmd.returnKey ? cmd.returnKey : false;
      findCmd.showRecordId = cmd.showDiskLoc ? cmd.showDiskLoc : false;
      if (cmd.snapshot)
        findCmd.snapshot = cmd.snapshot;
      if (cmd.tailable)
        findCmd.tailable = cmd.tailable;
      if (cmd.oplogReplay)
        findCmd.oplogReplay = cmd.oplogReplay;
      if (cmd.noCursorTimeout)
        findCmd.noCursorTimeout = cmd.noCursorTimeout;
      if (cmd.awaitData)
        findCmd.awaitData = cmd.awaitData;
      if (cmd.awaitdata)
        findCmd.awaitData = cmd.awaitdata;
      if (cmd.partial)
        findCmd.partial = cmd.partial;
      if (cmd.collation)
        findCmd.collation = cmd.collation;
      if (cmd.readConcern)
        findCmd.readConcern = cmd.readConcern;
      return findCmd;
    }
    function prepareLegacyFindQuery(server, ns, cmd, cursorState, options2) {
      options2 = options2 || {};
      const bson = server.s.bson;
      const readPreference = getReadPreference(cmd, options2);
      cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
      let numberToReturn = 0;
      if (cursorState.limit < 0 || cursorState.limit !== 0 && cursorState.limit < cursorState.batchSize || cursorState.limit > 0 && cursorState.batchSize === 0) {
        numberToReturn = cursorState.limit;
      } else {
        numberToReturn = cursorState.batchSize;
      }
      const numberToSkip = cursorState.skip || 0;
      const findCmd = {};
      if (isSharded(server) && readPreference) {
        findCmd["$readPreference"] = readPreference.toJSON();
      }
      if (cmd.sort)
        findCmd["$orderby"] = cmd.sort;
      if (cmd.hint)
        findCmd["$hint"] = cmd.hint;
      if (cmd.snapshot)
        findCmd["$snapshot"] = cmd.snapshot;
      if (typeof cmd.returnKey !== "undefined")
        findCmd["$returnKey"] = cmd.returnKey;
      if (cmd.maxScan)
        findCmd["$maxScan"] = cmd.maxScan;
      if (cmd.min)
        findCmd["$min"] = cmd.min;
      if (cmd.max)
        findCmd["$max"] = cmd.max;
      if (typeof cmd.showDiskLoc !== "undefined")
        findCmd["$showDiskLoc"] = cmd.showDiskLoc;
      if (cmd.comment)
        findCmd["$comment"] = cmd.comment;
      if (cmd.maxTimeMS)
        findCmd["$maxTimeMS"] = cmd.maxTimeMS;
      if (options2.explain !== void 0) {
        numberToReturn = -Math.abs(cmd.limit || 0);
        findCmd["$explain"] = true;
      }
      findCmd["$query"] = cmd.query;
      if (cmd.readConcern && cmd.readConcern.level !== "local") {
        throw new MongoError(`server find command does not support a readConcern level of ${cmd.readConcern.level}`);
      }
      if (cmd.readConcern) {
        cmd = Object.assign({}, cmd);
        delete cmd["readConcern"];
      }
      const serializeFunctions = typeof options2.serializeFunctions === "boolean" ? options2.serializeFunctions : false;
      const ignoreUndefined = typeof options2.ignoreUndefined === "boolean" ? options2.ignoreUndefined : false;
      const query2 = new Query(bson, ns, findCmd, {
        numberToSkip,
        numberToReturn,
        pre32Limit: typeof cmd.limit !== "undefined" ? cmd.limit : void 0,
        checkKeys: false,
        returnFieldSelector: cmd.fields,
        serializeFunctions,
        ignoreUndefined
      });
      if (typeof cmd.tailable === "boolean")
        query2.tailable = cmd.tailable;
      if (typeof cmd.oplogReplay === "boolean")
        query2.oplogReplay = cmd.oplogReplay;
      if (typeof cmd.noCursorTimeout === "boolean")
        query2.noCursorTimeout = cmd.noCursorTimeout;
      if (typeof cmd.awaitData === "boolean")
        query2.awaitData = cmd.awaitData;
      if (typeof cmd.partial === "boolean")
        query2.partial = cmd.partial;
      query2.slaveOk = readPreference.slaveOk();
      return query2;
    }
    module2.exports = query;
  }
});

// node_modules/mongodb/lib/core/wireprotocol/index.js
var require_wireprotocol = __commonJS({
  "node_modules/mongodb/lib/core/wireprotocol/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var writeCommand = require_write_command();
    module2.exports = {
      insert: function insert(server, ns, ops, options2, callback) {
        writeCommand(server, "insert", "documents", ns, ops, options2, callback);
      },
      update: function update2(server, ns, ops, options2, callback) {
        writeCommand(server, "update", "updates", ns, ops, options2, callback);
      },
      remove: function remove(server, ns, ops, options2, callback) {
        writeCommand(server, "delete", "deletes", ns, ops, options2, callback);
      },
      killCursors: require_kill_cursors(),
      getMore: require_get_more(),
      query: require_query(),
      command: require_command()
    };
  }
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS({
  "node_modules/mongodb/lib/operations/operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Explain = require_explain().Explain;
    var MongoError = require_error().MongoError;
    var Aspect = {
      READ_OPERATION: Symbol("READ_OPERATION"),
      WRITE_OPERATION: Symbol("WRITE_OPERATION"),
      RETRYABLE: Symbol("RETRYABLE"),
      EXECUTE_WITH_SELECTION: Symbol("EXECUTE_WITH_SELECTION"),
      NO_INHERIT_OPTIONS: Symbol("NO_INHERIT_OPTIONS"),
      EXPLAINABLE: Symbol("EXPLAINABLE")
    };
    var OperationBase = class {
      constructor(options2) {
        this.options = Object.assign({}, options2);
        if (this.hasAspect(Aspect.EXPLAINABLE)) {
          this.explain = Explain.fromOptions(options2);
        } else if (this.options.explain !== void 0) {
          throw new MongoError(`explain is not supported on this command`);
        }
      }
      hasAspect(aspect) {
        if (this.constructor.aspects == null) {
          return false;
        }
        return this.constructor.aspects.has(aspect);
      }
      set session(session) {
        Object.assign(this.options, { session });
      }
      get session() {
        return this.options.session;
      }
      clearSession() {
        delete this.options.session;
      }
      get canRetryRead() {
        return true;
      }
      execute() {
        throw new TypeError("`execute` must be implemented for OperationBase subclasses");
      }
    };
    function defineAspects(operation, aspects) {
      if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
        aspects = [aspects];
      }
      aspects = new Set(aspects);
      Object.defineProperty(operation, "aspects", {
        value: aspects,
        writable: false
      });
      return aspects;
    }
    module2.exports = {
      Aspect,
      defineAspects,
      OperationBase
    };
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS({
  "node_modules/mongodb/lib/operations/execute_operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var maybePromise = require_utils4().maybePromise;
    var MongoError = require_error().MongoError;
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_read_preference();
    var isRetryableError = require_error().isRetryableError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    function executeOperation(topology, operation, cb) {
      if (topology == null) {
        throw new TypeError("This method requires a valid topology instance");
      }
      if (!(operation instanceof OperationBase)) {
        throw new TypeError("This method requires a valid operation instance");
      }
      return maybePromise(topology, cb, (callback) => {
        if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {
          return selectServerForSessionSupport(topology, operation, callback);
        }
        let session, owner;
        if (topology.hasSessionSupport()) {
          if (operation.session == null) {
            owner = Symbol();
            session = topology.startSession({ owner });
            operation.session = session;
          } else if (operation.session.hasEnded) {
            return callback(new MongoError("Use of expired sessions is not permitted"));
          }
        } else if (operation.session) {
          return callback(new MongoError("Current topology does not support sessions"));
        }
        function executeCallback(err, result) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(err, result);
        }
        try {
          if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {
            executeWithServerSelection(topology, operation, executeCallback);
          } else {
            operation.execute(executeCallback);
          }
        } catch (error3) {
          if (session && session.owner === owner) {
            session.endSession();
            if (operation.session === session) {
              operation.clearSession();
            }
          }
          callback(error3);
        }
      });
    }
    function supportsRetryableReads(server) {
      return maxWireVersion(server) >= 6;
    }
    function executeWithServerSelection(topology, operation, callback) {
      const readPreference = operation.readPreference || ReadPreference.primary;
      const inTransaction = operation.session && operation.session.inTransaction();
      if (inTransaction && !readPreference.equals(ReadPreference.primary)) {
        callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));
        return;
      }
      const serverSelectionOptions = {
        readPreference,
        session: operation.session
      };
      function callbackWithRetry(err, result) {
        if (err == null) {
          return callback(null, result);
        }
        if (!isRetryableError(err)) {
          return callback(err);
        }
        topology.selectServer(serverSelectionOptions, (err2, server) => {
          if (err2 || !supportsRetryableReads(server)) {
            callback(err2, null);
            return;
          }
          operation.execute(server, callback);
        });
      }
      topology.selectServer(serverSelectionOptions, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;
        if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {
          operation.execute(server, callbackWithRetry);
          return;
        }
        operation.execute(server, callback);
      });
    }
    function selectServerForSessionSupport(topology, operation, callback) {
      topology.selectServer(ReadPreference.primaryPreferred, (err) => {
        if (err) {
          return callback(err);
        }
        executeOperation(topology, operation, callback);
      });
    }
    module2.exports = executeOperation;
  }
});

// node_modules/mongodb/lib/core/cursor.js
var require_cursor = __commonJS({
  "node_modules/mongodb/lib/core/cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var ReadPreference = require_read_preference();
    var isUnifiedTopology = require_utils2().isUnifiedTopology;
    var executeOperation = require_execute_operation();
    var Readable2 = __require("stream").Readable;
    var SUPPORTS = require_utils4().SUPPORTS;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var mergeOptions = require_utils4().mergeOptions;
    var OperationBase = require_operation().OperationBase;
    var BSON2 = retrieveBSON();
    var Long2 = BSON2.Long;
    var CursorState = {
      INIT: 0,
      OPEN: 1,
      CLOSED: 2,
      GET_MORE: 3
    };
    function handleCallback(callback, err, result) {
      try {
        callback(err, result);
      } catch (err2) {
        process.nextTick(function() {
          throw err2;
        });
      }
    }
    var CoreCursor = class extends Readable2 {
      constructor(topology, ns, cmd, options2) {
        super({ objectMode: true });
        options2 = options2 || {};
        if (ns instanceof OperationBase) {
          this.operation = ns;
          ns = this.operation.ns.toString();
          options2 = this.operation.options;
          cmd = this.operation.cmd ? this.operation.cmd : {};
        }
        this.pool = null;
        this.server = null;
        this.disconnectHandler = options2.disconnectHandler;
        this.bson = topology.s.bson;
        this.ns = ns;
        this.namespace = MongoDBNamespace.fromString(ns);
        this.cmd = cmd;
        this.options = options2;
        this.topology = topology;
        this.cursorState = {
          cursorId: null,
          cmd,
          documents: options2.documents || [],
          cursorIndex: 0,
          dead: false,
          killed: false,
          init: false,
          notified: false,
          limit: options2.limit || cmd.limit || 0,
          skip: options2.skip || cmd.skip || 0,
          batchSize: options2.batchSize || cmd.batchSize || 1e3,
          currentLimit: 0,
          transforms: options2.transforms,
          raw: options2.raw || cmd && cmd.raw
        };
        if (typeof options2.session === "object") {
          this.cursorState.session = options2.session;
        }
        const topologyOptions = topology.s.options;
        if (typeof topologyOptions.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = topologyOptions.promoteLongs;
        } else if (typeof options2.promoteLongs === "boolean") {
          this.cursorState.promoteLongs = options2.promoteLongs;
        }
        if (typeof topologyOptions.promoteValues === "boolean") {
          this.cursorState.promoteValues = topologyOptions.promoteValues;
        } else if (typeof options2.promoteValues === "boolean") {
          this.cursorState.promoteValues = options2.promoteValues;
        }
        if (typeof topologyOptions.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
        } else if (typeof options2.promoteBuffers === "boolean") {
          this.cursorState.promoteBuffers = options2.promoteBuffers;
        }
        if (topologyOptions.reconnect) {
          this.cursorState.reconnect = topologyOptions.reconnect;
        }
        this.logger = Logger("Cursor", topologyOptions);
        if (typeof cmd === "number") {
          this.cursorState.cursorId = Long2.fromNumber(cmd);
          this.cursorState.lastCursorId = this.cursorState.cursorId;
        } else if (cmd instanceof Long2) {
          this.cursorState.cursorId = cmd;
          this.cursorState.lastCursorId = cmd;
        }
        if (this.operation) {
          this.operation.cursorState = this.cursorState;
        }
      }
      setCursorBatchSize(value) {
        this.cursorState.batchSize = value;
      }
      cursorBatchSize() {
        return this.cursorState.batchSize;
      }
      setCursorLimit(value) {
        this.cursorState.limit = value;
      }
      cursorLimit() {
        return this.cursorState.limit;
      }
      setCursorSkip(value) {
        this.cursorState.skip = value;
      }
      cursorSkip() {
        return this.cursorState.skip;
      }
      _next(callback) {
        nextFunction(this, callback);
      }
      clone() {
        const clonedOptions = mergeOptions({}, this.options);
        delete clonedOptions.session;
        return this.topology.cursor(this.ns, this.cmd, clonedOptions);
      }
      isDead() {
        return this.cursorState.dead === true;
      }
      isKilled() {
        return this.cursorState.killed === true;
      }
      isNotified() {
        return this.cursorState.notified === true;
      }
      bufferedCount() {
        return this.cursorState.documents.length - this.cursorState.cursorIndex;
      }
      readBufferedDocuments(number) {
        const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
        const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
        let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
        if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === "function") {
          for (let i = 0; i < elements.length; i++) {
            elements[i] = this.cursorState.transforms.doc(elements[i]);
          }
        }
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {
          elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);
          this.kill();
        }
        this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
        this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
        return elements;
      }
      kill(callback) {
        this.cursorState.dead = true;
        this.cursorState.killed = true;
        this.cursorState.documents = [];
        if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {
          if (callback)
            callback(null, null);
          return;
        }
        this.server.killCursors(this.ns, this.cursorState, callback);
      }
      rewind() {
        if (this.cursorState.init) {
          if (!this.cursorState.dead) {
            this.kill();
          }
          this.cursorState.currentLimit = 0;
          this.cursorState.init = false;
          this.cursorState.dead = false;
          this.cursorState.killed = false;
          this.cursorState.notified = false;
          this.cursorState.documents = [];
          this.cursorState.cursorId = null;
          this.cursorState.cursorIndex = 0;
        }
      }
      _read() {
        if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {
          return this.push(null);
        }
        this._next((err, result) => {
          if (err) {
            if (this.listeners("error") && this.listeners("error").length > 0) {
              this.emit("error", err);
            }
            if (!this.isDead())
              this.close();
            this.emit("end");
            return this.emit("finish");
          }
          if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === "function" && result != null) {
            return this.push(this.cursorState.streamOptions.transform(result));
          }
          this.push(result);
          if (result === null && this.isDead()) {
            this.once("end", () => {
              this.close();
              this.emit("finish");
            });
          }
        });
      }
      _endSession(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        const session = this.cursorState.session;
        if (session && (options2.force || session.owner === this)) {
          this.cursorState.session = void 0;
          if (this.operation) {
            this.operation.clearSession();
          }
          session.endSession(callback);
          return true;
        }
        if (callback) {
          callback();
        }
        return false;
      }
      _getMore(callback) {
        if (this.logger.isDebug()) {
          this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);
        }
        let batchSize = this.cursorState.batchSize;
        if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {
          batchSize = this.cursorState.limit - this.cursorState.currentLimit;
        }
        const cursorState = this.cursorState;
        this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            this._endSession();
          }
          callback(err, result, conn);
        });
      }
      _initializeCursor(callback) {
        const cursor = this;
        if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {
          cursor.topology.selectServer(ReadPreference.primaryPreferred, (err) => {
            if (err) {
              callback(err);
              return;
            }
            this._initializeCursor(callback);
          });
          return;
        }
        function done(err, result) {
          const cursorState = cursor.cursorState;
          if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {
            cursor._endSession();
          }
          if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {
            return setCursorNotified(cursor, callback);
          }
          callback(err, result);
        }
        const queryCallback = (err, r) => {
          if (err) {
            return done(err);
          }
          const result = r.message;
          if (Array.isArray(result.documents) && result.documents.length === 1) {
            const document2 = result.documents[0];
            if (result.queryFailure) {
              return done(new MongoError(document2), null);
            }
            if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {
              if (document2.$err || document2.errmsg) {
                return done(new MongoError(document2), null);
              }
              if (document2.cursor != null && typeof document2.cursor !== "string") {
                const id = document2.cursor.id;
                if (document2.cursor.ns) {
                  cursor.ns = document2.cursor.ns;
                }
                cursor.cursorState.cursorId = typeof id === "number" ? Long2.fromNumber(id) : id;
                cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;
                cursor.cursorState.operationTime = document2.operationTime;
                if (Array.isArray(document2.cursor.firstBatch)) {
                  cursor.cursorState.documents = document2.cursor.firstBatch;
                }
                return done(null, result);
              }
            }
          }
          const cursorId = result.cursorId || 0;
          cursor.cursorState.cursorId = cursorId instanceof Long2 ? cursorId : Long2.fromNumber(cursorId);
          cursor.cursorState.documents = result.documents;
          cursor.cursorState.lastCursorId = result.cursorId;
          if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === "function") {
            cursor.cursorState.documents = cursor.cursorState.transforms.query(result);
          }
          done(null, result);
        };
        if (cursor.operation) {
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          executeOperation(cursor.topology, cursor.operation, (err, result) => {
            if (err) {
              done(err);
              return;
            }
            cursor.server = cursor.operation.server;
            cursor.cursorState.init = true;
            if (cursor.cursorState.cursorId != null) {
              return done();
            }
            queryCallback(err, result);
          });
          return;
        }
        const serverSelectOptions = {};
        if (cursor.cursorState.session) {
          serverSelectOptions.session = cursor.cursorState.session;
        }
        if (cursor.operation) {
          serverSelectOptions.readPreference = cursor.operation.readPreference;
        } else if (cursor.options.readPreference) {
          serverSelectOptions.readPreference = cursor.options.readPreference;
        }
        return cursor.topology.selectServer(serverSelectOptions, (err, server) => {
          if (err) {
            const disconnectHandler = cursor.disconnectHandler;
            if (disconnectHandler != null) {
              return disconnectHandler.addObjectAndMethod("cursor", cursor, "next", [callback], callback);
            }
            return callback(err);
          }
          cursor.server = server;
          cursor.cursorState.init = true;
          if (collationNotSupported(cursor.server, cursor.cmd)) {
            return callback(new MongoError(`server ${cursor.server.name} does not support collation`));
          }
          if (cursor.cursorState.cursorId != null) {
            return done();
          }
          if (cursor.logger.isDebug()) {
            cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);
          }
          if (cursor.cmd.find != null) {
            server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);
            return;
          }
          const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);
          server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);
        });
      }
    };
    if (SUPPORTS.ASYNC_ITERATOR) {
      CoreCursor.prototype[Symbol.asyncIterator] = require_async_iterator().asyncIterator;
    }
    function isConnectionDead(self2, callback) {
      if (self2.pool && self2.pool.isDestroyed()) {
        self2.cursorState.killed = true;
        const err = new MongoNetworkError(`connection to host ${self2.pool.host}:${self2.pool.port} was destroyed`);
        _setCursorNotifiedImpl(self2, () => callback(err));
        return true;
      }
      return false;
    }
    function isCursorDeadButNotkilled(self2, callback) {
      if (self2.cursorState.dead && !self2.cursorState.killed) {
        self2.cursorState.killed = true;
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function isCursorDeadAndKilled(self2, callback) {
      if (self2.cursorState.dead && self2.cursorState.killed) {
        handleCallback(callback, new MongoError("cursor is dead"));
        return true;
      }
      return false;
    }
    function isCursorKilled(self2, callback) {
      if (self2.cursorState.killed) {
        setCursorNotified(self2, callback);
        return true;
      }
      return false;
    }
    function setCursorDeadAndNotified(self2, callback) {
      self2.cursorState.dead = true;
      setCursorNotified(self2, callback);
    }
    function setCursorNotified(self2, callback) {
      _setCursorNotifiedImpl(self2, () => handleCallback(callback, null, null));
    }
    function _setCursorNotifiedImpl(self2, callback) {
      self2.cursorState.notified = true;
      self2.cursorState.documents = [];
      self2.cursorState.cursorIndex = 0;
      if (self2.cursorState.session) {
        self2._endSession(callback);
        return;
      }
      return callback();
    }
    function nextFunction(self2, callback) {
      if (self2.cursorState.notified) {
        return callback(new Error("cursor is exhausted"));
      }
      if (isCursorKilled(self2, callback))
        return;
      if (isCursorDeadButNotkilled(self2, callback))
        return;
      if (isCursorDeadAndKilled(self2, callback))
        return;
      if (!self2.cursorState.init) {
        if (!self2.topology.isConnected(self2.options)) {
          if (self2.topology._type === "server" && !self2.topology.s.options.reconnect) {
            return callback(new MongoError("no connection available"));
          }
          if (self2.disconnectHandler != null) {
            if (self2.topology.isDestroyed()) {
              return callback(new MongoError("Topology was destroyed"));
            }
            self2.disconnectHandler.addObjectAndMethod("cursor", self2, "next", [callback], callback);
            return;
          }
        }
        self2._initializeCursor((err, result) => {
          if (err || result === null) {
            callback(err, result);
            return;
          }
          nextFunction(self2, callback);
        });
        return;
      }
      if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
        self2.kill(() => setCursorDeadAndNotified(self2, callback));
      } else if (self2.cursorState.cursorIndex === self2.cursorState.documents.length && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
        self2.cursorState.documents = [];
        self2.cursorState.cursorIndex = 0;
        if (self2.topology.isDestroyed())
          return callback(new MongoNetworkError("connection destroyed, not possible to instantiate cursor"));
        if (isConnectionDead(self2, callback))
          return;
        self2._getMore(function(err, doc, connection2) {
          if (err) {
            return handleCallback(callback, err);
          }
          self2.connection = connection2;
          if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return handleCallback(callback, new MongoError({
              message: "No more documents in tailed cursor",
              tailable: self2.cmd.tailable,
              awaitData: self2.cmd.awaitData
            }));
          } else if (self2.cursorState.documents.length === 0 && self2.cmd.tailable && !Long2.ZERO.equals(self2.cursorState.cursorId)) {
            return nextFunction(self2, callback);
          }
          if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
            return setCursorDeadAndNotified(self2, callback);
          }
          nextFunction(self2, callback);
        });
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && self2.cmd.tailable && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        return handleCallback(callback, new MongoError({
          message: "No more documents in tailed cursor",
          tailable: self2.cmd.tailable,
          awaitData: self2.cmd.awaitData
        }));
      } else if (self2.cursorState.documents.length === self2.cursorState.cursorIndex && Long2.ZERO.equals(self2.cursorState.cursorId)) {
        setCursorDeadAndNotified(self2, callback);
      } else {
        if (self2.cursorState.limit > 0 && self2.cursorState.currentLimit >= self2.cursorState.limit) {
          self2.kill(() => setCursorDeadAndNotified(self2, callback));
          return;
        }
        self2.cursorState.currentLimit += 1;
        let doc = self2.cursorState.documents[self2.cursorState.cursorIndex++];
        if (!doc || doc.$err) {
          self2.kill(() => setCursorDeadAndNotified(self2, function() {
            handleCallback(callback, new MongoError(doc ? doc.$err : void 0));
          }));
          return;
        }
        if (self2.cursorState.transforms && typeof self2.cursorState.transforms.doc === "function") {
          doc = self2.cursorState.transforms.doc(doc);
        }
        handleCallback(callback, null, doc);
      }
    }
    module2.exports = {
      CursorState,
      CoreCursor
    };
  }
});

// node_modules/mongodb/lib/core/topologies/server.js
var require_server = __commonJS({
  "node_modules/mongodb/lib/core/topologies/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var Logger = require_logger();
    var debugOptions = require_utils3().debugOptions;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Pool = require_pool();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var wireProtocol = require_wireprotocol();
    var CoreCursor = require_cursor().CoreCursor;
    var sdam = require_shared2();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SessionMixins = require_shared2().SessionMixins;
    var relayEvents = require_utils2().relayEvents;
    var collationNotSupported = require_utils2().collationNotSupported;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var debugFields = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var id = 0;
    var serverAccounting = false;
    var servers = {};
    var BSON2 = retrieveBSON();
    function topologyId(server) {
      return server.s.parent == null ? server.id : server.s.parent.id;
    }
    var Server = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.id = id++;
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        logger: Logger("Server", options2),
        Cursor: options2.cursorFactory || CoreCursor,
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        pool: null,
        disconnectHandler: options2.disconnectHandler,
        monitoring: typeof options2.monitoring === "boolean" ? options2.monitoring : true,
        inTopology: !!options2.parent,
        monitoringInterval: typeof options2.monitoringInterval === "number" ? options2.monitoringInterval : 5e3,
        compression: { compressors: createCompressionInfo(options2) },
        parent: options2.parent
      };
      if (!this.s.parent) {
        this.s.clusterTime = null;
      }
      this.ismaster = null;
      this.lastIsMasterMS = -1;
      this.monitoringProcessId = null;
      this.initialConnect = true;
      this._type = "server";
      this.lastUpdateTime = 0;
      this.lastWriteDate = 0;
      this.staleness = 0;
    };
    inherits(Server, EventEmitter);
    Object.assign(Server.prototype, SessionMixins);
    Object.defineProperty(Server.prototype, "type", {
      enumerable: true,
      get: function() {
        return this._type;
      }
    });
    Object.defineProperty(Server.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Server.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    Object.defineProperty(Server.prototype, "clientMetadata", {
      enumerable: true,
      get: function() {
        return this.s.options.metadata;
      }
    });
    Object.defineProperty(Server.prototype, "clusterTime", {
      enumerable: true,
      set: function(clusterTime) {
        const settings = this.s.parent ? this.s.parent : this.s;
        resolveClusterTime(settings, clusterTime);
      },
      get: function() {
        const settings = this.s.parent ? this.s.parent : this.s;
        return settings.clusterTime || null;
      }
    });
    Server.enableServerAccounting = function() {
      serverAccounting = true;
      servers = {};
    };
    Server.disableServerAccounting = function() {
      serverAccounting = false;
    };
    Server.servers = function() {
      return servers;
    };
    Object.defineProperty(Server.prototype, "name", {
      enumerable: true,
      get: function() {
        return this.s.options.host + ":" + this.s.options.port;
      }
    });
    function disconnectHandler(self2, type, ns, cmd, options2, callback) {
      if (!self2.s.pool.isConnected() && self2.s.options.reconnect && self2.s.disconnectHandler != null && !options2.monitoring) {
        self2.s.disconnectHandler.add(type, ns, cmd, options2, callback);
        return true;
      }
      if (!self2.s.pool.isConnected()) {
        callback(new MongoError(f("no connection available to server %s", self2.name)));
        return true;
      }
    }
    function monitoringProcess(self2) {
      return function() {
        if (self2.s.pool.isDestroyed())
          return;
        self2.emit("monitoring", self2);
        var start = new Date().getTime();
        self2.command("admin.$cmd", { ismaster: true }, {
          socketTimeout: typeof self2.s.options.connectionTimeout !== "number" ? 2e3 : self2.s.options.connectionTimeout,
          monitoring: true
        }, (err, result) => {
          self2.lastIsMasterMS = new Date().getTime() - start;
          if (self2.s.pool.isDestroyed())
            return;
          if (result) {
            self2.ismaster = result.result;
          }
          self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
        });
      };
    }
    var eventHandler = function(self2, event) {
      return function(err, conn) {
        if (self2.s.logger.isInfo()) {
          var object = err instanceof MongoError ? JSON.stringify(err) : {};
          self2.s.logger.info(f("server %s fired event %s out with message %s", self2.name, event, object));
        }
        if (event === "connect") {
          self2.initialConnect = false;
          self2.ismaster = conn.ismaster;
          self2.lastIsMasterMS = conn.lastIsMasterMS;
          if (conn.agreedCompressor) {
            self2.s.pool.options.agreedCompressor = conn.agreedCompressor;
          }
          if (conn.zlibCompressionLevel) {
            self2.s.pool.options.zlibCompressionLevel = conn.zlibCompressionLevel;
          }
          if (conn.ismaster.$clusterTime) {
            const $clusterTime = conn.ismaster.$clusterTime;
            self2.clusterTime = $clusterTime;
          }
          if (self2.ismaster.msg === "isdbgrid") {
            self2._type = "mongos";
          }
          if (self2.s.monitoring) {
            self2.monitoringProcessId = setTimeout(monitoringProcess(self2), self2.s.monitoringInterval);
          }
          sdam.emitServerDescriptionChanged(self2, {
            address: self2.name,
            arbiters: [],
            hosts: [],
            passives: [],
            type: sdam.getTopologyType(self2)
          });
          if (!self2.s.inTopology) {
            sdam.emitTopologyDescriptionChanged(self2, {
              topologyType: "Single",
              servers: [
                {
                  address: self2.name,
                  arbiters: [],
                  hosts: [],
                  passives: [],
                  type: sdam.getTopologyType(self2)
                }
              ]
            });
          }
          if (self2.s.logger.isInfo()) {
            self2.s.logger.info(f("server %s connected with ismaster [%s]", self2.name, JSON.stringify(self2.ismaster)));
          }
          self2.emit("connect", self2);
        } else if (event === "error" || event === "parseError" || event === "close" || event === "timeout" || event === "reconnect" || event === "attemptReconnect" || event === "reconnectFailed") {
          if (serverAccounting && ["close", "timeout", "error", "parseError", "reconnectFailed"].indexOf(event) !== -1) {
            if (!self2.s.inTopology) {
              self2.emit("topologyOpening", { topologyId: self2.id });
            }
            delete servers[self2.id];
          }
          if (event === "close") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: "Unknown"
            });
          }
          if (event === "reconnectFailed") {
            self2.emit("reconnectFailed", err);
            if (self2.listeners("error").length > 0) {
              self2.emit("error", err);
            }
            return;
          }
          if (["disconnected", "connecting"].indexOf(self2.s.pool.state) !== -1 && self2.initialConnect && ["close", "timeout", "error", "parseError"].indexOf(event) !== -1) {
            self2.initialConnect = false;
            return self2.emit("error", new MongoNetworkError(f("failed to connect to server [%s] on first connect [%s]", self2.name, err)));
          }
          if (event === "reconnect") {
            sdam.emitServerDescriptionChanged(self2, {
              address: self2.name,
              arbiters: [],
              hosts: [],
              passives: [],
              type: sdam.getTopologyType(self2)
            });
            return self2.emit(event, self2);
          }
          self2.emit(event, err);
        }
      };
    };
    Server.prototype.connect = function(options2) {
      var self2 = this;
      options2 = options2 || {};
      if (serverAccounting)
        servers[this.id] = this;
      if (self2.s.pool && !self2.s.pool.isDisconnected() && !self2.s.pool.isDestroyed()) {
        throw new MongoError(f("server instance in invalid state %s", self2.s.pool.state));
      }
      self2.s.pool = new Pool(this, Object.assign(self2.s.options, options2, { bson: this.s.bson }));
      self2.s.pool.on("close", eventHandler(self2, "close"));
      self2.s.pool.on("error", eventHandler(self2, "error"));
      self2.s.pool.on("timeout", eventHandler(self2, "timeout"));
      self2.s.pool.on("parseError", eventHandler(self2, "parseError"));
      self2.s.pool.on("connect", eventHandler(self2, "connect"));
      self2.s.pool.on("reconnect", eventHandler(self2, "reconnect"));
      self2.s.pool.on("reconnectFailed", eventHandler(self2, "reconnectFailed"));
      relayEvents(self2.s.pool, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
      if (!self2.s.inTopology) {
        this.emit("topologyOpening", { topologyId: topologyId(self2) });
      }
      self2.emit("serverOpening", { topologyId: topologyId(self2), address: self2.name });
      self2.s.pool.connect();
    };
    Server.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    Server.prototype.getDescription = function() {
      var ismaster = this.ismaster || {};
      var description = {
        type: sdam.getTopologyType(this),
        address: this.name
      };
      if (ismaster.hosts)
        description.hosts = ismaster.hosts;
      if (ismaster.arbiters)
        description.arbiters = ismaster.arbiters;
      if (ismaster.passives)
        description.passives = ismaster.passives;
      if (ismaster.setName)
        description.setName = ismaster.setName;
      return description;
    };
    Server.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Server.prototype.unref = function() {
      this.s.pool.unref();
    };
    Server.prototype.isConnected = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isConnected();
    };
    Server.prototype.isDestroyed = function() {
      if (!this.s.pool)
        return false;
      return this.s.pool.isDestroyed();
    };
    function basicWriteValidations(self2) {
      if (!self2.s.pool)
        return new MongoError("server instance is not connected");
      if (self2.s.pool.isDestroyed())
        return new MongoError("server instance pool was destroyed");
    }
    function basicReadValidations(self2, options2) {
      basicWriteValidations(self2, options2);
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        throw new Error("readPreference must be an instance of ReadPreference");
      }
    }
    Server.prototype.command = function(ns, cmd, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicReadValidations(self2, options2);
      if (result)
        return callback(result);
      options2 = Object.assign({}, options2, { wireProtocolCommand: false });
      if (self2.s.logger.isDebug())
        self2.s.logger.debug(f("executing command [%s] against %s", JSON.stringify({
          ns,
          cmd,
          options: debugOptions(debugFields, options2)
        }), self2.name));
      if (disconnectHandler(self2, "command", ns, cmd, options2, callback))
        return;
      if (collationNotSupported(this, cmd)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      wireProtocol.command(self2, ns, cmd, options2, callback);
    };
    Server.prototype.query = function(ns, cmd, cursorState, options2, callback) {
      wireProtocol.query(this, ns, cmd, cursorState, options2, callback);
    };
    Server.prototype.getMore = function(ns, cursorState, batchSize, options2, callback) {
      wireProtocol.getMore(this, ns, cursorState, batchSize, options2, callback);
    };
    Server.prototype.killCursors = function(ns, cursorState, callback) {
      wireProtocol.killCursors(this, ns, cursorState, callback);
    };
    Server.prototype.insert = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "insert", ns, ops, options2, callback))
        return;
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.insert(self2, ns, ops, options2, callback);
    };
    Server.prototype.update = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "update", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.update(self2, ns, ops, options2, callback);
    };
    Server.prototype.remove = function(ns, ops, options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      var result = basicWriteValidations(self2, options2);
      if (result)
        return callback(result);
      if (disconnectHandler(self2, "remove", ns, ops, options2, callback))
        return;
      if (collationNotSupported(this, options2)) {
        return callback(new MongoError(`server ${this.name} does not support collation`));
      }
      ops = Array.isArray(ops) ? ops : [ops];
      return wireProtocol.remove(self2, ns, ops, options2, callback);
    };
    Server.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Server.prototype.equals = function(server) {
      if (typeof server === "string")
        return this.name.toLowerCase() === server.toLowerCase();
      if (server.name)
        return this.name.toLowerCase() === server.name.toLowerCase();
      return false;
    };
    Server.prototype.connections = function() {
      return this.s.pool.allConnections();
    };
    Server.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      callback(null, this);
    };
    var listeners = ["close", "error", "timeout", "parseError", "connect"];
    Server.prototype.destroy = function(options2, callback) {
      if (this._destroyed) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      var self2 = this;
      if (serverAccounting)
        delete servers[this.id];
      if (this.monitoringProcessId) {
        clearTimeout(this.monitoringProcessId);
      }
      if (!self2.s.pool || this._destroyed) {
        this._destroyed = true;
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      this._destroyed = true;
      if (options2.emitClose) {
        self2.emit("close", self2);
      }
      if (options2.emitDestroy) {
        self2.emit("destroy", self2);
      }
      listeners.forEach(function(event) {
        self2.s.pool.removeAllListeners(event);
      });
      if (self2.listeners("serverClosed").length > 0)
        self2.emit("serverClosed", { topologyId: topologyId(self2), address: self2.name });
      if (self2.listeners("topologyClosed").length > 0 && !self2.s.inTopology) {
        self2.emit("topologyClosed", { topologyId: topologyId(self2) });
      }
      if (self2.s.logger.isDebug()) {
        self2.s.logger.debug(f("destroy called on server %s", self2.name));
      }
      this.s.pool.destroy(options2.force, callback);
    };
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/core/topologies/replset_state.js
var require_replset_state = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset_state.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var diff = require_shared2().diff;
    var EventEmitter = __require("events").EventEmitter;
    var Logger = require_logger();
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var Buffer2 = require_safe_buffer().Buffer;
    var TopologyType = {
      Single: "Single",
      ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
      ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
      Sharded: "Sharded",
      Unknown: "Unknown"
    };
    var ServerType = {
      Standalone: "Standalone",
      Mongos: "Mongos",
      PossiblePrimary: "PossiblePrimary",
      RSPrimary: "RSPrimary",
      RSSecondary: "RSSecondary",
      RSArbiter: "RSArbiter",
      RSOther: "RSOther",
      RSGhost: "RSGhost",
      Unknown: "Unknown"
    };
    var ReplSetState = function(options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.topologyType = TopologyType.ReplicaSetNoPrimary;
      this.setName = options2.setName;
      this.set = {};
      this.id = options2.id;
      this.setName = options2.setName;
      this.logger = options2.logger || Logger("ReplSet", options2);
      this.index = 0;
      this.acceptableLatency = options2.acceptableLatency || 15;
      this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
      this.primary = null;
      this.secondaries = [];
      this.arbiters = [];
      this.passives = [];
      this.ghosts = [];
      this.unknownServers = [];
      this.set = {};
      this.maxElectionId = null;
      this.maxSetVersion = 0;
      this.replicasetDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.logicalSessionTimeoutMinutes = void 0;
    };
    inherits(ReplSetState, EventEmitter);
    ReplSetState.prototype.hasPrimaryAndSecondary = function() {
      return this.primary != null && this.secondaries.length > 0;
    };
    ReplSetState.prototype.hasPrimaryOrSecondary = function() {
      return this.hasPrimary() || this.hasSecondary();
    };
    ReplSetState.prototype.hasPrimary = function() {
      return this.primary != null;
    };
    ReplSetState.prototype.hasSecondary = function() {
      return this.secondaries.length > 0;
    };
    ReplSetState.prototype.get = function(host2) {
      var servers = this.allServers();
      for (var i = 0; i < servers.length; i++) {
        if (servers[i].name.toLowerCase() === host2.toLowerCase()) {
          return servers[i];
        }
      }
      return null;
    };
    ReplSetState.prototype.allServers = function(options2) {
      options2 = options2 || {};
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      if (!options2.ignoreArbiters)
        servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      return servers;
    };
    ReplSetState.prototype.destroy = function(options2, callback) {
      const serversToDestroy = this.secondaries.concat(this.arbiters).concat(this.passives).concat(this.ghosts);
      if (this.primary)
        serversToDestroy.push(this.primary);
      let serverCount = serversToDestroy.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        this.secondaries = [];
        this.arbiters = [];
        this.passives = [];
        this.ghosts = [];
        this.unknownServers = [];
        this.set = {};
        this.primary = null;
        emitTopologyDescriptionChanged(this);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      serversToDestroy.forEach((server) => server.destroy(options2, serverDestroyed));
    };
    ReplSetState.prototype.remove = function(server, options2) {
      options2 = options2 || {};
      var serverName = server.name.toLowerCase();
      var servers = this.primary ? [this.primary] : [];
      servers = servers.concat(this.secondaries);
      servers = servers.concat(this.arbiters);
      servers = servers.concat(this.passives);
      for (var i = 0; i < servers.length; i++) {
        if (!options2.force && servers[i].equals(server) && servers[i].isConnected && servers[i].isConnected()) {
          return;
        }
      }
      if (this.set[serverName]) {
        this.set[serverName].type = ServerType.Unknown;
        this.set[serverName].electionId = null;
        this.set[serverName].setName = null;
        this.set[serverName].setVersion = null;
      }
      var removeType = null;
      if (this.primary && this.primary.equals(server)) {
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        removeType = "primary";
      }
      removeType = removeFrom(server, this.secondaries) ? "secondary" : removeType;
      removeType = removeFrom(server, this.arbiters) ? "arbiter" : removeType;
      removeType = removeFrom(server, this.passives) ? "secondary" : removeType;
      removeFrom(server, this.ghosts);
      removeFrom(server, this.unknownServers);
      this.unknownServers.push(serverName);
      if (removeType) {
        this.emit("left", removeType, server);
      }
    };
    var isArbiter = (ismaster) => ismaster.arbiterOnly && ismaster.setName;
    ReplSetState.prototype.update = function(server) {
      var self2 = this;
      var ismaster = server.lastIsMaster();
      var serverName = server.name.toLowerCase();
      if (ismaster) {
        var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
        hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
        hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
        hosts = hosts.map(function(s3) {
          return s3.toLowerCase();
        });
        for (var i = 0; i < hosts.length; i++) {
          if (this.unknownServers.indexOf(hosts[i]) === -1 && (!this.set[hosts[i]] || this.set[hosts[i]].type === ServerType.Unknown)) {
            this.unknownServers.push(hosts[i].toLowerCase());
          }
          if (!this.set[hosts[i]]) {
            this.set[hosts[i]] = {
              type: ServerType.Unknown,
              electionId: null,
              setName: null,
              setVersion: null
            };
          }
        }
      }
      if (!ismaster && !inList(ismaster, server, this.unknownServers)) {
        self2.set[serverName] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.set[serverName].type = ServerType.Unknown;
        self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
        self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
        self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
        if (self2.unknownServers.indexOf(server.name) === -1) {
          self2.unknownServers.push(serverName);
        }
        return false;
      }
      if (ismaster.logicalSessionTimeoutMinutes !== void 0 && !isArbiter(ismaster)) {
        if (self2.logicalSessionTimeoutMinutes === void 0 || ismaster.logicalSessionTimeoutMinutes === null) {
          self2.logicalSessionTimeoutMinutes = ismaster.logicalSessionTimeoutMinutes;
        } else {
          self2.logicalSessionTimeoutMinutes = Math.min(self2.logicalSessionTimeoutMinutes, ismaster.logicalSessionTimeoutMinutes);
        }
      }
      if (ismaster && ismaster.msg === "isdbgrid") {
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        return false;
      }
      if (ismaster.isreplicaset) {
        self2.set[serverName] = {
          type: ServerType.RSGhost,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        if (this.primary && this.primary.name === serverName) {
          this.primary = null;
        }
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster.setName && ismaster.hidden || ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive) {
        self2.set[serverName] = {
          type: ServerType.RSOther,
          setVersion: null,
          electionId: null,
          setName: ismaster.setName
        };
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        return false;
      }
      if (ismaster && ismaster.ismaster && !ismaster.setName) {
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
        this.remove(server, { force: true });
        return false;
      }
      if (ismaster.me && ismaster.me.toLowerCase() !== serverName) {
        if (this.logger.isWarn()) {
          this.logger.warn(f("the seedlist server was removed due to its address %s not matching its ismaster.me address %s", server.name, ismaster.me));
        }
        delete this.set[serverName];
        removeFrom(server, self2.unknownServers);
        server.destroy({ force: true });
        if (this.primary && !this.primary.equals(server)) {
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        if (!this.primary && ismaster.primary) {
          this.set[ismaster.primary.toLowerCase()] = {
            type: ServerType.PossiblePrimary,
            setName: null,
            electionId: null,
            setVersion: null
          };
        }
        return false;
      }
      if (!this.primary && ismaster.ismaster && ismaster.setName) {
        var ismasterElectionId = server.lastIsMaster().electionId;
        if (this.setName && this.setName !== ismaster.setName) {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
          return new MongoError(f("setName from ismaster does not match provided connection setName [%s] != [%s]", ismaster.setName, this.setName));
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          var ismasterSetVersion = server.lastIsMaster().setVersion;
          if (result === 1) {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
            return false;
          } else if (result === 0 && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              this.topologyType = TopologyType.ReplicaSetNoPrimary;
              return false;
            }
          }
          this.maxSetVersion = ismasterSetVersion;
          this.maxElectionId = ismasterElectionId;
        }
        var normalizedHosts = ismaster.hosts.map(function(x) {
          return x.toLowerCase();
        });
        var locationIndex = normalizedHosts.indexOf(serverName);
        if (locationIndex !== -1) {
          self2.primary = server;
          self2.set[serverName] = {
            type: ServerType.RSPrimary,
            setVersion: ismaster.setVersion,
            electionId: ismaster.electionId,
            setName: ismaster.setName
          };
          this.topologyType = TopologyType.ReplicaSetWithPrimary;
          if (ismaster.setName)
            this.setName = ismaster.setName;
          removeFrom(server, self2.unknownServers);
          removeFrom(server, self2.secondaries);
          removeFrom(server, self2.passives);
          self2.emit("joined", "primary", server);
        } else {
          this.topologyType = TopologyType.ReplicaSetNoPrimary;
        }
        emitTopologyDescriptionChanged(self2);
        return true;
      } else if (ismaster.ismaster && ismaster.setName) {
        var currentElectionId = self2.set[self2.primary.name.toLowerCase()].electionId;
        var currentSetVersion = self2.set[self2.primary.name.toLowerCase()].setVersion;
        var currentSetName = self2.set[self2.primary.name.toLowerCase()].setName;
        ismasterElectionId = server.lastIsMaster().electionId;
        ismasterSetVersion = server.lastIsMaster().setVersion;
        var ismasterSetName = server.lastIsMaster().setName;
        if (this.primary.equals(server) && currentSetName === ismasterSetName) {
          return false;
        }
        if (currentSetName && currentSetName !== ismasterSetName) {
          if (!this.primary.equals(server)) {
            this.topologyType = TopologyType.ReplicaSetWithPrimary;
          } else {
            this.topologyType = TopologyType.ReplicaSetNoPrimary;
          }
          return false;
        }
        if (currentElectionId && ismasterElectionId) {
          result = compareObjectIds(currentElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion > ismasterSetVersion) {
            return false;
          }
        } else if (!currentElectionId && ismasterElectionId && ismasterSetVersion) {
          if (ismasterSetVersion < this.maxSetVersion) {
            return false;
          }
        }
        if (!this.maxElectionId && ismasterElectionId) {
          this.maxElectionId = ismasterElectionId;
        } else if (this.maxElectionId && ismasterElectionId) {
          result = compareObjectIds(this.maxElectionId, ismasterElectionId);
          if (result === 1) {
            return false;
          } else if (result === 0 && currentSetVersion && ismasterSetVersion) {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          } else {
            if (ismasterSetVersion < this.maxSetVersion) {
              return false;
            }
          }
          this.maxElectionId = ismasterElectionId;
          this.maxSetVersion = ismasterSetVersion;
        } else {
          this.maxSetVersion = ismasterSetVersion;
        }
        self2.set[self2.primary.name.toLowerCase()] = {
          type: ServerType.Unknown,
          setVersion: null,
          electionId: null,
          setName: null
        };
        self2.emit("left", "primary", this.primary);
        self2.primary.destroy({ force: true });
        self2.primary = server;
        self2.set[serverName] = {
          type: ServerType.RSPrimary,
          setVersion: ismaster.setVersion,
          electionId: ismaster.electionId,
          setName: ismaster.setName
        };
        this.topologyType = TopologyType.ReplicaSetWithPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        removeFrom(server, self2.secondaries);
        removeFrom(server, self2.passives);
        self2.emit("joined", "primary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (!this.primary && ismaster.primary) {
        self2.set[ismaster.primary.toLowerCase()] = {
          type: ServerType.PossiblePrimary,
          setVersion: null,
          electionId: null,
          setName: null
        };
      }
      if (ismaster.secondary && ismaster.setName && !inList(ismaster, server, this.secondaries) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.secondaries);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (isArbiter(ismaster) && !inList(ismaster, server, this.arbiters) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSArbiter, ismaster, server, this.arbiters);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        self2.emit("joined", "arbiter", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (ismaster.passive && ismaster.setName && !inList(ismaster, server, this.passives) && this.setName && this.setName === ismaster.setName) {
        addToList(self2, ServerType.RSSecondary, ismaster, server, this.passives);
        this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
        if (ismaster.setName)
          this.setName = ismaster.setName;
        removeFrom(server, self2.unknownServers);
        if (this.primary && this.primary.name.toLowerCase() === serverName) {
          server.destroy({ force: true });
          this.primary = null;
          self2.emit("left", "primary", server);
        }
        self2.emit("joined", "secondary", server);
        emitTopologyDescriptionChanged(self2);
        return true;
      }
      if (this.set[serverName] && this.set[serverName].type === ServerType.RSPrimary) {
        self2.emit("left", "primary", this.primary);
        this.primary.destroy({ force: true });
        this.primary = null;
        this.topologyType = TopologyType.ReplicaSetNoPrimary;
        return false;
      }
      this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
      return false;
    };
    ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
      var max = 0;
      for (var i = 0; i < this.secondaries.length; i++) {
        max = Math.max(max, this.secondaries[i].lastWriteDate);
      }
      if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary && this.hasPrimary()) {
        server.staleness = server.lastUpdateTime - server.lastWriteDate - (this.primary.lastUpdateTime - this.primary.lastWriteDate) + haInterval;
      } else if (server.ismaster.maxWireVersion >= 5 && server.ismaster.secondary) {
        server.staleness = max - server.lastWriteDate + haInterval;
      }
    };
    ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
      for (var i = 0; i < this.secondaries.length; i++) {
        this.updateServerMaxStaleness(this.secondaries[i], haInterval);
      }
    };
    ReplSetState.prototype.pickServer = function(readPreference) {
      readPreference = readPreference || ReadPreference.primary;
      if (readPreference.preference === "primary" && readPreference.maxStalenessSeconds != null) {
        return new MongoError("primary readPreference incompatible with maxStalenessSeconds");
      }
      var allservers = this.primary ? [this.primary] : [];
      allservers = allservers.concat(this.secondaries);
      if (readPreference.maxStalenessSeconds != null) {
        for (var i = 0; i < allservers.length; i++) {
          if (allservers[i].ismaster.maxWireVersion < 5) {
            return new MongoError("maxStalenessSeconds not supported by at least one of the replicaset members");
          }
        }
      }
      if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds == null) {
        return pickNearest(this, readPreference);
      } else if (readPreference.preference === "nearest" && readPreference.maxStalenessSeconds != null) {
        return pickNearestMaxStalenessSeconds(this, readPreference);
      }
      var secondaries = this.secondaries;
      if (readPreference.equals(ReadPreference.secondary) && secondaries.length === 0) {
        return new MongoError("no secondary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length === 0 && this.primary == null) {
        return new MongoError("no secondary or primary server available");
      }
      if (readPreference.equals(ReadPreference.primary) && this.primary == null) {
        return new MongoError("no primary server available");
      }
      if (readPreference.equals(ReadPreference.secondaryPreferred) || readPreference.equals(ReadPreference.secondary)) {
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          var server = pickNearest(this, readPreference);
          if (server) {
            return server;
          }
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
          if (server) {
            return server;
          }
        }
        if (readPreference.equals(ReadPreference.secondaryPreferred)) {
          return this.primary;
        }
        return null;
      }
      if (readPreference.equals(ReadPreference.primaryPreferred)) {
        server = null;
        if (this.primary) {
          return this.primary;
        }
        if (secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
          server = pickNearest(this, readPreference);
        } else if (secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
          server = pickNearestMaxStalenessSeconds(this, readPreference);
        }
        if (server)
          return server;
      }
      return this.primary;
    };
    var filterByTags = function(readPreference, servers) {
      if (readPreference.tags == null)
        return servers;
      var filteredServers = [];
      var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
      for (var j = 0; j < tagsArray.length; j++) {
        var tags = tagsArray[j];
        for (var i = 0; i < servers.length; i++) {
          var serverTag = servers[i].lastIsMaster().tags || {};
          var found = true;
          for (var name2 in tags) {
            if (serverTag[name2] !== tags[name2]) {
              found = false;
            }
          }
          if (found) {
            filteredServers.push(servers[i]);
          }
        }
      }
      return filteredServers;
    };
    function pickNearestMaxStalenessSeconds(self2, readPreference) {
      var servers = [];
      var maxStalenessMS = readPreference.maxStalenessSeconds * 1e3;
      if (maxStalenessMS < 90 * 1e3) {
        return new MongoError("maxStalenessSeconds must be set to at least 90 seconds");
      }
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (self2.primary && servers.length === 0 && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers = servers.filter(function(s3) {
        return s3.staleness <= maxStalenessMS;
      });
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function pickNearest(self2, readPreference) {
      var servers = [];
      if (self2.primary && readPreference.preference !== "secondary" && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      for (var i = 0; i < self2.secondaries.length; i++) {
        servers.push(self2.secondaries[i]);
      }
      if (servers.length === 0 && self2.primary && readPreference.preference !== "secondaryPreferred") {
        servers.push(self2.primary);
      }
      servers = filterByTags(readPreference, servers);
      servers.sort(function(a, b) {
        return a.lastIsMasterMS - b.lastIsMasterMS;
      });
      var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
      servers = servers.filter(function(s3) {
        return s3.lastIsMasterMS <= lowest + self2.acceptableLatency;
      });
      if (servers.length === 0) {
        return null;
      }
      self2.index = self2.index % servers.length;
      var server = servers[self2.index];
      self2.index = self2.index + 1;
      return server;
    }
    function inList(ismaster, server, list2) {
      for (var i = 0; i < list2.length; i++) {
        if (list2[i] && list2[i].name && list2[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      return false;
    }
    function addToList(self2, type, ismaster, server, list2) {
      var serverName = server.name.toLowerCase();
      self2.set[serverName].type = type;
      self2.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
      self2.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
      self2.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
      list2.push(server);
    }
    function compareObjectIds(id1, id2) {
      var a = Buffer2.from(id1.toHexString(), "hex");
      var b = Buffer2.from(id2.toHexString(), "hex");
      if (a === b) {
        return 0;
      }
      if (typeof Buffer2.compare === "function") {
        return Buffer2.compare(a, b);
      }
      var x = a.length;
      var y2 = b.length;
      var len = Math.min(x, y2);
      for (var i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          break;
        }
      }
      if (i !== len) {
        x = a[i];
        y2 = b[i];
      }
      return x < y2 ? -1 : y2 < x ? 1 : 0;
    }
    function removeFrom(server, list2) {
      for (var i = 0; i < list2.length; i++) {
        if (list2[i].equals && list2[i].equals(server)) {
          list2.splice(i, 1);
          return true;
        } else if (typeof list2[i] === "string" && list2[i].toLowerCase() === server.name.toLowerCase()) {
          list2.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        var setName = self2.setName;
        if (self2.hasPrimaryAndSecondary()) {
          topology = "ReplicaSetWithPrimary";
        } else if (!self2.hasPrimary() && self2.hasSecondary()) {
          topology = "ReplicaSetNoPrimary";
        }
        var description = {
          topologyType: topology,
          setName,
          servers: []
        };
        if (self2.hasPrimary()) {
          var desc = self2.primary.getDescription();
          desc.type = "RSPrimary";
          description.servers.push(desc);
        }
        description.servers = description.servers.concat(self2.secondaries.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        description.servers = description.servers.concat(self2.arbiters.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSArbiter";
          return description2;
        }));
        description.servers = description.servers.concat(self2.passives.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "RSSecondary";
          return description2;
        }));
        var diffResult = diff(self2.replicasetDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.replicasetDescription,
          newDescription: description,
          diff: diffResult
        };
        self2.emit("topologyDescriptionChanged", result);
        self2.replicasetDescription = description;
      }
    }
    module2.exports = ReplSetState;
  }
});

// node_modules/mongodb/lib/core/topologies/replset.js
var require_replset = __commonJS({
  "node_modules/mongodb/lib/core/topologies/replset.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var ReadPreference = require_read_preference();
    var CoreCursor = require_cursor().CoreCursor;
    var retrieveBSON = require_utils3().retrieveBSON;
    var Logger = require_logger();
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var ReplSetState = require_replset_state();
    var Timeout = require_shared2().Timeout;
    var Interval = require_shared2().Interval;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var ReplSet = function(seedlist, options2) {
      var self2 = this;
      options2 = options2 || {};
      if (!Array.isArray(seedlist))
        throw new MongoError("seedlist must be an array");
      if (seedlist.length === 0)
        throw new MongoError("seedlist must contain at least one entry");
      seedlist.forEach(function(e) {
        if (typeof e.host !== "string" || typeof e.port !== "number")
          throw new MongoError("seedlist entry must contain a host and port");
      });
      EventEmitter.call(this);
      this.id = id++;
      var localThresholdMS = options2.localThresholdMS || 15;
      if (options2.acceptableLatency)
        localThresholdMS = options2.acceptableLatency;
      var logger = Logger("ReplSet", options2);
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger,
        seedlist,
        replicaSetState: new ReplSetState({
          id: this.id,
          setName: options2.setName,
          acceptableLatency: localThresholdMS,
          heartbeatFrequencyMS: options2.haInterval ? options2.haInterval : 1e4,
          logger
        }),
        connectingServers: [],
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        minHeartbeatFrequencyMS: 500,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false
      };
      this.s.replicaSetState.on("topologyDescriptionChanged", function(r) {
        self2.emit("topologyDescriptionChanged", r);
      });
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      var types2 = ["joined", "left"];
      types2.forEach(function(x) {
        self2.s.replicaSetState.on(x, function(t, s3) {
          self2.emit(x, t, s3);
        });
      });
      this.initialConnectState = {
        connect: false,
        fullsetup: false,
        all: false
      };
      this.state = DISCONNECTED;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.intervalIds = [];
      this.clusterTime = null;
    };
    inherits(ReplSet, EventEmitter);
    Object.assign(ReplSet.prototype, SessionMixins);
    Object.defineProperty(ReplSet.prototype, "type", {
      enumerable: true,
      get: function() {
        return "replset";
      }
    });
    Object.defineProperty(ReplSet.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(ReplSet.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.replicaSetState.logicalSessionTimeoutMinutes || null;
      }
    });
    function rexecuteOperations(self2) {
      if (self2.s.replicaSetState.hasPrimaryAndSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute();
      } else if (self2.s.replicaSetState.hasPrimary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executePrimary: true });
      } else if (self2.s.replicaSetState.hasSecondary() && self2.s.disconnectHandler) {
        self2.s.disconnectHandler.execute({ executeSecondary: true });
      }
    }
    function connectNewServers(self2, servers, callback) {
      if (servers.length === 0) {
        return callback();
      }
      var count = servers.length;
      var error3 = null;
      function done() {
        count = count - 1;
        if (count === 0) {
          callback(error3);
        }
      }
      var _handleEvent = function(self3, event) {
        return function(err) {
          var _self = this;
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            this.destroy({ force: true });
            return done();
          }
          if (event === "connect") {
            var result = self3.s.replicaSetState.update(_self);
            if (result) {
              if (_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
                self3.ismaster = _self.lastIsMaster();
              }
              for (let i2 = 0; i2 < handlers.length; i2++) {
                _self.removeAllListeners(handlers[i2]);
              }
              _self.on("error", handleEvent(self3, "error"));
              _self.on("close", handleEvent(self3, "close"));
              _self.on("timeout", handleEvent(self3, "timeout"));
              _self.on("parseError", handleEvent(self3, "parseError"));
              monitorServer(_self.lastIsMaster().me, self3, {});
              rexecuteOperations(self3);
            } else {
              _self.destroy({ force: true });
            }
          } else if (event === "error") {
            error3 = err;
          }
          rexecuteOperations(self3);
          done();
        };
      };
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          const existingServerIdx = self2.s.connectingServers.findIndex((s3) => s3.name === _server);
          if (existingServerIdx >= 0) {
            const connectingServer = self2.s.connectingServers[existingServerIdx];
            connectingServer.destroy({ force: true });
            self2.s.connectingServers.splice(existingServerIdx, 1);
            return done();
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.split(":")[0],
            port: parseInt(_server.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.s.connectingServers.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < servers.length; i++) {
        execute(servers[i], i);
      }
    }
    var pingServer = function(self2, server, cb) {
      var start = new Date().getTime();
      emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: server.name });
      server.command("admin.$cmd", {
        ismaster: true
      }, {
        monitoring: true,
        socketTimeout: self2.s.options.connectionTimeout || 2e3
      }, function(err, r) {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          server.destroy({ force: true });
          return cb(err, r);
        }
        var latencyMS = new Date().getTime() - start;
        server.lastUpdateTime = now();
        if (err) {
          emitSDAMEvent(self2, "serverHeartbeatFailed", {
            durationMS: latencyMS,
            failure: err,
            connectionId: server.name
          });
          self2.s.replicaSetState.remove(server);
        } else {
          server.ismaster = r.result;
          if (server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
            server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
          }
          if (server.lastIsMasterMS === -1) {
            server.lastIsMasterMS = latencyMS;
          } else if (server.lastIsMasterMS) {
            server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
          }
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
            durationMS: latencyMS,
            reply: r.result,
            connectionId: server.name
          });
        }
        self2.s.replicaSetState.updateServerMaxStaleness(server, self2.s.haInterval);
        cb(err, r);
      });
    };
    var monitorServer = function(host2, self2, options2) {
      if (!options2.haInterval) {
        for (var i = 0; i < self2.intervalIds.length; i++) {
          if (self2.intervalIds[i].__host === host2) {
            return;
          }
        }
      }
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      var intervalId = new _process(function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          intervalId.stop();
          return;
        }
        var _server = self2.s.replicaSetState.get(host2);
        if (_server) {
          return pingServer(self2, _server, function(err) {
            if (err) {
              return;
            }
            if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
              intervalId.stop();
              return;
            }
            self2.intervalIds = self2.intervalIds.filter(function(intervalId2) {
              return intervalId2.isRunning();
            });
            if (_process === Timeout) {
              if (self2.state === CONNECTING && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTED);
                process.nextTick(function() {
                  self2.emit("connect", self2);
                });
                topologyMonitor(self2, {});
              }
            } else {
              if (self2.state === DISCONNECTED && (self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed || self2.s.replicaSetState.hasPrimary())) {
                stateTransition(self2, CONNECTING);
                rexecuteOperations(self2);
                process.nextTick(function() {
                  self2.emit("reconnect", self2);
                });
              }
            }
            if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
              self2.initialConnectState.fullsetup = true;
              self2.initialConnectState.all = true;
              process.nextTick(function() {
                self2.emit("fullsetup", self2);
                self2.emit("all", self2);
              });
            }
          });
        }
      }, _haInterval);
      intervalId.start();
      intervalId.__host = host2;
      self2.intervalIds.push(intervalId);
    };
    function topologyMonitor(self2, options2) {
      if (self2.state === DESTROYED || self2.state === UNREFERENCED)
        return;
      options2 = options2 || {};
      var servers = Object.keys(self2.s.replicaSetState.set);
      var _process = options2.haInterval ? Timeout : Interval;
      var _haInterval = options2.haInterval ? options2.haInterval : self2.s.haInterval;
      if (_process === Timeout) {
        return connectNewServers(self2, self2.s.replicaSetState.unknownServers, function(err) {
          if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
            return;
          }
          if (!self2.s.replicaSetState.hasPrimary() && !self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no primary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          } else if (!self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
            if (err) {
              return self2.emit("error", err);
            }
            self2.emit("error", new MongoError("no secondary found in replicaset or invalid replica set name"));
            return self2.destroy({ force: true });
          }
          for (var i2 = 0; i2 < servers.length; i2++) {
            monitorServer(servers[i2], self2, options2);
          }
        });
      } else {
        for (var i = 0; i < servers.length; i++) {
          monitorServer(servers[i], self2, options2);
        }
      }
      function executeReconnect(self3) {
        return function() {
          if (self3.state === DESTROYED || self3.state === UNREFERENCED) {
            return;
          }
          connectNewServers(self3, self3.s.replicaSetState.unknownServers, function() {
            var monitoringFrequencey = self3.s.replicaSetState.hasPrimary() ? _haInterval : self3.s.minHeartbeatFrequencyMS;
            self3.intervalIds.push(new Timeout(executeReconnect(self3), monitoringFrequencey).start());
          });
        };
      }
      var intervalTime = !self2.s.replicaSetState.hasPrimary() ? self2.s.minHeartbeatFrequencyMS : _haInterval;
      self2.intervalIds.push(new Timeout(executeReconnect(self2), intervalTime).start());
    }
    function addServerToList(list2, server) {
      for (var i = 0; i < list2.length; i++) {
        if (list2[i].name.toLowerCase() === server.name.toLowerCase())
          return true;
      }
      list2.push(server);
    }
    function handleEvent(self2, event) {
      return function() {
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        self2.s.replicaSetState.remove(this);
        if (self2.state === DESTROYED || self2.state === UNREFERENCED)
          return;
        if (!self2.s.replicaSetState.hasPrimary() && !self2.s.replicaSetState.hasSecondary() && self2.s.options.secondaryOnlyConnectionAllowed) {
          stateTransition(self2, DISCONNECTED);
        } else if (!self2.s.replicaSetState.hasPrimary()) {
          stateTransition(self2, DISCONNECTED);
        }
        addServerToList(self2.s.connectingServers, this);
      };
    }
    function shouldTriggerConnect(self2) {
      const isConnecting = self2.state === CONNECTING;
      const hasPrimary = self2.s.replicaSetState.hasPrimary();
      const hasSecondary = self2.s.replicaSetState.hasSecondary();
      const secondaryOnlyConnectionAllowed = self2.s.options.secondaryOnlyConnectionAllowed;
      const readPreferenceSecondary = self2.s.connectOptions.readPreference && self2.s.connectOptions.readPreference.equals(ReadPreference.secondary);
      return isConnecting && (readPreferenceSecondary && hasSecondary || !readPreferenceSecondary && hasPrimary) || hasSecondary && secondaryOnlyConnectionAllowed;
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.s.logger.isDebug()) {
          self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s", event, this.name, self2.id));
        }
        if (self2.state === DESTROYED || self2.state === UNREFERENCED) {
          return this.destroy({ force: true });
        }
        if (event === "connect") {
          var result = self2.s.replicaSetState.update(_this);
          if (result === true) {
            if (_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
              self2.ismaster = _this.lastIsMaster();
            }
            if (self2.s.logger.isDebug()) {
              self2.s.logger.debug(f("handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]", event, _this.name, self2.id, JSON.stringify(self2.s.replicaSetState.set)));
            }
            for (let i2 = 0; i2 < handlers.length; i2++) {
              _this.removeAllListeners(handlers[i2]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            if (shouldTriggerConnect(self2)) {
              stateTransition(self2, CONNECTED);
              self2.initialConnectState.connect = true;
              process.nextTick(function() {
                self2.emit("connect", self2);
              });
              topologyMonitor(self2, {});
            }
          } else if (result instanceof MongoError) {
            _this.destroy({ force: true });
            self2.destroy({ force: true });
            return self2.emit("error", result);
          } else {
            _this.destroy({ force: true });
          }
        } else {
          self2.emit("failed", this);
          addServerToList(self2.s.connectingServers, this);
          self2.s.replicaSetState.remove(this);
        }
        if (self2.initialConnectState.connect && !self2.initialConnectState.fullsetup && self2.s.replicaSetState.hasPrimaryAndSecondary()) {
          self2.initialConnectState.fullsetup = true;
          self2.initialConnectState.all = true;
          process.nextTick(function() {
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          });
        }
        for (var i = 0; i < self2.s.connectingServers.length; i++) {
          if (self2.s.connectingServers[i].equals(this)) {
            self2.s.connectingServers.splice(i, 1);
          }
        }
        if (self2.s.connectingServers.length === 0 && self2.state === CONNECTING) {
          topologyMonitor(self2, { haInterval: 1 });
        }
      };
    }
    function connectServers(self2, servers) {
      self2.s.connectingServers = self2.s.connectingServers.concat(servers);
      var timeoutInterval = 0;
      function connect2(server, timeoutInterval2) {
        setTimeout(function() {
          if (self2.s.replicaSetState.update(server)) {
            if (server.lastIsMaster() && server.lastIsMaster().ismaster) {
              self2.ismaster = server.lastIsMaster();
            }
          }
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          server.on("serverOpening", (e) => self2.emit("serverOpening", e));
          server.on("serverDescriptionChanged", (e) => self2.emit("serverDescriptionChanged", e));
          server.on("serverClosed", (e) => self2.emit("serverClosed", e));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      while (servers.length > 0) {
        connect2(servers.shift(), timeoutInterval++);
      }
    }
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    ReplSet.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        return new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
      });
      if (this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
        return self2.emit("error", new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS", this.s.options.haInterval, this.s.options.socketTimeout)));
      }
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectServers(self2, servers);
    };
    ReplSet.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    ReplSet.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      let destroyCount = this.s.connectingServers.length + 1;
      const serverDestroyed = () => {
        destroyCount--;
        if (destroyCount > 0) {
          return;
        }
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (this.state === DESTROYED) {
        if (typeof callback === "function")
          callback(null, null);
        return;
      }
      stateTransition(this, DESTROYED);
      if (this.haTimeoutId)
        clearTimeout(this.haTimeoutId);
      for (var i = 0; i < this.intervalIds.length; i++) {
        this.intervalIds[i].stop();
      }
      this.intervalIds = [];
      if (destroyCount === 0) {
        serverDestroyed();
        return;
      }
      this.s.replicaSetState.destroy(options2, serverDestroyed);
      this.s.connectingServers.forEach(function(x) {
        x.destroy(options2, serverDestroyed);
      });
    };
    ReplSet.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      this.s.replicaSetState.allServers().forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    ReplSet.prototype.lastIsMaster = function() {
      if (this.s.options.secondaryOnlyConnectionAllowed && !this.s.replicaSetState.hasPrimary() && this.s.replicaSetState.hasSecondary()) {
        return this.s.replicaSetState.secondaries[0].lastIsMaster();
      }
      return this.s.replicaSetState.primary ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
    };
    ReplSet.prototype.connections = function() {
      var servers = this.s.replicaSetState.allServers();
      var connections = [];
      for (var i = 0; i < servers.length; i++) {
        connections = connections.concat(servers[i].connections());
      }
      return connections;
    };
    ReplSet.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondary)) {
        return this.s.replicaSetState.hasSecondary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primary)) {
        return this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.primaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (options2.readPreference && options2.readPreference.equals(ReadPreference.secondaryPreferred)) {
        return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
      }
      if (this.s.options.secondaryOnlyConnectionAllowed && this.s.replicaSetState.hasSecondary()) {
        return true;
      }
      return this.s.replicaSetState.hasPrimary();
    };
    ReplSet.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    var SERVER_SELECTION_TIMEOUT_MS = 1e4;
    var SERVER_SELECTION_INTERVAL_MS = 1e3;
    ReplSet.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector;
      options2 = options2 || {};
      let readPreference;
      if (selector instanceof ReadPreference) {
        readPreference = selector;
      } else {
        readPreference = options2.readPreference || ReadPreference.primary;
      }
      let lastError;
      const start = now();
      const _selectServer = () => {
        if (calculateDurationInMs(start) >= SERVER_SELECTION_TIMEOUT_MS) {
          if (lastError != null) {
            callback(lastError, null);
          } else {
            callback(new MongoError("Server selection timed out"));
          }
          return;
        }
        const server = this.s.replicaSetState.pickServer(readPreference);
        if (server == null) {
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (!(server instanceof Server)) {
          lastError = server;
          setTimeout(_selectServer, SERVER_SELECTION_INTERVAL_MS);
          return;
        }
        if (this.s.debug)
          this.emit("pickedServer", options2.readPreference, server);
        callback(null, server);
      };
      _selectServer();
    };
    ReplSet.prototype.getServers = function() {
      return this.s.replicaSetState.allServers();
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      if (self2.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      if (!self2.s.replicaSetState.hasPrimary()) {
        if (self2.s.disconnectHandler) {
          return self2.s.disconnectHandler.add(op, ns, ops, options2, callback);
        } else if (!willRetryWrite) {
          return callback(new MongoError("no primary server found"));
        }
      }
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          err = getMMAPError(err);
          return callback(err);
        }
        if (willRetryWrite) {
          const newArgs = Object.assign({}, args, { retrying: true });
          return executeWriteOperation(newArgs, options2, callback);
        }
        if (self2.s.replicaSetState.primary) {
          self2.s.replicaSetState.primary.destroy();
          self2.s.replicaSetState.remove(self2.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      self2.s.replicaSetState.primary[op](ns, ops, options2, handler);
    }
    ReplSet.prototype.insert = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options2, callback);
    };
    ReplSet.prototype.update = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "update", ns, ops }, options2, callback);
    };
    ReplSet.prototype.remove = function(ns, ops, options2, callback) {
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    ReplSet.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED)
        return callback(new MongoError(f("topology was destroyed")));
      var self2 = this;
      var readPreference = options2.readPreference ? options2.readPreference : ReadPreference.primary;
      if (readPreference.preference === "primary" && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference === "secondary" && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      } else if (readPreference.preference !== "primary" && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      var server = this.s.replicaSetState.pickServer(readPreference);
      if (!(server instanceof Server))
        return callback(server);
      if (self2.s.debug)
        self2.emit("pickedServer", ReadPreference.primary, server);
      if (server == null) {
        return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
      }
      const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, options2, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        if (this.s.replicaSetState.primary) {
          this.s.replicaSetState.primary.destroy();
          this.s.replicaSetState.remove(this.s.replicaSetState.primary, { force: true });
        }
        return callback(err);
      };
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, options2, cb);
    };
    ReplSet.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/core/topologies/mongos.js
var require_mongos = __commonJS({
  "node_modules/mongodb/lib/core/topologies/mongos.js"(exports2, module2) {
    init_shims();
    "use strict";
    var inherits = __require("util").inherits;
    var f = __require("util").format;
    var EventEmitter = __require("events").EventEmitter;
    var CoreCursor = require_cursor().CoreCursor;
    var Logger = require_logger();
    var retrieveBSON = require_utils3().retrieveBSON;
    var MongoError = require_error().MongoError;
    var Server = require_server();
    var diff = require_shared2().diff;
    var cloneOptions = require_shared2().cloneOptions;
    var SessionMixins = require_shared2().SessionMixins;
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = retrieveBSON();
    var getMMAPError = require_shared2().getMMAPError;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var legacyIsRetryableWriteError = require_shared2().legacyIsRetryableWriteError;
    var DISCONNECTED = "disconnected";
    var CONNECTING = "connecting";
    var CONNECTED = "connected";
    var UNREFERENCED = "unreferenced";
    var DESTROYING = "destroying";
    var DESTROYED = "destroyed";
    function stateTransition(self2, newState) {
      var legalTransitions = {
        disconnected: [CONNECTING, DESTROYING, DESTROYED, DISCONNECTED],
        connecting: [CONNECTING, DESTROYING, DESTROYED, CONNECTED, DISCONNECTED],
        connected: [CONNECTED, DISCONNECTED, DESTROYING, DESTROYED, UNREFERENCED],
        unreferenced: [UNREFERENCED, DESTROYING, DESTROYED],
        destroyed: [DESTROYED]
      };
      var legalStates = legalTransitions[self2.state];
      if (legalStates && legalStates.indexOf(newState) !== -1) {
        self2.state = newState;
      } else {
        self2.s.logger.error(f("Mongos with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]", self2.id, self2.state, newState, legalStates));
      }
    }
    var id = 1;
    var handlers = ["connect", "close", "error", "timeout", "parseError"];
    var Mongos = function(seedlist, options2) {
      options2 = options2 || {};
      this.id = id++;
      if (Array.isArray(seedlist)) {
        seedlist = seedlist.reduce((seeds, seed) => {
          if (seeds.find((s3) => s3.host === seed.host && s3.port === seed.port)) {
            return seeds;
          }
          seeds.push(seed);
          return seeds;
        }, []);
      }
      this.s = {
        options: Object.assign({ metadata: makeClientMetadata(options2) }, options2),
        bson: options2.bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]),
        Cursor: options2.cursorFactory || CoreCursor,
        logger: Logger("Mongos", options2),
        seedlist,
        haInterval: options2.haInterval ? options2.haInterval : 1e4,
        disconnectHandler: options2.disconnectHandler,
        index: 0,
        connectOptions: {},
        debug: typeof options2.debug === "boolean" ? options2.debug : false,
        localThresholdMS: options2.localThresholdMS || 15
      };
      if (this.s.logger.isWarn() && this.s.options.socketTimeout !== 0 && this.s.options.socketTimeout < this.s.haInterval) {
        this.s.logger.warn(f("warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts", this.s.options.socketTimeout, this.s.haInterval));
      }
      this.state = DISCONNECTED;
      this.connectingProxies = [];
      this.connectedProxies = [];
      this.disconnectedProxies = [];
      this.index = 0;
      this.haTimeoutId = null;
      this.ismaster = null;
      this.topologyDescription = {
        topologyType: "Unknown",
        servers: []
      };
      this.clusterTime = null;
      EventEmitter.call(this);
    };
    inherits(Mongos, EventEmitter);
    Object.assign(Mongos.prototype, SessionMixins);
    Object.defineProperty(Mongos.prototype, "type", {
      enumerable: true,
      get: function() {
        return "mongos";
      }
    });
    Object.defineProperty(Mongos.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return BSON2.native ? "c++" : "js";
      }
    });
    Object.defineProperty(Mongos.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        if (!this.ismaster)
          return null;
        return this.ismaster.logicalSessionTimeoutMinutes || null;
      }
    });
    function emitSDAMEvent(self2, event, description) {
      if (self2.listeners(event).length > 0) {
        self2.emit(event, description);
      }
    }
    var SERVER_EVENTS = ["serverDescriptionChanged", "error", "close", "timeout", "parseError"];
    function destroyServer(server, options2, callback) {
      options2 = options2 || {};
      SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, callback);
    }
    Mongos.prototype.connect = function(options2) {
      var self2 = this;
      this.s.connectOptions = options2 || {};
      stateTransition(this, CONNECTING);
      var servers = this.s.seedlist.map(function(x) {
        const server = new Server(Object.assign({}, self2.s.options, x, options2, {
          reconnect: false,
          monitoring: false,
          parent: self2
        }));
        relayEvents(server, self2, ["serverDescriptionChanged"]);
        return server;
      });
      emitSDAMEvent(this, "topologyOpening", { topologyId: this.id });
      connectProxies(self2, servers);
    };
    Mongos.prototype.auth = function(credentials, callback) {
      if (typeof callback === "function")
        callback(null, null);
    };
    function handleEvent(self2) {
      return function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING) {
          return;
        }
        moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, this);
        emitTopologyDescriptionChanged(self2);
        self2.emit("left", "mongos", this);
        self2.emit("serverClosed", {
          topologyId: self2.id,
          address: this.name
        });
      };
    }
    function handleInitialConnectEvent(self2, event) {
      return function() {
        var _this = this;
        if (self2.state === DESTROYED) {
          emitTopologyDescriptionChanged(self2);
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          return this.destroy();
        }
        if (event === "connect") {
          self2.ismaster = _this.lastIsMaster();
          if (self2.ismaster.msg === "isdbgrid") {
            for (let i = 0; i < self2.connectedProxies.length; i++) {
              if (self2.connectedProxies[i].name === _this.name) {
                moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, _this);
                emitTopologyDescriptionChanged(self2);
                _this.destroy();
                return self2.emit("failed", _this);
              }
            }
            for (let i = 0; i < handlers.length; i++) {
              _this.removeAllListeners(handlers[i]);
            }
            _this.on("error", handleEvent(self2, "error"));
            _this.on("close", handleEvent(self2, "close"));
            _this.on("timeout", handleEvent(self2, "timeout"));
            _this.on("parseError", handleEvent(self2, "parseError"));
            moveServerFrom(self2.connectingProxies, self2.connectedProxies, _this);
            self2.emit("joined", "mongos", _this);
          } else {
            if (self2.s.logger.isWarn()) {
              var message = "expected mongos proxy, but found replicaset member mongod for server %s";
              if (!self2.ismaster.hosts) {
                message = "expected mongos proxy, but found standalone mongod for server %s";
              }
              self2.s.logger.warn(f(message, _this.name));
            }
            _this.destroy(true);
            removeProxyFrom(self2.connectingProxies, _this);
            self2.emit("left", "server", _this);
            self2.emit("failed", _this);
          }
        } else {
          moveServerFrom(self2.connectingProxies, self2.disconnectedProxies, this);
          self2.emit("left", "mongos", this);
          self2.emit("failed", this);
        }
        emitTopologyDescriptionChanged(self2);
        if (self2.connectingProxies.length === 0) {
          if (self2.connectedProxies.length > 0 && self2.state === CONNECTING) {
            stateTransition(self2, CONNECTED);
            self2.emit("connect", self2);
            self2.emit("fullsetup", self2);
            self2.emit("all", self2);
          } else if (self2.disconnectedProxies.length === 0) {
            if (self2.s.logger.isWarn()) {
              self2.s.logger.warn(f("no mongos proxies found in seed list, did you mean to connect to a replicaset"));
            }
            return self2.emit("error", new MongoError("no mongos proxies found in seed list"));
          }
          topologyMonitor(self2, { firstConnect: true });
        }
      };
    }
    function connectProxies(self2, servers) {
      self2.connectingProxies = self2.connectingProxies.concat(servers);
      var timeoutInterval = 0;
      function connect2(server, timeoutInterval2) {
        setTimeout(function() {
          self2.emit("serverOpening", {
            topologyId: self2.id,
            address: server.name
          });
          emitTopologyDescriptionChanged(self2);
          server.once("close", handleInitialConnectEvent(self2, "close"));
          server.once("timeout", handleInitialConnectEvent(self2, "timeout"));
          server.once("parseError", handleInitialConnectEvent(self2, "parseError"));
          server.once("error", handleInitialConnectEvent(self2, "error"));
          server.once("connect", handleInitialConnectEvent(self2, "connect"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          server.connect(self2.s.connectOptions);
        }, timeoutInterval2);
      }
      servers.forEach((server) => connect2(server, timeoutInterval++));
    }
    function pickProxy(self2, session) {
      const transaction = session && session.transaction;
      if (transaction && transaction.server) {
        if (transaction.server.isConnected()) {
          return transaction.server;
        } else {
          transaction.unpinServer();
        }
      }
      var connectedProxies = self2.connectedProxies.slice(0);
      var lowerBoundLatency = Number.MAX_VALUE;
      for (var i = 0; i < connectedProxies.length; i++) {
        if (connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
          lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
        }
      }
      connectedProxies = connectedProxies.filter(function(server) {
        if (server.lastIsMasterMS <= lowerBoundLatency + self2.s.localThresholdMS && server.isConnected()) {
          return true;
        }
      });
      let proxy;
      if (connectedProxies.length === 0) {
        proxy = self2.connectedProxies[0];
      } else {
        proxy = connectedProxies[self2.index % connectedProxies.length];
        self2.index = (self2.index + 1) % connectedProxies.length;
      }
      if (transaction && transaction.isActive && proxy && proxy.isConnected()) {
        transaction.pinServer(proxy);
      }
      return proxy;
    }
    function moveServerFrom(from, to, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
      for (i = 0; i < to.length; i++) {
        if (to[i].name === proxy.name) {
          to.splice(i, 1);
        }
      }
      to.push(proxy);
    }
    function removeProxyFrom(from, proxy) {
      for (var i = 0; i < from.length; i++) {
        if (from[i].name === proxy.name) {
          from.splice(i, 1);
        }
      }
    }
    function reconnectProxies(self2, proxies, callback) {
      var count = proxies.length;
      var _handleEvent = function(self3, event) {
        return function() {
          var _self = this;
          count = count - 1;
          if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            return this.destroy();
          }
          if (event === "connect") {
            if (self3.state === DESTROYED || self3.state === DESTROYING || self3.state === UNREFERENCED) {
              moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
              return _self.destroy();
            }
            for (var i2 = 0; i2 < handlers.length; i2++) {
              _self.removeAllListeners(handlers[i2]);
            }
            _self.on("error", handleEvent(self3, "error"));
            _self.on("close", handleEvent(self3, "close"));
            _self.on("timeout", handleEvent(self3, "timeout"));
            _self.on("parseError", handleEvent(self3, "parseError"));
            moveServerFrom(self3.connectingProxies, self3.connectedProxies, _self);
            emitTopologyDescriptionChanged(self3);
            self3.emit("joined", "mongos", _self);
          } else {
            moveServerFrom(self3.connectingProxies, self3.disconnectedProxies, _self);
            this.destroy();
          }
          if (count === 0) {
            callback();
          }
        };
      };
      if (count === 0) {
        return callback();
      }
      function execute(_server, i2) {
        setTimeout(function() {
          if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
            return;
          }
          var server = new Server(Object.assign({}, self2.s.options, {
            host: _server.name.split(":")[0],
            port: parseInt(_server.name.split(":")[1], 10),
            reconnect: false,
            monitoring: false,
            parent: self2
          }));
          destroyServer(_server, { force: true });
          removeProxyFrom(self2.disconnectedProxies, _server);
          relayEvents(server, self2, ["serverDescriptionChanged"]);
          self2.emit("serverOpening", {
            topologyId: server.s.topologyId !== -1 ? server.s.topologyId : self2.id,
            address: server.name
          });
          server.once("connect", _handleEvent(self2, "connect"));
          server.once("close", _handleEvent(self2, "close"));
          server.once("timeout", _handleEvent(self2, "timeout"));
          server.once("error", _handleEvent(self2, "error"));
          server.once("parseError", _handleEvent(self2, "parseError"));
          relayEvents(server, self2, ["commandStarted", "commandSucceeded", "commandFailed"]);
          self2.connectingProxies.push(server);
          server.connect(self2.s.connectOptions);
        }, i2);
      }
      for (var i = 0; i < proxies.length; i++) {
        execute(proxies[i], i);
      }
    }
    function topologyMonitor(self2, options2) {
      options2 = options2 || {};
      if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
        return;
      }
      self2.haTimeoutId = setTimeout(function() {
        if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
          return;
        }
        if (self2.isConnected() && self2.s.disconnectHandler) {
          self2.s.disconnectHandler.execute();
        }
        var proxies = self2.connectedProxies.slice(0);
        var count = proxies.length;
        function pingServer(_self, _server, cb) {
          var start = new Date().getTime();
          emitSDAMEvent(self2, "serverHeartbeatStarted", { connectionId: _server.name });
          _server.command("admin.$cmd", {
            ismaster: true
          }, {
            monitoring: true,
            socketTimeout: self2.s.options.connectionTimeout || 2e3
          }, function(err, r) {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
              _server.destroy();
              return cb(err, r);
            }
            var latencyMS = new Date().getTime() - start;
            if (err) {
              emitSDAMEvent(self2, "serverHeartbeatFailed", {
                durationMS: latencyMS,
                failure: err,
                connectionId: _server.name
              });
              moveServerFrom(self2.connectedProxies, self2.disconnectedProxies, _server);
            } else {
              _server.ismaster = r.result;
              _server.lastIsMasterMS = latencyMS;
              emitSDAMEvent(self2, "serverHeartbeatSucceeded", {
                durationMS: latencyMS,
                reply: r.result,
                connectionId: _server.name
              });
            }
            cb(err, r);
          });
        }
        if (proxies.length === 0) {
          if (self2.listeners("close").length > 0 && self2.state === CONNECTING) {
            self2.emit("error", new MongoError("no mongos proxy available"));
          } else {
            self2.emit("close", self2);
          }
          return reconnectProxies(self2, self2.disconnectedProxies, function() {
            if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
              return;
            }
            if (self2.state === CONNECTING && options2.firstConnect) {
              self2.emit("connect", self2);
              self2.emit("fullsetup", self2);
              self2.emit("all", self2);
            } else if (self2.isConnected()) {
              self2.emit("reconnect", self2);
            } else if (!self2.isConnected() && self2.listeners("close").length > 0) {
              self2.emit("close", self2);
            }
            topologyMonitor(self2);
          });
        }
        for (var i = 0; i < proxies.length; i++) {
          pingServer(self2, proxies[i], function() {
            count = count - 1;
            if (count === 0) {
              if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                return;
              }
              reconnectProxies(self2, self2.disconnectedProxies, function() {
                if (self2.state === DESTROYED || self2.state === DESTROYING || self2.state === UNREFERENCED) {
                  return;
                }
                topologyMonitor(self2);
              });
            }
          });
        }
      }, self2.s.haInterval);
    }
    Mongos.prototype.lastIsMaster = function() {
      return this.ismaster;
    };
    Mongos.prototype.unref = function() {
      stateTransition(this, UNREFERENCED);
      var proxies = this.connectedProxies.concat(this.connectingProxies);
      proxies.forEach(function(x) {
        x.unref();
      });
      clearTimeout(this.haTimeoutId);
    };
    Mongos.prototype.destroy = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || {};
      stateTransition(this, DESTROYING);
      if (this.haTimeoutId) {
        clearTimeout(this.haTimeoutId);
      }
      const proxies = this.connectedProxies.concat(this.connectingProxies);
      let serverCount = proxies.length;
      const serverDestroyed = () => {
        serverCount--;
        if (serverCount > 0) {
          return;
        }
        emitTopologyDescriptionChanged(this);
        emitSDAMEvent(this, "topologyClosed", { topologyId: this.id });
        stateTransition(this, DESTROYED);
        if (typeof callback === "function") {
          callback(null, null);
        }
      };
      if (serverCount === 0) {
        serverDestroyed();
        return;
      }
      proxies.forEach((server) => {
        this.emit("serverClosed", {
          topologyId: this.id,
          address: server.name
        });
        destroyServer(server, options2, serverDestroyed);
        moveServerFrom(this.connectedProxies, this.disconnectedProxies, server);
      });
    };
    Mongos.prototype.isConnected = function() {
      return this.connectedProxies.length > 0;
    };
    Mongos.prototype.isDestroyed = function() {
      return this.state === DESTROYED;
    };
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const self2 = args.self;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      let server = pickProxy(self2, options2.session);
      if (!server)
        return callback(new MongoError("no mongos proxy available"));
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && options2.explain === void 0;
      const handler = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2) || !willRetryWrite) {
          err = getMMAPError(err);
          return callback(err);
        }
        server = pickProxy(self2, options2.session);
        if (!server) {
          return callback(err);
        }
        const newArgs = Object.assign({}, args, { retrying: true });
        return executeWriteOperation(newArgs, options2, callback);
      };
      if (callback.operationId) {
        handler.operationId = callback.operationId;
      }
      if (willRetryWrite) {
        options2.session.incrementTransactionNumber();
        options2.willRetryWrite = willRetryWrite;
      }
      server[op](ns, ops, options2, handler);
    }
    Mongos.prototype.insert = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("insert", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "insert", ns, ops }, options2, callback);
    };
    Mongos.prototype.update = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("update", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "update", ns, ops }, options2, callback);
    };
    Mongos.prototype.remove = function(ns, ops, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      if (!this.isConnected() && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("remove", ns, ops, options2, callback);
      }
      if (!this.isConnected()) {
        return callback(new MongoError("no mongos proxy available"));
      }
      executeWriteOperation({ self: this, op: "remove", ns, ops }, options2, callback);
    };
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    Mongos.prototype.command = function(ns, cmd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {}, options2 = options2 || {};
      }
      if (this.state === DESTROYED) {
        return callback(new MongoError(f("topology was destroyed")));
      }
      var self2 = this;
      var server = pickProxy(self2, options2.session);
      if ((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
        return this.s.disconnectHandler.add("command", ns, cmd, options2, callback);
      }
      if (server == null) {
        return callback(new MongoError("no mongos proxy available"));
      }
      var clonedOptions = cloneOptions(options2);
      clonedOptions.topology = self2;
      const willRetryWrite = !options2.retrying && options2.retryWrites && options2.session && isRetryableWritesSupported(self2) && !options2.session.inTransaction() && isWriteCommand(cmd);
      const cb = (err, result) => {
        if (!err)
          return callback(null, result);
        if (!legacyIsRetryableWriteError(err, self2)) {
          return callback(err);
        }
        if (willRetryWrite) {
          const newOptions = Object.assign({}, clonedOptions, { retrying: true });
          return this.command(ns, cmd, newOptions, callback);
        }
        return callback(err);
      };
      if (willRetryWrite) {
        clonedOptions.session.incrementTransactionNumber();
        clonedOptions.willRetryWrite = willRetryWrite;
      }
      server.command(ns, cmd, clonedOptions, cb);
    };
    Mongos.prototype.cursor = function(ns, cmd, options2) {
      options2 = options2 || {};
      const topology = options2.topology || this;
      var FinalCursor = options2.cursorFactory || this.s.Cursor;
      return new FinalCursor(topology, ns, cmd, options2);
    };
    Mongos.prototype.selectServer = function(selector, options2, callback) {
      if (typeof selector === "function" && typeof callback === "undefined")
        callback = selector, selector = void 0, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = selector, selector = void 0;
      options2 = options2 || {};
      const server = pickProxy(this, options2.session);
      if (server == null) {
        callback(new MongoError("server selection failed"));
        return;
      }
      if (this.s.debug)
        this.emit("pickedServer", null, server);
      callback(null, server);
    };
    Mongos.prototype.connections = function() {
      var connections = [];
      for (var i = 0; i < this.connectedProxies.length; i++) {
        connections = connections.concat(this.connectedProxies[i].connections());
      }
      return connections;
    };
    function emitTopologyDescriptionChanged(self2) {
      if (self2.listeners("topologyDescriptionChanged").length > 0) {
        var topology = "Unknown";
        if (self2.connectedProxies.length > 0) {
          topology = "Sharded";
        }
        var description = {
          topologyType: topology,
          servers: []
        };
        var proxies = self2.disconnectedProxies.concat(self2.connectingProxies);
        description.servers = description.servers.concat(proxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Unknown";
          return description2;
        }));
        description.servers = description.servers.concat(self2.connectedProxies.map(function(x) {
          var description2 = x.getDescription();
          description2.type = "Mongos";
          return description2;
        }));
        var diffResult = diff(self2.topologyDescription, description);
        var result = {
          topologyId: self2.id,
          previousDescription: self2.topologyDescription,
          newDescription: description,
          diff: diffResult
        };
        if (diffResult.servers.length > 0) {
          self2.emit("topologyDescriptionChanged", result);
        }
        self2.topologyDescription = description;
      }
    }
    module2.exports = Mongos;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    function Denque(array, options2) {
      var options2 = options2 || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options2.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index2) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index2 < size / 2) {
        for (k = index2; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index2; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index2, count) {
      var i = index2;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index2 + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index2 === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index2 + count + len & this._capacityMask;
        for (k = index2; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index2 < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index2); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index2, count) {
      var i = index2;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list2 = this._list;
      var len = list2.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list2[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list2[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list2[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length *= 2;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/mongodb/lib/core/sdam/events.js
var require_events = __commonJS({
  "node_modules/mongodb/lib/core/sdam/events.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerDescriptionChangedEvent = class {
      constructor(topologyId, address, previousDescription, newDescription) {
        Object.assign(this, { topologyId, address, previousDescription, newDescription });
      }
    };
    var ServerOpeningEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var ServerClosedEvent = class {
      constructor(topologyId, address) {
        Object.assign(this, { topologyId, address });
      }
    };
    var TopologyDescriptionChangedEvent = class {
      constructor(topologyId, previousDescription, newDescription) {
        Object.assign(this, { topologyId, previousDescription, newDescription });
      }
    };
    var TopologyOpeningEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var TopologyClosedEvent = class {
      constructor(topologyId) {
        Object.assign(this, { topologyId });
      }
    };
    var ServerHeartbeatStartedEvent = class {
      constructor(connectionId) {
        Object.assign(this, { connectionId });
      }
    };
    var ServerHeartbeatSucceededEvent = class {
      constructor(duration, reply, connectionId) {
        Object.assign(this, { connectionId, duration, reply });
      }
    };
    var ServerHeartbeatFailedEvent = class {
      constructor(duration, failure, connectionId) {
        Object.assign(this, { connectionId, duration, failure });
      }
    };
    module2.exports = {
      ServerDescriptionChangedEvent,
      ServerOpeningEvent,
      ServerClosedEvent,
      TopologyDescriptionChangedEvent,
      TopologyOpeningEvent,
      TopologyClosedEvent,
      ServerHeartbeatStartedEvent,
      ServerHeartbeatSucceededEvent,
      ServerHeartbeatFailedEvent
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    init_shims();
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    init_shims();
    module2.exports = __require("stream");
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    init_shims();
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d3) {
      return objectToString(d3) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    init_shims();
    try {
      util2 = __require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    init_shims();
    "use strict";
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util2 = __require("util");
    function copyBuffer(src3, target, offset) {
      src3.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s3) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s3 + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module2.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    init_shims();
    module2.exports = __require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util2.inherits(Writable, Stream2);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream2.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding3, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding3 === "function") {
        cb = encoding3;
        encoding3 = null;
      }
      if (isBuf)
        encoding3 = "buffer";
      else if (!encoding3)
        encoding3 = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding3, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding3) {
      if (typeof encoding3 === "string")
        encoding3 = encoding3.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding3 + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding3);
      this._writableState.defaultEncoding = encoding3;
      return this;
    };
    function decodeChunk(state, chunk, encoding3) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding3);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding3, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding3);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding3 = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding: encoding3,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding3, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding3, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding3, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding3 = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding3, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding3, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding3, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding3 = null;
      } else if (typeof encoding3 === "function") {
        cb = encoding3;
        encoding3 = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding3);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    util2.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable2.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    init_shims();
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    var debugUtil = __require("util");
    var debug2 = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util2.inherits(Readable2, Stream2);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = __require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable2(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding3) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding3 = encoding3 || state.defaultEncoding;
          if (encoding3 !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding3);
            encoding3 = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding3, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding3, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding3) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = __require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug2("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug2("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src3 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src3.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src3) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src3);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src3.removeListener("end", onend);
        src3.removeListener("end", unpipe);
        src3.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src3.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", src3._readableState.awaitDrain);
            src3._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src3.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src3.unpipe(dest);
      }
      dest.emit("pipe", src3);
      if (!state.flowing) {
        debug2("pipe resume");
        src3.resume();
      }
      return dest;
    };
    function pipeOnDrain(src3) {
      return function() {
        var state = src3._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src3, "data")) {
          state.flowing = true;
          flow(src3);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index2 = indexOf(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug2("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug2("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list2, hasStrings) {
      var ret;
      if (n < list2.head.data.length) {
        ret = list2.head.data.slice(0, n);
        list2.head.data = list2.head.data.slice(n);
      } else if (n === list2.head.data.length) {
        ret = list2.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list2) : copyFromBuffer(n, list2);
      }
      return ret;
    }
    function copyFromBufferString(n, list2) {
      var p = list2.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list2.head = p.next;
            else
              list2.head = list2.tail = null;
          } else {
            list2.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list2.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list2) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list2.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list2.head = p.next;
            else
              list2.head = list2.tail = null;
          } else {
            list2.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list2.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    util2.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding3) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding3);
    };
    Transform.prototype._transform = function(chunk, encoding3, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding3, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding3;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = PassThrough2;
    var Transform = require_stream_transform();
    var util2 = Object.create(require_util());
    util2.inherits = require_inherits();
    util2.inherits(PassThrough2, Transform);
    function PassThrough2(options2) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options2);
      Transform.call(this, options2);
    }
    PassThrough2.prototype._transform = function(chunk, encoding3, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    init_shims();
    var Stream2 = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream2) {
      module2.exports = Stream2;
      exports2 = module2.exports = Stream2.Readable;
      exports2.Readable = Stream2.Readable;
      exports2.Writable = Stream2.Writable;
      exports2.Duplex = Stream2.Duplex;
      exports2.Transform = Stream2.Transform;
      exports2.PassThrough = Stream2.PassThrough;
      exports2.Stream = Stream2;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream2 || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    init_shims();
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var util2 = __require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src3) {
          src3.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src3) {
          src3.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util2.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      var bufferId = blOffset[0];
      var offset = blOffset[1];
      for (var i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.append = function append2(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding3, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get2(index2) {
      if (index2 > this.length || index2 < 0) {
        return void 0;
      }
      var offset = this._offset(index2);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes2 = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes2 <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off[0]].slice(start, start + bytes2);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes2 > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes2);
          bufoff += l;
          break;
        }
        bytes2 -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      if (start === end) {
        return new BufferList();
      }
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding3, start, end) {
      return this.slice(start, end).toString(encoding3);
    };
    BufferList.prototype.consume = function consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes2 >= this._bufs[0].length) {
          bytes2 -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes2);
          this.length -= bytes2;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    BufferList.prototype.indexOf = function(search, offset, encoding3) {
      if (encoding3 === void 0 && typeof offset === "string") {
        encoding3 = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding3);
      } else if (search instanceof BufferList) {
        search = search.slice();
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      var blOffset = this._offset(offset);
      var blIndex = blOffset[0];
      var buffOffset = blOffset[1];
      for (blIndex; blIndex < this._bufs.length; blIndex++) {
        var buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          var availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            var nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            var revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (var searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1,
        "readIntBE": null,
        "readIntLE": null,
        "readUIntBE": null,
        "readUIntLE": null
      };
      for (var m2 in methods) {
        (function(m3) {
          if (methods[m3] === null) {
            BufferList.prototype[m3] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m3](0, byteLength);
            };
          } else {
            BufferList.prototype[m3] = function(offset) {
              return this.slice(offset, offset + methods[m3])[m3](0);
            };
          }
        })(m2);
      }
    })();
    module2.exports = BufferList;
  }
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS({
  "node_modules/mongodb/lib/cmap/message_stream.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Duplex = __require("stream").Duplex;
    var BufferList = require_bl();
    var MongoParseError = require_error().MongoParseError;
    var decompress = require_compression().decompress;
    var Response3 = require_commands().Response;
    var BinMsg = require_msg().BinMsg;
    var MongoError = require_error().MongoError;
    var OP_COMPRESSED = require_shared().opcodes.OP_COMPRESSED;
    var OP_MSG = require_shared().opcodes.OP_MSG;
    var MESSAGE_HEADER_SIZE = require_shared().MESSAGE_HEADER_SIZE;
    var COMPRESSION_DETAILS_SIZE = require_shared().COMPRESSION_DETAILS_SIZE;
    var opcodes = require_shared().opcodes;
    var compress = require_compression().compress;
    var compressorIDs = require_compression().compressorIDs;
    var uncompressibleCommands = require_compression().uncompressibleCommands;
    var Msg = require_msg().Msg;
    var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
    var kBuffer = Symbol("buffer");
    var MessageStream = class extends Duplex {
      constructor(options2) {
        options2 = options2 || {};
        super(options2);
        this.bson = options2.bson;
        this.maxBsonMessageSize = options2.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
        this[kBuffer] = new BufferList();
      }
      _write(chunk, _, callback) {
        const buffer2 = this[kBuffer];
        buffer2.append(chunk);
        processIncomingData(this, callback);
      }
      _read() {
        return;
      }
      writeCommand(command, operationDescription) {
        const shouldCompress2 = operationDescription && !!operationDescription.agreedCompressor;
        if (!shouldCompress2 || !canCompress(command)) {
          const data = command.toBin();
          this.push(Array.isArray(data) ? Buffer.concat(data) : data);
          return;
        }
        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
        compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {
          if (err) {
            operationDescription.cb(err, null);
            return;
          }
          const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
          msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
          msgHeader.writeInt32LE(command.requestId, 4);
          msgHeader.writeInt32LE(0, 8);
          msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12);
          const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
          compressionDetails.writeInt32LE(originalCommandOpCode, 0);
          compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
          compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8);
          this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
        });
      }
    };
    function canCompress(command) {
      const commandDoc = command instanceof Msg ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !uncompressibleCommands.has(commandName);
    }
    function processIncomingData(stream, callback) {
      const buffer2 = stream[kBuffer];
      if (buffer2.length < 4) {
        callback();
        return;
      }
      const sizeOfMessage = buffer2.readInt32LE(0);
      if (sizeOfMessage < 0) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}`));
        return;
      }
      if (sizeOfMessage > stream.maxBsonMessageSize) {
        callback(new MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
        return;
      }
      if (sizeOfMessage > buffer2.length) {
        callback();
        return;
      }
      const message = buffer2.slice(0, sizeOfMessage);
      buffer2.consume(sizeOfMessage);
      const messageHeader = {
        length: message.readInt32LE(0),
        requestId: message.readInt32LE(4),
        responseTo: message.readInt32LE(8),
        opCode: message.readInt32LE(12)
      };
      let ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      const responseOptions = stream.responseOptions;
      if (messageHeader.opCode !== OP_COMPRESSED) {
        const messageBody = message.slice(MESSAGE_HEADER_SIZE);
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer2.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
        return;
      }
      messageHeader.fromCompressed = true;
      messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
      messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
      const compressorID = message[MESSAGE_HEADER_SIZE + 8];
      const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
      ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response3;
      decompress(compressorID, compressedBuffer, (err, messageBody) => {
        if (err) {
          callback(err);
          return;
        }
        if (messageBody.length !== messageHeader.length) {
          callback(new MongoError("Decompressing a compressed message from the server failed. The message is corrupt."));
          return;
        }
        stream.emit("message", new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));
        if (buffer2.length >= 4) {
          processIncomingData(stream, callback);
        } else {
          callback();
        }
      });
    }
    module2.exports = MessageStream;
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS({
  "node_modules/mongodb/lib/cmap/stream_description.js"(exports2, module2) {
    init_shims();
    "use strict";
    var parseServerType = require_server_description().parseServerType;
    var RESPONSE_FIELDS = [
      "minWireVersion",
      "maxWireVersion",
      "maxBsonObjectSize",
      "maxMessageSizeBytes",
      "maxWriteBatchSize",
      "__nodejs_mock_server__"
    ];
    var StreamDescription = class {
      constructor(address, options2) {
        this.address = address;
        this.type = parseServerType(null);
        this.minWireVersion = void 0;
        this.maxWireVersion = void 0;
        this.maxBsonObjectSize = 16777216;
        this.maxMessageSizeBytes = 48e6;
        this.maxWriteBatchSize = 1e5;
        this.compressors = options2 && options2.compression && Array.isArray(options2.compression.compressors) ? options2.compression.compressors : [];
      }
      receiveResponse(response) {
        this.type = parseServerType(response);
        RESPONSE_FIELDS.forEach((field) => {
          if (typeof response[field] !== "undefined") {
            this[field] = response[field];
          }
        });
        if (response.compression) {
          this.compressor = this.compressors.filter((c) => response.compression.indexOf(c) !== -1)[0];
        }
      }
    };
    module2.exports = {
      StreamDescription
    };
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection2 = __commonJS({
  "node_modules/mongodb/lib/cmap/connection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events");
    var MessageStream = require_message_stream();
    var MongoError = require_error().MongoError;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var MongoWriteConcernError = require_error().MongoWriteConcernError;
    var CommandResult = require_command_result();
    var StreamDescription = require_stream_description().StreamDescription;
    var wp = require_wireprotocol();
    var apm = require_apm();
    var updateSessionFromResponse = require_sessions().updateSessionFromResponse;
    var uuidV4 = require_utils2().uuidV4;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var kStream = Symbol("stream");
    var kQueue = Symbol("queue");
    var kMessageStream = Symbol("messageStream");
    var kGeneration = Symbol("generation");
    var kLastUseTime = Symbol("lastUseTime");
    var kClusterTime = Symbol("clusterTime");
    var kDescription = Symbol("description");
    var kIsMaster = Symbol("ismaster");
    var kAutoEncrypter = Symbol("autoEncrypter");
    var Connection = class extends EventEmitter {
      constructor(stream, options2) {
        super(options2);
        this.id = options2.id;
        this.address = streamIdentifier(stream);
        this.bson = options2.bson;
        this.socketTimeout = typeof options2.socketTimeout === "number" ? options2.socketTimeout : 0;
        this.host = options2.host || "localhost";
        this.port = options2.port || 27017;
        this.monitorCommands = typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false;
        this.closed = false;
        this.destroyed = false;
        this[kDescription] = new StreamDescription(this.address, options2);
        this[kGeneration] = options2.generation;
        this[kLastUseTime] = now();
        if (options2.autoEncrypter) {
          this[kAutoEncrypter] = options2.autoEncrypter;
        }
        this[kQueue] = new Map();
        this[kMessageStream] = new MessageStream(options2);
        this[kMessageStream].on("message", messageHandler(this));
        this[kStream] = stream;
        stream.on("error", () => {
        });
        this[kMessageStream].on("error", (error3) => this.handleIssue({ destroy: error3 }));
        stream.on("close", () => this.handleIssue({ isClose: true }));
        stream.on("timeout", () => this.handleIssue({ isTimeout: true, destroy: true }));
        stream.pipe(this[kMessageStream]);
        this[kMessageStream].pipe(stream);
      }
      get description() {
        return this[kDescription];
      }
      get ismaster() {
        return this[kIsMaster];
      }
      set ismaster(response) {
        this[kDescription].receiveResponse(response);
        this[kIsMaster] = response;
      }
      get generation() {
        return this[kGeneration] || 0;
      }
      get idleTime() {
        return calculateDurationInMs(this[kLastUseTime]);
      }
      get clusterTime() {
        return this[kClusterTime];
      }
      get stream() {
        return this[kStream];
      }
      markAvailable() {
        this[kLastUseTime] = now();
      }
      handleIssue(issue) {
        if (this.closed) {
          return;
        }
        if (issue.destroy) {
          this[kStream].destroy(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
        }
        this.closed = true;
        for (const idAndOp of this[kQueue]) {
          const op = idAndOp[1];
          if (issue.isTimeout) {
            op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {
              beforeHandshake: this.ismaster == null
            }));
          } else if (issue.isClose) {
            op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));
          } else {
            op.cb(typeof issue.destroy === "boolean" ? void 0 : issue.destroy);
          }
        }
        this[kQueue].clear();
        this.emit("close");
      }
      destroy(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = Object.assign({ force: false }, options2);
        if (this[kStream] == null || this.destroyed) {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        if (options2.force) {
          this[kStream].destroy();
          this.destroyed = true;
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        this[kStream].end((err) => {
          this.destroyed = true;
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      command(ns, cmd, options2, callback) {
        wp.command(makeServerTrampoline(this), ns, cmd, options2, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options2, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options2, callback);
      }
      killCursors(ns, cursorState, callback) {
        wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);
      }
      insert(ns, ops, options2, callback) {
        wp.insert(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        wp.update(makeServerTrampoline(this), ns, ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        wp.remove(makeServerTrampoline(this), ns, ops, options2, callback);
      }
    };
    function makeServerTrampoline(connection2) {
      const server = {
        description: connection2.description,
        clusterTime: connection2[kClusterTime],
        s: {
          bson: connection2.bson,
          pool: { write: write.bind(connection2), isConnected: () => true }
        }
      };
      if (connection2[kAutoEncrypter]) {
        server.autoEncrypter = connection2[kAutoEncrypter];
      }
      return server;
    }
    function messageHandler(conn) {
      return function messageHandler2(message) {
        conn.emit("message", message);
        if (!conn[kQueue].has(message.responseTo)) {
          return;
        }
        const operationDescription = conn[kQueue].get(message.responseTo);
        const callback = operationDescription.cb;
        conn[kQueue].delete(message.responseTo);
        if (message.moreToCome) {
          conn[kQueue].set(message.requestId, operationDescription);
        } else if (operationDescription.socketTimeoutOverride) {
          conn[kStream].setTimeout(conn.socketTimeout);
        }
        try {
          message.parse(operationDescription);
        } catch (err) {
          callback(new MongoError(err));
          return;
        }
        if (message.documents[0]) {
          const document2 = message.documents[0];
          const session = operationDescription.session;
          if (session) {
            updateSessionFromResponse(session, document2);
          }
          if (document2.$clusterTime) {
            conn[kClusterTime] = document2.$clusterTime;
            conn.emit("clusterTimeReceived", document2.$clusterTime);
          }
          if (operationDescription.command) {
            if (document2.writeConcernError) {
              callback(new MongoWriteConcernError(document2.writeConcernError, document2));
              return;
            }
            if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
              callback(new MongoError(document2));
              return;
            }
          }
        }
        callback(void 0, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));
      };
    }
    function streamIdentifier(stream) {
      if (typeof stream.address === "function") {
        return `${stream.remoteAddress}:${stream.remotePort}`;
      }
      return uuidV4().toString("hex");
    }
    function write(command, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
      }
      options2 = options2 || {};
      const operationDescription = {
        requestId: command.requestId,
        cb: callback,
        session: options2.session,
        fullResult: typeof options2.fullResult === "boolean" ? options2.fullResult : false,
        noResponse: typeof options2.noResponse === "boolean" ? options2.noResponse : false,
        documentsReturnedIn: options2.documentsReturnedIn,
        command: !!options2.command,
        promoteLongs: typeof options2.promoteLongs === "boolean" ? options2.promoteLongs : true,
        promoteValues: typeof options2.promoteValues === "boolean" ? options2.promoteValues : true,
        promoteBuffers: typeof options2.promoteBuffers === "boolean" ? options2.promoteBuffers : false,
        raw: typeof options2.raw === "boolean" ? options2.raw : false
      };
      if (this[kDescription] && this[kDescription].compressor) {
        operationDescription.agreedCompressor = this[kDescription].compressor;
        if (this[kDescription].zlibCompressionLevel) {
          operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;
        }
      }
      if (typeof options2.socketTimeout === "number") {
        operationDescription.socketTimeoutOverride = true;
        this[kStream].setTimeout(options2.socketTimeout);
      }
      if (this.monitorCommands) {
        this.emit("commandStarted", new apm.CommandStartedEvent(this, command));
        operationDescription.started = now();
        operationDescription.cb = (err, reply) => {
          if (err) {
            this.emit("commandFailed", new apm.CommandFailedEvent(this, command, err, operationDescription.started));
          } else {
            if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {
              this.emit("commandFailed", new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));
            } else {
              this.emit("commandSucceeded", new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));
            }
          }
          if (typeof callback === "function") {
            callback(err, reply);
          }
        };
      }
      if (!operationDescription.noResponse) {
        this[kQueue].set(operationDescription.requestId, operationDescription);
      }
      try {
        this[kMessageStream].writeCommand(command, operationDescription);
      } catch (e) {
        if (!operationDescription.noResponse) {
          this[kQueue].delete(operationDescription.requestId);
          operationDescription.cb(e);
          return;
        }
      }
      if (operationDescription.noResponse) {
        operationDescription.cb();
      }
    }
    module2.exports = {
      Connection
    };
  }
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS({
  "node_modules/mongodb/lib/cmap/errors.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_error().MongoError;
    var PoolClosedError = class extends MongoError {
      constructor(pool) {
        super("Attempted to check out a connection from closed connection pool");
        this.name = "MongoPoolClosedError";
        this.address = pool.address;
      }
    };
    var WaitQueueTimeoutError = class extends MongoError {
      constructor(pool) {
        super("Timed out while checking out a connection from connection pool");
        this.name = "MongoWaitQueueTimeoutError";
        this.address = pool.address;
      }
    };
    module2.exports = {
      PoolClosedError,
      WaitQueueTimeoutError
    };
  }
});

// node_modules/mongodb/lib/cmap/events.js
var require_events2 = __commonJS({
  "node_modules/mongodb/lib/cmap/events.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ConnectionPoolMonitoringEvent = class {
      constructor(pool) {
        this.time = new Date();
        this.address = pool.address;
      }
    };
    var ConnectionPoolCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
        this.options = pool.options;
      }
    };
    var ConnectionPoolClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCreatedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection2) {
        super(pool);
        this.connectionId = connection2.id;
      }
    };
    var ConnectionReadyEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection2) {
        super(pool);
        this.connectionId = connection2.id;
      }
    };
    var ConnectionClosedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection2, reason) {
        super(pool);
        this.connectionId = connection2.id;
        this.reason = reason || "unknown";
      }
    };
    var ConnectionCheckOutStartedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var ConnectionCheckOutFailedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, reason) {
        super(pool);
        this.reason = reason;
      }
    };
    var ConnectionCheckedOutEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection2) {
        super(pool);
        this.connectionId = connection2.id;
      }
    };
    var ConnectionCheckedInEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool, connection2) {
        super(pool);
        this.connectionId = connection2.id;
      }
    };
    var ConnectionPoolClearedEvent = class extends ConnectionPoolMonitoringEvent {
      constructor(pool) {
        super(pool);
      }
    };
    var CMAP_EVENT_NAMES = [
      "connectionPoolCreated",
      "connectionPoolClosed",
      "connectionCreated",
      "connectionReady",
      "connectionClosed",
      "connectionCheckOutStarted",
      "connectionCheckOutFailed",
      "connectionCheckedOut",
      "connectionCheckedIn",
      "connectionPoolCleared"
    ];
    module2.exports = {
      CMAP_EVENT_NAMES,
      ConnectionPoolCreatedEvent,
      ConnectionPoolClosedEvent,
      ConnectionCreatedEvent,
      ConnectionReadyEvent,
      ConnectionClosedEvent,
      ConnectionCheckOutStartedEvent,
      ConnectionCheckOutFailedEvent,
      ConnectionCheckedOutEvent,
      ConnectionCheckedInEvent,
      ConnectionPoolClearedEvent
    };
  }
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS({
  "node_modules/mongodb/lib/cmap/connection_pool.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events").EventEmitter;
    var Logger = require_logger();
    var makeCounter = require_utils4().makeCounter;
    var MongoError = require_error().MongoError;
    var Connection = require_connection2().Connection;
    var eachAsync = require_utils2().eachAsync;
    var connect2 = require_connect();
    var relayEvents = require_utils2().relayEvents;
    var errors = require_errors();
    var PoolClosedError = errors.PoolClosedError;
    var WaitQueueTimeoutError = errors.WaitQueueTimeoutError;
    var events = require_events2();
    var ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;
    var ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;
    var ConnectionCreatedEvent = events.ConnectionCreatedEvent;
    var ConnectionReadyEvent = events.ConnectionReadyEvent;
    var ConnectionClosedEvent = events.ConnectionClosedEvent;
    var ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;
    var ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;
    var ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;
    var ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;
    var ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;
    var kLogger = Symbol("logger");
    var kConnections = Symbol("connections");
    var kPermits = Symbol("permits");
    var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
    var kGeneration = Symbol("generation");
    var kConnectionCounter = Symbol("connectionCounter");
    var kCancellationToken = Symbol("cancellationToken");
    var kWaitQueue = Symbol("waitQueue");
    var kCancelled = Symbol("cancelled");
    var VALID_POOL_OPTIONS = new Set([
      "ssl",
      "bson",
      "connectionType",
      "monitorCommands",
      "socketTimeout",
      "credentials",
      "compression",
      "host",
      "port",
      "localAddress",
      "localPort",
      "family",
      "hints",
      "lookup",
      "path",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "passphrase",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "allowHalfOpen",
      "rejectUnauthorized",
      "pskCallback",
      "ALPNProtocols",
      "servername",
      "checkServerIdentity",
      "session",
      "minDHSize",
      "secureContext",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ]);
    function resolveOptions(options2, defaults) {
      const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {
        if (Object.prototype.hasOwnProperty.call(options2, key)) {
          obj[key] = options2[key];
        }
        return obj;
      }, {});
      return Object.freeze(Object.assign({}, defaults, newOptions));
    }
    var ConnectionPool = class extends EventEmitter {
      constructor(options2) {
        super();
        options2 = options2 || {};
        this.closed = false;
        this.options = resolveOptions(options2, {
          connectionType: Connection,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : 100,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : 0,
          maxIdleTimeMS: typeof options2.maxIdleTimeMS === "number" ? options2.maxIdleTimeMS : 0,
          waitQueueTimeoutMS: typeof options2.waitQueueTimeoutMS === "number" ? options2.waitQueueTimeoutMS : 0,
          autoEncrypter: options2.autoEncrypter,
          metadata: options2.metadata
        });
        if (options2.minSize > options2.maxSize) {
          throw new TypeError("Connection pool minimum size must not be greater than maxiumum pool size");
        }
        this[kLogger] = Logger("ConnectionPool", options2);
        this[kConnections] = new Denque();
        this[kPermits] = this.options.maxPoolSize;
        this[kMinPoolSizeTimer] = void 0;
        this[kGeneration] = 0;
        this[kConnectionCounter] = makeCounter(1);
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kWaitQueue] = new Denque();
        process.nextTick(() => {
          this.emit("connectionPoolCreated", new ConnectionPoolCreatedEvent(this));
          ensureMinPoolSize(this);
        });
      }
      get address() {
        return `${this.options.host}:${this.options.port}`;
      }
      get generation() {
        return this[kGeneration];
      }
      get totalConnectionCount() {
        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);
      }
      get availableConnectionCount() {
        return this[kConnections].length;
      }
      get waitQueueSize() {
        return this[kWaitQueue].length;
      }
      checkOut(callback) {
        this.emit("connectionCheckOutStarted", new ConnectionCheckOutStartedEvent(this));
        if (this.closed) {
          this.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(this, "poolClosed"));
          callback(new PoolClosedError(this));
          return;
        }
        const waitQueueMember = { callback };
        const pool = this;
        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
        if (waitQueueTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, "timeout"));
            waitQueueMember.callback(new WaitQueueTimeoutError(pool));
          }, waitQueueTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        process.nextTick(() => processWaitQueue(this));
      }
      checkIn(connection2) {
        const poolClosed = this.closed;
        const stale = connectionIsStale(this, connection2);
        const willDestroy = !!(poolClosed || stale || connection2.closed);
        if (!willDestroy) {
          connection2.markAvailable();
          this[kConnections].push(connection2);
        }
        this.emit("connectionCheckedIn", new ConnectionCheckedInEvent(this, connection2));
        if (willDestroy) {
          const reason = connection2.closed ? "error" : poolClosed ? "poolClosed" : "stale";
          destroyConnection(this, connection2, reason);
        }
        process.nextTick(() => processWaitQueue(this));
      }
      clear() {
        this[kGeneration] += 1;
        this.emit("connectionPoolCleared", new ConnectionPoolClearedEvent(this));
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
        }
        options2 = Object.assign({ force: false }, options2);
        if (this.closed) {
          return callback();
        }
        this[kCancellationToken].emit("cancel");
        while (this.waitQueueSize) {
          const waitQueueMember = this[kWaitQueue].pop();
          clearTimeout(waitQueueMember.timer);
          if (!waitQueueMember[kCancelled]) {
            waitQueueMember.callback(new MongoError("connection pool closed"));
          }
        }
        if (this[kMinPoolSizeTimer]) {
          clearTimeout(this[kMinPoolSizeTimer]);
        }
        if (typeof this[kConnectionCounter].return === "function") {
          this[kConnectionCounter].return();
        }
        this.closed = true;
        eachAsync(this[kConnections].toArray(), (conn, cb) => {
          this.emit("connectionClosed", new ConnectionClosedEvent(this, conn, "poolClosed"));
          conn.destroy(options2, cb);
        }, (err) => {
          this[kConnections].clear();
          this.emit("connectionPoolClosed", new ConnectionPoolClosedEvent(this));
          callback(err);
        });
      }
      withConnection(fn, callback) {
        this.checkOut((err, conn) => {
          fn(err, conn, (fnErr, result) => {
            if (typeof callback === "function") {
              if (fnErr) {
                callback(fnErr);
              } else {
                callback(void 0, result);
              }
            }
            if (conn) {
              this.checkIn(conn);
            }
          });
        });
      }
    };
    function ensureMinPoolSize(pool) {
      if (pool.closed || pool.options.minPoolSize === 0) {
        return;
      }
      const minPoolSize = pool.options.minPoolSize;
      for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {
        createConnection(pool);
      }
      pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);
    }
    function connectionIsStale(pool, connection2) {
      return connection2.generation !== pool[kGeneration];
    }
    function connectionIsIdle(pool, connection2) {
      return !!(pool.options.maxIdleTimeMS && connection2.idleTime > pool.options.maxIdleTimeMS);
    }
    function createConnection(pool, callback) {
      const connectOptions = Object.assign({
        id: pool[kConnectionCounter].next().value,
        generation: pool[kGeneration]
      }, pool.options);
      pool[kPermits]--;
      connect2(connectOptions, pool[kCancellationToken], (err, connection2) => {
        if (err) {
          pool[kPermits]++;
          pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);
          if (typeof callback === "function") {
            callback(err);
          }
          return;
        }
        if (pool.closed) {
          connection2.destroy({ force: true });
          return;
        }
        relayEvents(connection2, pool, [
          "commandStarted",
          "commandFailed",
          "commandSucceeded",
          "clusterTimeReceived"
        ]);
        pool.emit("connectionCreated", new ConnectionCreatedEvent(pool, connection2));
        connection2.markAvailable();
        pool.emit("connectionReady", new ConnectionReadyEvent(pool, connection2));
        if (typeof callback === "function") {
          callback(void 0, connection2);
          return;
        }
        pool[kConnections].push(connection2);
        process.nextTick(() => processWaitQueue(pool));
      });
    }
    function destroyConnection(pool, connection2, reason) {
      pool.emit("connectionClosed", new ConnectionClosedEvent(pool, connection2, reason));
      pool[kPermits]++;
      process.nextTick(() => connection2.destroy());
    }
    function processWaitQueue(pool) {
      if (pool.closed) {
        return;
      }
      while (pool.waitQueueSize) {
        const waitQueueMember = pool[kWaitQueue].peekFront();
        if (waitQueueMember[kCancelled]) {
          pool[kWaitQueue].shift();
          continue;
        }
        if (!pool.availableConnectionCount) {
          break;
        }
        const connection2 = pool[kConnections].shift();
        const isStale = connectionIsStale(pool, connection2);
        const isIdle = connectionIsIdle(pool, connection2);
        if (!isStale && !isIdle && !connection2.closed) {
          pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection2));
          clearTimeout(waitQueueMember.timer);
          pool[kWaitQueue].shift();
          waitQueueMember.callback(void 0, connection2);
          return;
        }
        const reason = connection2.closed ? "error" : isStale ? "stale" : "idle";
        destroyConnection(pool, connection2, reason);
      }
      const maxPoolSize = pool.options.maxPoolSize;
      if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {
        createConnection(pool, (err, connection2) => {
          const waitQueueMember = pool[kWaitQueue].shift();
          if (waitQueueMember == null || waitQueueMember[kCancelled]) {
            if (err == null) {
              pool[kConnections].push(connection2);
            }
            return;
          }
          if (err) {
            pool.emit("connectionCheckOutFailed", new ConnectionCheckOutFailedEvent(pool, err));
          } else {
            pool.emit("connectionCheckedOut", new ConnectionCheckedOutEvent(pool, connection2));
          }
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(err, connection2);
        });
        return;
      }
    }
    module2.exports = {
      ConnectionPool
    };
  }
});

// node_modules/mongodb/lib/core/sdam/monitor.js
var require_monitor = __commonJS({
  "node_modules/mongodb/lib/core/sdam/monitor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var EventEmitter = __require("events");
    var connect2 = require_connect();
    var Connection = require_connection2().Connection;
    var common = require_common();
    var makeStateMachine = require_utils2().makeStateMachine;
    var MongoNetworkError = require_error().MongoNetworkError;
    var BSON2 = require_utils3().retrieveBSON();
    var makeInterruptableAsyncInterval = require_utils4().makeInterruptableAsyncInterval;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var now = require_utils4().now;
    var sdamEvents = require_events();
    var ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;
    var ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;
    var ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;
    var kServer = Symbol("server");
    var kMonitorId = Symbol("monitorId");
    var kConnection = Symbol("connection");
    var kCancellationToken = Symbol("cancellationToken");
    var kRTTPinger = Symbol("rttPinger");
    var kRoundTripTime = Symbol("roundTripTime");
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_IDLE = "idle";
    var STATE_MONITORING = "monitoring";
    var stateTransition = makeStateMachine({
      [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],
      [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],
      [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],
      [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]
    });
    var INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);
    function isInCloseState(monitor) {
      return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;
    }
    var Monitor = class extends EventEmitter {
      constructor(server, options2) {
        super(options2);
        this[kServer] = server;
        this[kConnection] = void 0;
        this[kCancellationToken] = new EventEmitter();
        this[kCancellationToken].setMaxListeners(Infinity);
        this[kMonitorId] = null;
        this.s = {
          state: STATE_CLOSED
        };
        this.address = server.description.address;
        this.options = Object.freeze({
          connectTimeoutMS: typeof options2.connectionTimeout === "number" ? options2.connectionTimeout : typeof options2.connectTimeoutMS === "number" ? options2.connectTimeoutMS : 1e4,
          heartbeatFrequencyMS: typeof options2.heartbeatFrequencyMS === "number" ? options2.heartbeatFrequencyMS : 1e4,
          minHeartbeatFrequencyMS: typeof options2.minHeartbeatFrequencyMS === "number" ? options2.minHeartbeatFrequencyMS : 500
        });
        const connectOptions = Object.assign({
          id: "<monitor>",
          host: server.description.host,
          port: server.description.port,
          bson: server.s.bson,
          connectionType: Connection
        }, server.s.options, this.options, {
          raw: false,
          promoteLongs: true,
          promoteValues: true,
          promoteBuffers: true
        });
        delete connectOptions.credentials;
        delete connectOptions.autoEncrypter;
        this.connectOptions = Object.freeze(connectOptions);
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS,
          immediate: true
        });
      }
      requestCheck() {
        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
          return;
        }
        this[kMonitorId].wake();
      }
      reset() {
        const topologyVersion = this[kServer].description.topologyVersion;
        if (isInCloseState(this) || topologyVersion == null) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        stateTransition(this, STATE_IDLE);
        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
        this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {
          interval: heartbeatFrequencyMS,
          minInterval: minHeartbeatFrequencyMS
        });
      }
      close() {
        if (isInCloseState(this)) {
          return;
        }
        stateTransition(this, STATE_CLOSING);
        resetMonitorState(this);
        this.emit("close");
        stateTransition(this, STATE_CLOSED);
      }
    };
    function resetMonitorState(monitor) {
      if (monitor[kMonitorId]) {
        monitor[kMonitorId].stop();
        monitor[kMonitorId] = null;
      }
      if (monitor[kRTTPinger]) {
        monitor[kRTTPinger].close();
        monitor[kRTTPinger] = void 0;
      }
      monitor[kCancellationToken].emit("cancel");
      if (monitor[kMonitorId]) {
        clearTimeout(monitor[kMonitorId]);
        monitor[kMonitorId] = void 0;
      }
      if (monitor[kConnection]) {
        monitor[kConnection].destroy({ force: true });
      }
    }
    function checkServer(monitor, callback) {
      let start = now();
      monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
      function failureHandler(err) {
        if (monitor[kConnection]) {
          monitor[kConnection].destroy({ force: true });
          monitor[kConnection] = void 0;
        }
        monitor.emit("serverHeartbeatFailed", new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));
        monitor.emit("resetServer", err);
        monitor.emit("resetConnectionPool");
        callback(err);
      }
      if (monitor[kConnection] != null && !monitor[kConnection].closed) {
        const connectTimeoutMS = monitor.options.connectTimeoutMS;
        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
        const topologyVersion = monitor[kServer].description.topologyVersion;
        const isAwaitable = topologyVersion != null;
        const cmd = { ismaster: true };
        const options2 = { socketTimeout: connectTimeoutMS };
        if (isAwaitable) {
          cmd.maxAwaitTimeMS = maxAwaitTimeMS;
          cmd.topologyVersion = makeTopologyVersion(topologyVersion);
          if (connectTimeoutMS) {
            options2.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;
          }
          options2.exhaustAllowed = true;
          if (monitor[kRTTPinger] == null) {
            monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);
          }
        }
        monitor[kConnection].command("admin.$cmd", cmd, options2, (err, result) => {
          if (err) {
            failureHandler(err);
            return;
          }
          const isMaster = result.result;
          const rttPinger = monitor[kRTTPinger];
          const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);
          monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address));
          if (isAwaitable && isMaster.topologyVersion) {
            monitor.emit("serverHeartbeatStarted", new ServerHeartbeatStartedEvent(monitor.address));
            start = now();
          } else {
            if (monitor[kRTTPinger]) {
              monitor[kRTTPinger].close();
              monitor[kRTTPinger] = void 0;
            }
            callback(void 0, isMaster);
          }
        });
        return;
      }
      connect2(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {
        if (conn && isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        if (err) {
          monitor[kConnection] = void 0;
          if (!(err instanceof MongoNetworkError)) {
            monitor.emit("resetConnectionPool");
          }
          failureHandler(err);
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit("serverHeartbeatSucceeded", new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));
        callback(void 0, conn.ismaster);
      });
    }
    function monitorServer(monitor) {
      return (callback) => {
        stateTransition(monitor, STATE_MONITORING);
        function done() {
          if (!isInCloseState(monitor)) {
            stateTransition(monitor, STATE_IDLE);
          }
          callback();
        }
        process.nextTick(() => monitor.emit("monitoring", monitor[kServer]));
        checkServer(monitor, (err, isMaster) => {
          if (err) {
            if (monitor[kServer].description.type === ServerType.Unknown) {
              monitor.emit("resetServer", err);
              return done();
            }
          }
          if (isMaster && isMaster.topologyVersion) {
            setTimeout(() => {
              if (!isInCloseState(monitor)) {
                monitor[kMonitorId].wake();
              }
            });
          }
          done();
        });
      };
    }
    function makeTopologyVersion(tv) {
      return {
        processId: tv.processId,
        counter: BSON2.Long.fromNumber(tv.counter)
      };
    }
    var RTTPinger = class {
      constructor(cancellationToken, options2) {
        this[kConnection] = null;
        this[kCancellationToken] = cancellationToken;
        this[kRoundTripTime] = 0;
        this.closed = false;
        const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
        this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options2), heartbeatFrequencyMS);
      }
      get roundTripTime() {
        return this[kRoundTripTime];
      }
      close() {
        this.closed = true;
        clearTimeout(this[kMonitorId]);
        this[kMonitorId] = void 0;
        if (this[kConnection]) {
          this[kConnection].destroy({ force: true });
        }
      }
    };
    function measureRoundTripTime(rttPinger, options2) {
      const start = now();
      const cancellationToken = rttPinger[kCancellationToken];
      const heartbeatFrequencyMS = options2.heartbeatFrequencyMS;
      if (rttPinger.closed) {
        return;
      }
      function measureAndReschedule(conn) {
        if (rttPinger.closed) {
          conn.destroy({ force: true });
          return;
        }
        if (rttPinger[kConnection] == null) {
          rttPinger[kConnection] = conn;
        }
        rttPinger[kRoundTripTime] = calculateDurationInMs(start);
        rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options2), heartbeatFrequencyMS);
      }
      if (rttPinger[kConnection] == null) {
        connect2(options2, cancellationToken, (err, conn) => {
          if (err) {
            rttPinger[kConnection] = void 0;
            rttPinger[kRoundTripTime] = 0;
            return;
          }
          measureAndReschedule(conn);
        });
        return;
      }
      rttPinger[kConnection].command("admin.$cmd", { ismaster: 1 }, (err) => {
        if (err) {
          rttPinger[kConnection] = void 0;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule();
      });
    }
    module2.exports = {
      Monitor
    };
  }
});

// node_modules/mongodb/lib/core/sdam/server.js
var require_server2 = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events");
    var ConnectionPool = require_connection_pool().ConnectionPool;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var MongoError = require_error().MongoError;
    var relayEvents = require_utils2().relayEvents;
    var BSON2 = require_utils3().retrieveBSON();
    var Logger = require_logger();
    var ServerDescription = require_server_description().ServerDescription;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var ReadPreference = require_read_preference();
    var Monitor = require_monitor().Monitor;
    var MongoNetworkError = require_error().MongoNetworkError;
    var MongoNetworkTimeoutError = require_error().MongoNetworkTimeoutError;
    var collationNotSupported = require_utils2().collationNotSupported;
    var debugOptions = require_utils3().debugOptions;
    var isSDAMUnrecoverableError = require_error().isSDAMUnrecoverableError;
    var isRetryableWriteError = require_error().isRetryableWriteError;
    var isNodeShuttingDownError = require_error().isNodeShuttingDownError;
    var isNetworkErrorBeforeHandshake = require_error().isNetworkErrorBeforeHandshake;
    var maxWireVersion = require_utils2().maxWireVersion;
    var makeStateMachine = require_utils2().makeStateMachine;
    var common = require_common();
    var ServerType = common.ServerType;
    var isTransactionCommand = require_transactions().isTransactionCommand;
    var DEBUG_FIELDS = [
      "reconnect",
      "reconnectTries",
      "reconnectInterval",
      "emitError",
      "cursorFactory",
      "host",
      "port",
      "size",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectionTimeout",
      "checkServerIdentity",
      "socketTimeout",
      "ssl",
      "ca",
      "crl",
      "cert",
      "key",
      "rejectUnauthorized",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "servername"
    ];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var kMonitor = Symbol("monitor");
    var Server = class extends EventEmitter {
      constructor(description, options2, topology) {
        super();
        this.s = {
          description,
          options: options2,
          logger: Logger("Server", options2),
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          state: STATE_CLOSED,
          credentials: options2.credentials,
          topology
        };
        const poolOptions = Object.assign({ host: this.description.host, port: this.description.port, bson: this.s.bson }, options2);
        this.s.pool = new ConnectionPool(poolOptions);
        relayEvents(this.s.pool, this, ["commandStarted", "commandSucceeded", "commandFailed"].concat(CMAP_EVENT_NAMES));
        this.s.pool.on("clusterTimeReceived", (clusterTime) => {
          this.clusterTime = clusterTime;
        });
        this[kMonitor] = new Monitor(this, this.s.options);
        relayEvents(this[kMonitor], this, [
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "monitoring"
        ]);
        this[kMonitor].on("resetConnectionPool", () => {
          this.s.pool.clear();
        });
        this[kMonitor].on("resetServer", (error3) => markServerUnknown(this, error3));
        this[kMonitor].on("serverHeartbeatSucceeded", (event) => {
          this.emit("descriptionReceived", new ServerDescription(this.description.address, event.reply, {
            roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
          }));
          if (this.s.state === STATE_CONNECTING) {
            stateTransition(this, STATE_CONNECTED);
            this.emit("connect", this);
          }
        });
      }
      get description() {
        return this.s.description;
      }
      get name() {
        return this.s.description.address;
      }
      get autoEncrypter() {
        if (this.s.options && this.s.options.autoEncrypter) {
          return this.s.options.autoEncrypter;
        }
        return null;
      }
      connect() {
        if (this.s.state !== STATE_CLOSED) {
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this[kMonitor].connect();
      }
      destroy(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, { force: false }, options2);
        if (this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        this[kMonitor].close();
        this.s.pool.close(options2, (err) => {
          stateTransition(this, STATE_CLOSED);
          this.emit("closed");
          if (typeof callback === "function") {
            callback(err);
          }
        });
      }
      requestCheck() {
        this[kMonitor].requestCheck();
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        const error3 = basicReadValidations(this, options2);
        if (error3) {
          return callback(error3);
        }
        options2 = Object.assign({}, options2, { wireProtocolCommand: false });
        if (this.s.logger.isDebug()) {
          this.s.logger.debug(`executing command [${JSON.stringify({
            ns,
            cmd,
            options: debugOptions(DEBUG_FIELDS, options2)
          })}] against ${this.name}`);
        }
        if (collationNotSupported(this, cmd)) {
          callback(new MongoError(`server ${this.name} does not support collation`));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.command(ns, cmd, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      query(ns, cmd, cursorState, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.query(ns, cmd, cursorState, options2, makeOperationHandler(this, conn, cmd, options2, cb));
        }, callback);
      }
      getMore(ns, cursorState, batchSize, options2, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          callback(new MongoError("server is closed"));
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.getMore(ns, cursorState, batchSize, options2, makeOperationHandler(this, conn, null, options2, cb));
        }, callback);
      }
      killCursors(ns, cursorState, callback) {
        if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {
          if (typeof callback === "function") {
            callback(new MongoError("server is closed"));
          }
          return;
        }
        this.s.pool.withConnection((err, conn, cb) => {
          if (err) {
            markServerUnknown(this, err);
            return cb(err);
          }
          conn.killCursors(ns, cursorState, makeOperationHandler(this, conn, null, void 0, cb));
        }, callback);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "insert", ns, ops }, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "update", ns, ops }, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({ server: this, op: "remove", ns, ops }, options2, callback);
      }
    };
    Object.defineProperty(Server.prototype, "clusterTime", {
      get: function() {
        return this.s.topology.clusterTime;
      },
      set: function(clusterTime) {
        this.s.topology.clusterTime = clusterTime;
      }
    });
    function supportsRetryableWrites(server) {
      return server.description.maxWireVersion >= 6 && server.description.logicalSessionTimeoutMinutes && server.description.type !== ServerType.Standalone;
    }
    function calculateRoundTripTime(oldRtt, duration) {
      if (oldRtt === -1) {
        return duration;
      }
      const alpha = 0.2;
      return alpha * duration + (1 - alpha) * oldRtt;
    }
    function basicReadValidations(server, options2) {
      if (options2.readPreference && !(options2.readPreference instanceof ReadPreference)) {
        return new MongoError("readPreference must be an instance of ReadPreference");
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const server = args.server;
      const op = args.op;
      const ns = args.ns;
      const ops = Array.isArray(args.ops) ? args.ops : [args.ops];
      if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {
        callback(new MongoError("server is closed"));
        return;
      }
      if (collationNotSupported(server, options2)) {
        callback(new MongoError(`server ${server.name} does not support collation`));
        return;
      }
      const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
      if (unacknowledgedWrite || maxWireVersion(server) < 5) {
        if ((op === "update" || op === "remove") && ops.find((o) => o.hint)) {
          callback(new MongoError(`servers < 3.4 do not support hint on ${op}`));
          return;
        }
      }
      server.s.pool.withConnection((err, conn, cb) => {
        if (err) {
          markServerUnknown(server, err);
          return cb(err);
        }
        conn[op](ns, ops, options2, makeOperationHandler(server, conn, ops, options2, cb));
      }, callback);
    }
    function markServerUnknown(server, error3) {
      if (error3 instanceof MongoNetworkError && !(error3 instanceof MongoNetworkTimeoutError)) {
        server[kMonitor].reset();
      }
      server.emit("descriptionReceived", new ServerDescription(server.description.address, null, {
        error: error3,
        topologyVersion: error3 && error3.topologyVersion ? error3.topologyVersion : server.description.topologyVersion
      }));
    }
    function connectionIsStale(pool, connection2) {
      return connection2.generation !== pool.generation;
    }
    function shouldHandleStateChangeError(server, err) {
      const etv = err.topologyVersion;
      const stv = server.description.topologyVersion;
      return compareTopologyVersion(stv, etv) < 0;
    }
    function inActiveTransaction(session, cmd) {
      return session && session.inTransaction() && !isTransactionCommand(cmd);
    }
    function makeOperationHandler(server, connection2, cmd, options2, callback) {
      const session = options2 && options2.session;
      return function handleOperationResult(err, result) {
        if (err && !connectionIsStale(server.s.pool, connection2)) {
          if (err instanceof MongoNetworkError) {
            if (session && !session.hasEnded) {
              session.serverSession.isDirty = true;
            }
            if (supportsRetryableWrites(server) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (!(err instanceof MongoNetworkTimeoutError) || isNetworkErrorBeforeHandshake(err)) {
              markServerUnknown(server, err);
              server.s.pool.clear();
            }
          } else {
            if (maxWireVersion(server) < 9 && isRetryableWriteError(err) && !inActiveTransaction(session, cmd)) {
              err.addErrorLabel("RetryableWriteError");
            }
            if (isSDAMUnrecoverableError(err)) {
              if (shouldHandleStateChangeError(server, err)) {
                if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {
                  server.s.pool.clear();
                }
                markServerUnknown(server, err);
                process.nextTick(() => server.requestCheck());
              }
            }
          }
        }
        callback(err, result);
      };
    }
    module2.exports = {
      Server
    };
  }
});

// node_modules/mongodb/lib/core/sdam/srv_polling.js
var require_srv_polling = __commonJS({
  "node_modules/mongodb/lib/core/sdam/srv_polling.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Logger = require_logger();
    var EventEmitter = __require("events").EventEmitter;
    var dns = __require("dns");
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    var SrvPollingEvent = class {
      constructor(srvRecords) {
        this.srvRecords = srvRecords;
      }
      addresses() {
        return new Set(this.srvRecords.map((record) => `${record.name}:${record.port}`));
      }
    };
    var SrvPoller = class extends EventEmitter {
      constructor(options2) {
        super();
        if (!options2 || !options2.srvHost) {
          throw new TypeError("options for SrvPoller must exist and include srvHost");
        }
        this.srvHost = options2.srvHost;
        this.rescanSrvIntervalMS = 6e4;
        this.heartbeatFrequencyMS = options2.heartbeatFrequencyMS || 1e4;
        this.logger = Logger("srvPoller", options2);
        this.haMode = false;
        this.generation = 0;
        this._timeout = null;
      }
      get srvAddress() {
        return `_mongodb._tcp.${this.srvHost}`;
      }
      get intervalMS() {
        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
      }
      start() {
        if (!this._timeout) {
          this.schedule();
        }
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
          this.generation += 1;
          this._timeout = null;
        }
      }
      schedule() {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(() => this._poll(), this.intervalMS);
      }
      success(srvRecords) {
        this.haMode = false;
        this.schedule();
        this.emit("srvRecordDiscovery", new SrvPollingEvent(srvRecords));
      }
      failure(message, obj) {
        this.logger.warn(message, obj);
        this.haMode = true;
        this.schedule();
      }
      parentDomainMismatch(srvRecord) {
        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);
      }
      _poll() {
        const generation = this.generation;
        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {
          if (generation !== this.generation) {
            return;
          }
          if (err) {
            this.failure("DNS error", err);
            return;
          }
          const finalAddresses = [];
          srvRecords.forEach((record) => {
            if (matchesParentDomain(record.name, this.srvHost)) {
              finalAddresses.push(record);
            } else {
              this.parentDomainMismatch(record);
            }
          });
          if (!finalAddresses.length) {
            this.failure("No valid addresses found at host");
            return;
          }
          this.success(finalAddresses);
        });
      }
    };
    module2.exports.SrvPollingEvent = SrvPollingEvent;
    module2.exports.SrvPoller = SrvPoller;
  }
});

// node_modules/mongodb/lib/core/sdam/server_selection.js
var require_server_selection = __commonJS({
  "node_modules/mongodb/lib/core/sdam/server_selection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ServerType = require_common().ServerType;
    var TopologyType = require_common().TopologyType;
    var ReadPreference = require_read_preference();
    var MongoError = require_error().MongoError;
    var IDLE_WRITE_PERIOD = 1e4;
    var SMALLEST_MAX_STALENESS_SECONDS = 90;
    function writableServerSelector() {
      return function(topologyDescription, servers) {
        return latencyWindowReducer(topologyDescription, servers.filter((s3) => s3.isWritable));
      };
    }
    function maxStalenessReducer(readPreference, topologyDescription, servers) {
      if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
        return servers;
      }
      const maxStaleness = readPreference.maxStalenessSeconds;
      const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1e3;
      if (maxStaleness < maxStalenessVariance) {
        throw new MongoError(`maxStalenessSeconds must be at least ${maxStalenessVariance} seconds`);
      }
      if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
        throw new MongoError(`maxStalenessSeconds must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {
        const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
        return servers.reduce((result, server) => {
          const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {
        if (servers.length === 0) {
          return servers;
        }
        const sMax = servers.reduce((max, s3) => s3.lastWriteDate > max.lastWriteDate ? s3 : max);
        return servers.reduce((result, server) => {
          const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
          const staleness = stalenessMS / 1e3;
          if (staleness <= readPreference.maxStalenessSeconds)
            result.push(server);
          return result;
        }, []);
      }
      return servers;
    }
    function tagSetMatch(tagSet, serverTags) {
      const keys = Object.keys(tagSet);
      const serverTagKeys = Object.keys(serverTags);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
          return false;
        }
      }
      return true;
    }
    function tagSetReducer(readPreference, servers) {
      if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
        return servers;
      }
      for (let i = 0; i < readPreference.tags.length; ++i) {
        const tagSet = readPreference.tags[i];
        const serversMatchingTagset = servers.reduce((matched, server) => {
          if (tagSetMatch(tagSet, server.tags))
            matched.push(server);
          return matched;
        }, []);
        if (serversMatchingTagset.length) {
          return serversMatchingTagset;
        }
      }
      return [];
    }
    function latencyWindowReducer(topologyDescription, servers) {
      const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
      const high = low + topologyDescription.localThresholdMS;
      return servers.reduce((result, server) => {
        if (server.roundTripTime <= high && server.roundTripTime >= low)
          result.push(server);
        return result;
      }, []);
    }
    function primaryFilter(server) {
      return server.type === ServerType.RSPrimary;
    }
    function secondaryFilter(server) {
      return server.type === ServerType.RSSecondary;
    }
    function nearestFilter(server) {
      return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;
    }
    function knownFilter(server) {
      return server.type !== ServerType.Unknown;
    }
    function readPreferenceServerSelector(readPreference) {
      if (!readPreference.isValid()) {
        throw new TypeError("Invalid read preference specified");
      }
      return function(topologyDescription, servers) {
        const commonWireVersion = topologyDescription.commonWireVersion;
        if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
          throw new MongoError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
        }
        if (topologyDescription.type === TopologyType.Unknown) {
          return [];
        }
        if (topologyDescription.type === TopologyType.Single || topologyDescription.type === TopologyType.Sharded) {
          return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
        }
        const mode = readPreference.mode;
        if (mode === ReadPreference.PRIMARY) {
          return servers.filter(primaryFilter);
        }
        if (mode === ReadPreference.PRIMARY_PREFERRED) {
          const result = servers.filter(primaryFilter);
          if (result.length) {
            return result;
          }
        }
        const filter2 = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
        const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter2))));
        if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
          return servers.filter(primaryFilter);
        }
        return selectedServers;
      };
    }
    module2.exports = {
      writableServerSelector,
      readPreferenceServerSelector
    };
  }
});

// node_modules/mongodb/lib/core/sdam/topology.js
var require_topology = __commonJS({
  "node_modules/mongodb/lib/core/sdam/topology.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events");
    var ServerDescription = require_server_description().ServerDescription;
    var ServerType = require_common().ServerType;
    var TopologyDescription = require_topology_description().TopologyDescription;
    var TopologyType = require_common().TopologyType;
    var events = require_events();
    var Server = require_server2().Server;
    var relayEvents = require_utils2().relayEvents;
    var ReadPreference = require_read_preference();
    var isRetryableWritesSupported = require_shared2().isRetryableWritesSupported;
    var CoreCursor = require_cursor().CoreCursor;
    var deprecate = __require("util").deprecate;
    var BSON2 = require_utils3().retrieveBSON();
    var createCompressionInfo = require_shared2().createCompressionInfo;
    var ClientSession = require_sessions().ClientSession;
    var MongoError = require_error().MongoError;
    var MongoServerSelectionError = require_error().MongoServerSelectionError;
    var resolveClusterTime = require_shared2().resolveClusterTime;
    var SrvPoller = require_srv_polling().SrvPoller;
    var getMMAPError = require_shared2().getMMAPError;
    var makeStateMachine = require_utils2().makeStateMachine;
    var eachAsync = require_utils2().eachAsync;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var ServerSessionPool = require_sessions().ServerSessionPool;
    var makeClientMetadata = require_utils2().makeClientMetadata;
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var compareTopologyVersion = require_server_description().compareTopologyVersion;
    var emitWarning = require_utils4().emitWarning;
    var common = require_common();
    var drainTimerQueue = common.drainTimerQueue;
    var clearAndRemoveTimerFrom = common.clearAndRemoveTimerFrom;
    var serverSelection = require_server_selection();
    var readPreferenceServerSelector = serverSelection.readPreferenceServerSelector;
    var writableServerSelector = serverSelection.writableServerSelector;
    var globalTopologyCounter = 0;
    var SERVER_RELAY_EVENTS = [
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "monitoring"
    ].concat(CMAP_EVENT_NAMES);
    var LOCAL_SERVER_EVENTS = ["connect", "descriptionReceived", "close", "ended"];
    var STATE_CLOSING = common.STATE_CLOSING;
    var STATE_CLOSED = common.STATE_CLOSED;
    var STATE_CONNECTING = common.STATE_CONNECTING;
    var STATE_CONNECTED = common.STATE_CONNECTED;
    var stateTransition = makeStateMachine({
      [STATE_CLOSED]: [STATE_CLOSED, STATE_CONNECTING],
      [STATE_CONNECTING]: [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED],
      [STATE_CONNECTED]: [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED],
      [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED]
    });
    var DEPRECATED_OPTIONS = new Set([
      "autoReconnect",
      "reconnectTries",
      "reconnectInterval",
      "bufferMaxEntries"
    ]);
    var kCancelled = Symbol("cancelled");
    var kWaitQueue = Symbol("waitQueue");
    var Topology = class extends EventEmitter {
      constructor(seedlist, options2) {
        super();
        if (typeof options2 === "undefined" && typeof seedlist !== "string") {
          options2 = seedlist;
          seedlist = [];
          if (options2.host) {
            seedlist.push({ host: options2.host, port: options2.port });
          }
        }
        seedlist = seedlist || [];
        if (typeof seedlist === "string") {
          seedlist = parseStringSeedlist(seedlist);
        }
        options2 = Object.assign({}, common.TOPOLOGY_DEFAULTS, options2);
        options2 = Object.freeze(Object.assign(options2, {
          metadata: makeClientMetadata(options2),
          compression: { compressors: createCompressionInfo(options2) }
        }));
        DEPRECATED_OPTIONS.forEach((optionName) => {
          if (options2[optionName]) {
            emitDeprecationWarning(`The option \`${optionName}\` is incompatible with the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
          }
        });
        const topologyType = topologyTypeFromSeedlist(seedlist, options2);
        const topologyId = globalTopologyCounter++;
        const serverDescriptions = seedlist.reduce((result, seed) => {
          if (seed.domain_socket)
            seed.host = seed.domain_socket;
          const address = seed.port ? `${seed.host}:${seed.port}` : `${seed.host}:27017`;
          result.set(address, new ServerDescription(address));
          return result;
        }, new Map());
        this[kWaitQueue] = new Denque();
        this.s = {
          id: topologyId,
          options: options2,
          seedlist,
          state: STATE_CLOSED,
          description: new TopologyDescription(topologyType, serverDescriptions, options2.replicaSet, null, null, null, options2),
          serverSelectionTimeoutMS: options2.serverSelectionTimeoutMS,
          heartbeatFrequencyMS: options2.heartbeatFrequencyMS,
          minHeartbeatFrequencyMS: options2.minHeartbeatFrequencyMS,
          Cursor: options2.cursorFactory || CoreCursor,
          bson: options2.bson || new BSON2([
            BSON2.Binary,
            BSON2.Code,
            BSON2.DBRef,
            BSON2.Decimal128,
            BSON2.Double,
            BSON2.Int32,
            BSON2.Long,
            BSON2.Map,
            BSON2.MaxKey,
            BSON2.MinKey,
            BSON2.ObjectId,
            BSON2.BSONRegExp,
            BSON2.Symbol,
            BSON2.Timestamp
          ]),
          servers: new Map(),
          sessionPool: new ServerSessionPool(this),
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise,
          credentials: options2.credentials,
          clusterTime: null,
          connectionTimers: new Set()
        };
        if (options2.srvHost) {
          this.s.srvPoller = options2.srvPoller || new SrvPoller({
            heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
            srvHost: options2.srvHost,
            logger: options2.logger,
            loggerLevel: options2.loggerLevel
          });
          this.s.detectTopologyDescriptionChange = (ev) => {
            const previousType = ev.previousDescription.type;
            const newType = ev.newDescription.type;
            if (previousType !== TopologyType.Sharded && newType === TopologyType.Sharded) {
              this.s.handleSrvPolling = srvPollingHandler(this);
              this.s.srvPoller.on("srvRecordDiscovery", this.s.handleSrvPolling);
              this.s.srvPoller.start();
            }
          };
          this.on("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
        }
        this.setMaxListeners(Infinity);
      }
      get description() {
        return this.s.description;
      }
      get parserType() {
        return BSON2.native ? "c++" : "js";
      }
      connect(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (this.s.state === STATE_CONNECTED) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CONNECTING);
        this.emit("topologyOpening", new events.TopologyOpeningEvent(this.s.id));
        this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, new TopologyDescription(TopologyType.Unknown), this.s.description));
        connectServers(this, Array.from(this.s.description.servers.values()));
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        const connectHandler = (err) => {
          if (err) {
            this.close();
            if (typeof callback === "function") {
              callback(err);
            } else {
              this.emit("error", err);
            }
            return;
          }
          stateTransition(this, STATE_CONNECTED);
          this.emit("open", err, this);
          this.emit("connect", this);
          if (typeof callback === "function")
            callback(err, this);
        };
        if (this.s.credentials) {
          this.command("admin.$cmd", { ping: 1 }, { readPreference }, connectHandler);
          return;
        }
        this.selectServer(readPreferenceServerSelector(readPreference), options2, connectHandler);
      }
      close(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (typeof options2 === "boolean") {
          options2 = { force: options2 };
        }
        options2 = options2 || {};
        if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {
          if (typeof callback === "function") {
            callback();
          }
          return;
        }
        stateTransition(this, STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new MongoError("Topology closed"));
        drainTimerQueue(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          if (this.s.handleSrvPolling) {
            this.s.srvPoller.removeListener("srvRecordDiscovery", this.s.handleSrvPolling);
            delete this.s.handleSrvPolling;
          }
        }
        if (this.s.detectTopologyDescriptionChange) {
          this.removeListener("topologyDescriptionChanged", this.s.detectTopologyDescriptionChange);
          delete this.s.detectTopologyDescriptionChange;
        }
        this.s.sessions.forEach((session) => session.endSession());
        this.s.sessionPool.endAllPooledSessions(() => {
          eachAsync(Array.from(this.s.servers.values()), (server, cb) => destroyServer(server, this, options2, cb), (err) => {
            this.s.servers.clear();
            this.emit("topologyClosed", new events.TopologyClosedEvent(this.s.id));
            stateTransition(this, STATE_CLOSED);
            if (typeof callback === "function") {
              callback(err);
            }
          });
        });
      }
      selectServer(selector, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          if (typeof selector !== "function") {
            options2 = selector;
            let readPreference;
            if (selector instanceof ReadPreference) {
              readPreference = selector;
            } else if (typeof selector === "string") {
              readPreference = new ReadPreference(selector);
            } else {
              ReadPreference.translate(options2);
              readPreference = options2.readPreference || ReadPreference.primary;
            }
            selector = readPreferenceServerSelector(readPreference);
          } else {
            options2 = {};
          }
        }
        options2 = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options2);
        const isSharded = this.description.type === TopologyType.Sharded;
        const session = options2.session;
        const transaction = session && session.transaction;
        if (isSharded && transaction && transaction.server) {
          callback(void 0, transaction.server);
          return;
        }
        let serverSelector = selector;
        if (typeof selector === "object") {
          const readPreference = selector.readPreference ? selector.readPreference : ReadPreference.primary;
          serverSelector = readPreferenceServerSelector(readPreference);
        }
        const waitQueueMember = {
          serverSelector,
          transaction,
          callback
        };
        const serverSelectionTimeoutMS = options2.serverSelectionTimeoutMS;
        if (serverSelectionTimeoutMS) {
          waitQueueMember.timer = setTimeout(() => {
            waitQueueMember[kCancelled] = true;
            waitQueueMember.timer = void 0;
            const timeoutError = new MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
            waitQueueMember.callback(timeoutError);
          }, serverSelectionTimeoutMS);
        }
        this[kWaitQueue].push(waitQueueMember);
        processWaitQueue(this);
      }
      shouldCheckForSessionSupport() {
        if (this.description.type === TopologyType.Single) {
          return !this.description.hasKnownServers;
        }
        return !this.description.hasDataBearingServers;
      }
      hasSessionSupport() {
        return this.description.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        if (!Array.isArray(sessions)) {
          sessions = [sessions];
        }
        this.command("admin.$cmd", { endSessions: sessions }, { readPreference: ReadPreference.primaryPreferred, noResponse: true }, () => {
          if (typeof callback === "function")
            callback();
        });
      }
      serverUpdateHandler(serverDescription) {
        if (!this.s.description.hasServer(serverDescription.address)) {
          return;
        }
        if (isStaleServerDescription(this.s.description, serverDescription)) {
          return;
        }
        const previousTopologyDescription = this.s.description;
        const previousServerDescription = this.s.description.servers.get(serverDescription.address);
        const clusterTime = serverDescription.$clusterTime;
        if (clusterTime) {
          resolveClusterTime(this, clusterTime);
        }
        const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
        this.s.description = this.s.description.update(serverDescription);
        if (this.s.description.compatibilityError) {
          this.emit("error", new MongoError(this.s.description.compatibilityError));
          return;
        }
        if (!equalDescriptions) {
          this.emit("serverDescriptionChanged", new events.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, this.s.description.servers.get(serverDescription.address)));
        }
        updateServers(this, serverDescription);
        if (this[kWaitQueue].length > 0) {
          processWaitQueue(this);
        }
        if (!equalDescriptions) {
          this.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
        }
      }
      auth(credentials, callback) {
        if (typeof credentials === "function")
          callback = credentials, credentials = null;
        if (typeof callback === "function")
          callback(null, true);
      }
      logout(callback) {
        if (typeof callback === "function")
          callback(null, true);
      }
      insert(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "insert", ns, ops }, options2, callback);
      }
      update(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "update", ns, ops }, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        executeWriteOperation({ topology: this, op: "remove", ns, ops }, options2, callback);
      }
      command(ns, cmd, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2, options2 = {}, options2 = options2 || {};
        }
        ReadPreference.translate(options2);
        const readPreference = options2.readPreference || ReadPreference.primary;
        this.selectServer(readPreferenceServerSelector(readPreference), options2, (err, server) => {
          if (err) {
            callback(err);
            return;
          }
          const willRetryWrite = !options2.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(this) && !options2.session.inTransaction() && isWriteCommand(cmd);
          const cb = (err2, result) => {
            if (!err2)
              return callback(null, result);
            if (!shouldRetryOperation(err2)) {
              return callback(err2);
            }
            if (willRetryWrite) {
              const newOptions = Object.assign({}, options2, { retrying: true });
              return this.command(ns, cmd, newOptions, callback);
            }
            return callback(err2);
          };
          if (willRetryWrite) {
            options2.session.incrementTransactionNumber();
            options2.willRetryWrite = willRetryWrite;
          }
          server.command(ns, cmd, options2, cb);
        });
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        const topology = options2.topology || this;
        const CursorClass = options2.cursorFactory || this.s.Cursor;
        ReadPreference.translate(options2);
        return new CursorClass(topology, ns, cmd, options2);
      }
      get clientMetadata() {
        return this.s.options.metadata;
      }
      isConnected() {
        return this.s.state === STATE_CONNECTED;
      }
      isDestroyed() {
        return this.s.state === STATE_CLOSED;
      }
      unref() {
        emitWarning("not implemented: `unref`");
      }
      lastIsMaster() {
        const serverDescriptions = Array.from(this.description.servers.values());
        if (serverDescriptions.length === 0)
          return {};
        const sd = serverDescriptions.filter((sd2) => sd2.type !== ServerType.Unknown)[0];
        const result = sd || { maxWireVersion: this.description.commonWireVersion };
        return result;
      }
      get logicalSessionTimeoutMinutes() {
        return this.description.logicalSessionTimeoutMinutes;
      }
      get bson() {
        return this.s.bson;
      }
    };
    Object.defineProperty(Topology.prototype, "clusterTime", {
      enumerable: true,
      get: function() {
        return this.s.clusterTime;
      },
      set: function(clusterTime) {
        this.s.clusterTime = clusterTime;
      }
    });
    Topology.prototype.destroy = deprecate(Topology.prototype.close, "destroy() is deprecated, please use close() instead");
    var RETRYABLE_WRITE_OPERATIONS = ["findAndModify", "insert", "update", "delete"];
    function isWriteCommand(command) {
      return RETRYABLE_WRITE_OPERATIONS.some((op) => command[op]);
    }
    function isStaleServerDescription(topologyDescription, incomingServerDescription) {
      const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
      const currentTopologyVersion = currentServerDescription.topologyVersion;
      return compareTopologyVersion(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
    }
    function destroyServer(server, topology, options2, callback) {
      options2 = options2 || {};
      LOCAL_SERVER_EVENTS.forEach((event) => server.removeAllListeners(event));
      server.destroy(options2, () => {
        topology.emit("serverClosed", new events.ServerClosedEvent(topology.s.id, server.description.address));
        SERVER_RELAY_EVENTS.forEach((event) => server.removeAllListeners(event));
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    function parseStringSeedlist(seedlist) {
      return seedlist.split(",").map((seed) => ({
        host: seed.split(":")[0],
        port: seed.split(":")[1] || 27017
      }));
    }
    function topologyTypeFromSeedlist(seedlist, options2) {
      if (options2.directConnection) {
        return TopologyType.Single;
      }
      const replicaSet = options2.replicaSet || options2.setName || options2.rs_name;
      if (replicaSet == null) {
        return TopologyType.Unknown;
      }
      return TopologyType.ReplicaSetNoPrimary;
    }
    function randomSelection(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    function createAndConnectServer(topology, serverDescription, connectDelay) {
      topology.emit("serverOpening", new events.ServerOpeningEvent(topology.s.id, serverDescription.address));
      const server = new Server(serverDescription, topology.s.options, topology);
      relayEvents(server, topology, SERVER_RELAY_EVENTS);
      server.on("descriptionReceived", topology.serverUpdateHandler.bind(topology));
      if (connectDelay) {
        const connectTimer = setTimeout(() => {
          clearAndRemoveTimerFrom(connectTimer, topology.s.connectionTimers);
          server.connect();
        }, connectDelay);
        topology.s.connectionTimers.add(connectTimer);
        return server;
      }
      server.connect();
      return server;
    }
    function connectServers(topology, serverDescriptions) {
      topology.s.servers = serverDescriptions.reduce((servers, serverDescription) => {
        const server = createAndConnectServer(topology, serverDescription);
        servers.set(serverDescription.address, server);
        return servers;
      }, new Map());
    }
    function updateServers(topology, incomingServerDescription) {
      if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
        const server = topology.s.servers.get(incomingServerDescription.address);
        server.s.description = incomingServerDescription;
      }
      for (const serverDescription of topology.description.servers.values()) {
        if (!topology.s.servers.has(serverDescription.address)) {
          const server = createAndConnectServer(topology, serverDescription);
          topology.s.servers.set(serverDescription.address, server);
        }
      }
      for (const entry of topology.s.servers) {
        const serverAddress = entry[0];
        if (topology.description.hasServer(serverAddress)) {
          continue;
        }
        const server = topology.s.servers.get(serverAddress);
        topology.s.servers.delete(serverAddress);
        destroyServer(server, topology);
      }
    }
    function executeWriteOperation(args, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const topology = args.topology;
      const op = args.op;
      const ns = args.ns;
      const ops = args.ops;
      const willRetryWrite = !args.retrying && !!options2.retryWrites && options2.session && isRetryableWritesSupported(topology) && !options2.session.inTransaction() && options2.explain === void 0;
      topology.selectServer(writableServerSelector(), options2, (err, server) => {
        if (err) {
          callback(err, null);
          return;
        }
        const handler = (err2, result) => {
          if (!err2)
            return callback(null, result);
          if (!shouldRetryOperation(err2)) {
            err2 = getMMAPError(err2);
            return callback(err2);
          }
          if (willRetryWrite) {
            const newArgs = Object.assign({}, args, { retrying: true });
            return executeWriteOperation(newArgs, options2, callback);
          }
          return callback(err2);
        };
        if (callback.operationId) {
          handler.operationId = callback.operationId;
        }
        if (willRetryWrite) {
          options2.session.incrementTransactionNumber();
          options2.willRetryWrite = willRetryWrite;
        }
        server[op](ns, ops, options2, handler);
      });
    }
    function shouldRetryOperation(err) {
      return err instanceof MongoError && err.hasErrorLabel("RetryableWriteError");
    }
    function srvPollingHandler(topology) {
      return function handleSrvPolling(ev) {
        const previousTopologyDescription = topology.s.description;
        topology.s.description = topology.s.description.updateFromSrvPollingEvent(ev);
        if (topology.s.description === previousTopologyDescription) {
          return;
        }
        updateServers(topology);
        topology.emit("topologyDescriptionChanged", new events.TopologyDescriptionChangedEvent(topology.s.id, previousTopologyDescription, topology.s.description));
      };
    }
    function drainWaitQueue(queue, err) {
      while (queue.length) {
        const waitQueueMember = queue.shift();
        clearTimeout(waitQueueMember.timer);
        if (!waitQueueMember[kCancelled]) {
          waitQueueMember.callback(err);
        }
      }
    }
    function processWaitQueue(topology) {
      if (topology.s.state === STATE_CLOSED) {
        drainWaitQueue(topology[kWaitQueue], new MongoError("Topology is closed, please connect"));
        return;
      }
      const serverDescriptions = Array.from(topology.description.servers.values());
      const membersToProcess = topology[kWaitQueue].length;
      for (let i = 0; i < membersToProcess && topology[kWaitQueue].length; ++i) {
        const waitQueueMember = topology[kWaitQueue].shift();
        if (waitQueueMember[kCancelled]) {
          continue;
        }
        let selectedDescriptions;
        try {
          const serverSelector = waitQueueMember.serverSelector;
          selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
        } catch (e) {
          clearTimeout(waitQueueMember.timer);
          waitQueueMember.callback(e);
          continue;
        }
        if (selectedDescriptions.length === 0) {
          topology[kWaitQueue].push(waitQueueMember);
          continue;
        }
        const selectedServerDescription = randomSelection(selectedDescriptions);
        const selectedServer = topology.s.servers.get(selectedServerDescription.address);
        const transaction = waitQueueMember.transaction;
        const isSharded = topology.description.type === TopologyType.Sharded;
        if (isSharded && transaction && transaction.isActive) {
          transaction.pinServer(selectedServer);
        }
        clearTimeout(waitQueueMember.timer);
        waitQueueMember.callback(void 0, selectedServer);
      }
      if (topology[kWaitQueue].length > 0) {
        topology.s.servers.forEach((server) => process.nextTick(() => server.requestCheck()));
      }
    }
    module2.exports = {
      Topology
    };
  }
});

// node_modules/mongodb/lib/core/uri_parser.js
var require_uri_parser = __commonJS({
  "node_modules/mongodb/lib/core/uri_parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var URL2 = __require("url");
    var qs2 = __require("querystring");
    var dns = __require("dns");
    var MongoParseError = require_error().MongoParseError;
    var ReadPreference = require_read_preference();
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var HOSTS_RX = /(mongodb(?:\+srv|)):\/\/(?: (?:[^:]*) (?: : ([^@]*) )? @ )?([^/?]*)(?:\/|)(.*)/;
    var FILE_PATH_OPTIONS = new Set(["sslCA", "sslCert", "sslKey", "tlsCAFile", "tlsCertificateKeyFile"].map((key) => key.toLowerCase()));
    function matchesParentDomain(srvAddress, parentDomain) {
      const regex = /^.*?\./;
      const srv = `.${srvAddress.replace(regex, "")}`;
      const parent = `.${parentDomain.replace(regex, "")}`;
      return srv.endsWith(parent);
    }
    function parseSrvConnectionString(uri2, options2, callback) {
      const result = URL2.parse(uri2, true);
      if (options2.directConnection || options2.directconnection) {
        return callback(new MongoParseError("directConnection not supported with SRV URI"));
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new MongoParseError("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = uri2.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new MongoParseError("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new MongoParseError(`Ports not accepted with '${PROTOCOL_MONGODB_SRV}' URIs`));
      }
      const lookupAddress = result.host;
      dns.resolveSrv(`_mongodb._tcp.${lookupAddress}`, (err, addresses) => {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new MongoParseError("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new MongoParseError("Server record does not share hostname with parent URI"));
          }
        }
        result.protocol = "mongodb";
        result.host = addresses.map((address) => `${address.name}:${address.port}`).join(",");
        if (!("ssl" in options2) && (!result.search || !("ssl" in result.query) || result.query.ssl === null)) {
          result.query.ssl = true;
        }
        dns.resolveTxt(lookupAddress, (err2, record) => {
          if (err2) {
            if (err2.code !== "ENODATA" && err2.code !== "ENOTFOUND") {
              return callback(err2);
            }
            record = null;
          }
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = qs2.parse(record[0].join(""));
            if (Object.keys(record).some((key) => key !== "authSource" && key !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            result.query = Object.assign({}, record, result.query);
          }
          result.search = qs2.stringify(result.query);
          const finalString = URL2.format(result);
          parseConnectionString(finalString, options2, (err3, ret) => {
            if (err3) {
              callback(err3);
              return;
            }
            callback(null, Object.assign({}, ret, { srvHost: lookupAddress }));
          });
        });
      });
    }
    function parseQueryStringItemValue(key, value) {
      if (Array.isArray(value)) {
        value = value.filter((v, idx) => value.indexOf(v) === idx);
        if (value.length === 1)
          value = value[0];
      } else if (value.indexOf(":") > 0) {
        value = value.split(",").reduce((result, pair) => {
          const parts = pair.split(":");
          result[parts[0]] = parseQueryStringItemValue(key, parts[1]);
          return result;
        }, {});
      } else if (value.indexOf(",") > 0) {
        value = value.split(",").map((v) => {
          return parseQueryStringItemValue(key, v);
        });
      } else if (value.toLowerCase() === "true" || value.toLowerCase() === "false") {
        value = value.toLowerCase() === "true";
      } else if (!Number.isNaN(value) && !STRING_OPTIONS.has(key)) {
        const numericValue = parseFloat(value);
        if (!Number.isNaN(numericValue)) {
          value = parseFloat(value);
        }
      }
      return value;
    }
    var BOOLEAN_OPTIONS = new Set([
      "slaveok",
      "slave_ok",
      "sslvalidate",
      "fsync",
      "safe",
      "retrywrites",
      "j"
    ]);
    var STRING_OPTIONS = new Set(["authsource", "replicaset"]);
    var AUTH_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-AWS",
      "MONGODB-X509",
      "MONGODB-CR",
      "DEFAULT",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256",
      "PLAIN"
    ]);
    var CASE_TRANSLATION = {
      replicaset: "replicaSet",
      connecttimeoutms: "connectTimeoutMS",
      sockettimeoutms: "socketTimeoutMS",
      maxpoolsize: "maxPoolSize",
      minpoolsize: "minPoolSize",
      maxidletimems: "maxIdleTimeMS",
      waitqueuemultiple: "waitQueueMultiple",
      waitqueuetimeoutms: "waitQueueTimeoutMS",
      wtimeoutms: "wtimeoutMS",
      readconcern: "readConcern",
      readconcernlevel: "readConcernLevel",
      readpreference: "readPreference",
      maxstalenessseconds: "maxStalenessSeconds",
      readpreferencetags: "readPreferenceTags",
      authsource: "authSource",
      authmechanism: "authMechanism",
      authmechanismproperties: "authMechanismProperties",
      gssapiservicename: "gssapiServiceName",
      localthresholdms: "localThresholdMS",
      serverselectiontimeoutms: "serverSelectionTimeoutMS",
      serverselectiontryonce: "serverSelectionTryOnce",
      heartbeatfrequencyms: "heartbeatFrequencyMS",
      retrywrites: "retryWrites",
      uuidrepresentation: "uuidRepresentation",
      zlibcompressionlevel: "zlibCompressionLevel",
      tlsallowinvalidcertificates: "tlsAllowInvalidCertificates",
      tlsallowinvalidhostnames: "tlsAllowInvalidHostnames",
      tlsinsecure: "tlsInsecure",
      tlscafile: "tlsCAFile",
      tlscertificatekeyfile: "tlsCertificateKeyFile",
      tlscertificatekeyfilepassword: "tlsCertificateKeyFilePassword",
      wtimeout: "wTimeoutMS",
      j: "journal",
      directconnection: "directConnection"
    };
    function applyConnectionStringOption(obj, key, value, options2) {
      if (key === "journal") {
        key = "j";
      } else if (key === "wtimeoutms") {
        key = "wtimeout";
      }
      if (BOOLEAN_OPTIONS.has(key)) {
        value = value === "true" || value === true;
      } else if (key === "appname") {
        value = decodeURIComponent(value);
      } else if (key === "readconcernlevel") {
        obj["readConcernLevel"] = value;
        key = "readconcern";
        value = { level: value };
      }
      if (key === "compressors") {
        value = Array.isArray(value) ? value : [value];
        if (!value.every((c) => c === "snappy" || c === "zlib")) {
          throw new MongoParseError("Value for `compressors` must be at least one of: `snappy`, `zlib`");
        }
      }
      if (key === "authmechanism" && !AUTH_MECHANISMS.has(value)) {
        throw new MongoParseError(`Value for authMechanism must be one of: ${Array.from(AUTH_MECHANISMS).join(", ")}, found: ${value}`);
      }
      if (key === "readpreference" && !ReadPreference.isValid(value)) {
        throw new MongoParseError("Value for `readPreference` must be one of: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`, `nearest`");
      }
      if (key === "zlibcompressionlevel" && (value < -1 || value > 9)) {
        throw new MongoParseError("zlibCompressionLevel must be an integer between -1 and 9");
      }
      if (key === "compressors" || key === "zlibcompressionlevel") {
        obj.compression = obj.compression || {};
        obj = obj.compression;
      }
      if (key === "authmechanismproperties") {
        if (typeof value.SERVICE_NAME === "string")
          obj.gssapiServiceName = value.SERVICE_NAME;
        if (typeof value.SERVICE_REALM === "string")
          obj.gssapiServiceRealm = value.SERVICE_REALM;
        if (typeof value.CANONICALIZE_HOST_NAME !== "undefined") {
          obj.gssapiCanonicalizeHostName = value.CANONICALIZE_HOST_NAME;
        }
      }
      if (key === "readpreferencetags") {
        value = Array.isArray(value) ? splitArrayOfMultipleReadPreferenceTags(value) : [value];
      }
      if (options2.caseTranslate && CASE_TRANSLATION[key]) {
        obj[CASE_TRANSLATION[key]] = value;
        return;
      }
      obj[key] = value;
    }
    var USERNAME_REQUIRED_MECHANISMS = new Set([
      "GSSAPI",
      "MONGODB-CR",
      "PLAIN",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    function splitArrayOfMultipleReadPreferenceTags(value) {
      const parsedTags = [];
      for (let i = 0; i < value.length; i++) {
        parsedTags[i] = {};
        value[i].split(",").forEach((individualTag) => {
          const splitTag = individualTag.split(":");
          parsedTags[i][splitTag[0]] = splitTag[1];
        });
      }
      return parsedTags;
    }
    function applyAuthExpectations(parsed) {
      if (parsed.options == null) {
        return;
      }
      const options2 = parsed.options;
      const authSource = options2.authsource || options2.authSource;
      if (authSource != null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: authSource });
      }
      const authMechanism = options2.authmechanism || options2.authMechanism;
      if (authMechanism != null) {
        if (USERNAME_REQUIRED_MECHANISMS.has(authMechanism) && (!parsed.auth || parsed.auth.username == null)) {
          throw new MongoParseError(`Username required for mechanism \`${authMechanism}\``);
        }
        if (authMechanism === "GSSAPI") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-AWS") {
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "MONGODB-X509") {
          if (parsed.auth && parsed.auth.password != null) {
            throw new MongoParseError(`Password not allowed for mechanism \`${authMechanism}\``);
          }
          if (authSource != null && authSource !== "$external") {
            throw new MongoParseError(`Invalid source \`${authSource}\` for mechanism \`${authMechanism}\` specified.`);
          }
          parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
        }
        if (authMechanism === "PLAIN") {
          if (parsed.auth && parsed.auth.db == null) {
            parsed.auth = Object.assign({}, parsed.auth, { db: "$external" });
          }
        }
      }
      if (parsed.auth && parsed.auth.db == null) {
        parsed.auth = Object.assign({}, parsed.auth, { db: "admin" });
      }
      return parsed;
    }
    function parseQueryString(query, options2) {
      const result = {};
      let parsedQueryString = qs2.parse(query);
      checkTLSOptions(parsedQueryString);
      for (const key in parsedQueryString) {
        const value = parsedQueryString[key];
        if (value === "" || value == null) {
          throw new MongoParseError("Incomplete key value pair for option");
        }
        const normalizedKey = key.toLowerCase();
        const parsedValue = FILE_PATH_OPTIONS.has(normalizedKey) ? value : parseQueryStringItemValue(normalizedKey, value);
        applyConnectionStringOption(result, normalizedKey, parsedValue, options2);
      }
      if (result.wtimeout && result.wtimeoutms) {
        delete result.wtimeout;
        emitWarningOnce("Unsupported option `wtimeout` specified");
      }
      return Object.keys(result).length ? result : null;
    }
    function translateTLSOptions(queryString) {
      if (queryString.tls) {
        queryString.ssl = queryString.tls;
      }
      if (queryString.tlsInsecure) {
        queryString.checkServerIdentity = false;
        queryString.sslValidate = false;
      } else {
        Object.assign(queryString, {
          checkServerIdentity: queryString.tlsAllowInvalidHostnames ? false : true,
          sslValidate: queryString.tlsAllowInvalidCertificates ? false : true
        });
      }
      if (queryString.tlsCAFile) {
        queryString.ssl = true;
        queryString.sslCA = queryString.tlsCAFile;
      }
      if (queryString.tlsCertificateKeyFile) {
        queryString.ssl = true;
        if (queryString.tlsCertificateFile) {
          queryString.sslCert = queryString.tlsCertificateFile;
          queryString.sslKey = queryString.tlsCertificateKeyFile;
        } else {
          queryString.sslKey = queryString.tlsCertificateKeyFile;
          queryString.sslCert = queryString.tlsCertificateKeyFile;
        }
      }
      if (queryString.tlsCertificateKeyFilePassword) {
        queryString.ssl = true;
        queryString.sslPass = queryString.tlsCertificateKeyFilePassword;
      }
      return queryString;
    }
    function checkTLSOptions(queryString) {
      const queryStringKeys = Object.keys(queryString);
      if (queryStringKeys.indexOf("tlsInsecure") !== -1 && (queryStringKeys.indexOf("tlsAllowInvalidCertificates") !== -1 || queryStringKeys.indexOf("tlsAllowInvalidHostnames") !== -1)) {
        throw new MongoParseError("The `tlsInsecure` option cannot be used with `tlsAllowInvalidCertificates` or `tlsAllowInvalidHostnames`.");
      }
      const tlsValue = assertTlsOptionsAreEqual("tls", queryString, queryStringKeys);
      const sslValue = assertTlsOptionsAreEqual("ssl", queryString, queryStringKeys);
      if (tlsValue != null && sslValue != null) {
        if (tlsValue !== sslValue) {
          throw new MongoParseError("All values of `tls` and `ssl` must be the same.");
        }
      }
    }
    function assertTlsOptionsAreEqual(optionName, queryString, queryStringKeys) {
      const queryStringHasTLSOption = queryStringKeys.indexOf(optionName) !== -1;
      let optionValue;
      if (Array.isArray(queryString[optionName])) {
        optionValue = queryString[optionName][0];
      } else {
        optionValue = queryString[optionName];
      }
      if (queryStringHasTLSOption) {
        if (Array.isArray(queryString[optionName])) {
          const firstValue = queryString[optionName][0];
          queryString[optionName].forEach((tlsValue) => {
            if (tlsValue !== firstValue) {
              throw new MongoParseError(`All values of ${optionName} must be the same.`);
            }
          });
        }
      }
      return optionValue;
    }
    var PROTOCOL_MONGODB = "mongodb";
    var PROTOCOL_MONGODB_SRV = "mongodb+srv";
    var SUPPORTED_PROTOCOLS = [PROTOCOL_MONGODB, PROTOCOL_MONGODB_SRV];
    function parseConnectionString(uri2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, { caseTranslate: true }, options2);
      try {
        URL2.parse(uri2);
      } catch (e) {
        return callback(new MongoParseError("URI malformed, cannot be parsed"));
      }
      const cap = uri2.match(HOSTS_RX);
      if (!cap) {
        return callback(new MongoParseError("Invalid connection string"));
      }
      const protocol = cap[1];
      if (SUPPORTED_PROTOCOLS.indexOf(protocol) === -1) {
        return callback(new MongoParseError("Invalid protocol provided"));
      }
      const dbAndQuery = cap[4].split("?");
      const db = dbAndQuery.length > 0 ? dbAndQuery[0] : null;
      const query = dbAndQuery.length > 1 ? dbAndQuery[1] : null;
      let parsedOptions;
      try {
        parsedOptions = parseQueryString(query, options2);
      } catch (parseError) {
        return callback(parseError);
      }
      parsedOptions = Object.assign({}, parsedOptions, options2);
      if (protocol === PROTOCOL_MONGODB_SRV) {
        return parseSrvConnectionString(uri2, parsedOptions, callback);
      }
      const auth = { username: null, password: null, db: db && db !== "" ? qs2.unescape(db) : null };
      if (parsedOptions.auth) {
        if (parsedOptions.auth.username)
          auth.username = parsedOptions.auth.username;
        if (parsedOptions.auth.user)
          auth.username = parsedOptions.auth.user;
        if (parsedOptions.auth.password)
          auth.password = parsedOptions.auth.password;
      } else {
        if (parsedOptions.username)
          auth.username = parsedOptions.username;
        if (parsedOptions.user)
          auth.username = parsedOptions.user;
        if (parsedOptions.password)
          auth.password = parsedOptions.password;
      }
      if (cap[4].split("?")[0].indexOf("@") !== -1) {
        return callback(new MongoParseError("Unescaped slash in userinfo section"));
      }
      const authorityParts = cap[3].split("@");
      if (authorityParts.length > 2) {
        return callback(new MongoParseError("Unescaped at-sign in authority section"));
      }
      if (authorityParts[0] == null || authorityParts[0] === "") {
        return callback(new MongoParseError("No username provided in authority section"));
      }
      if (authorityParts.length > 1) {
        const authParts = authorityParts.shift().split(":");
        if (authParts.length > 2) {
          return callback(new MongoParseError("Unescaped colon in authority section"));
        }
        if (authParts[0] === "") {
          return callback(new MongoParseError("Invalid empty username provided"));
        }
        if (!auth.username)
          auth.username = qs2.unescape(authParts[0]);
        if (!auth.password)
          auth.password = authParts[1] ? qs2.unescape(authParts[1]) : null;
      }
      let hostParsingError = null;
      const hosts = authorityParts.shift().split(",").map((host2) => {
        let parsedHost = URL2.parse(`mongodb://${host2}`);
        if (parsedHost.path === "/:") {
          hostParsingError = new MongoParseError("Double colon in host identifier");
          return null;
        }
        if (host2.match(/\.sock/)) {
          parsedHost.hostname = qs2.unescape(host2);
          parsedHost.port = null;
        }
        if (Number.isNaN(parsedHost.port)) {
          hostParsingError = new MongoParseError("Invalid port (non-numeric string)");
          return;
        }
        const result2 = {
          host: parsedHost.hostname,
          port: parsedHost.port ? parseInt(parsedHost.port) : 27017
        };
        if (result2.port === 0) {
          hostParsingError = new MongoParseError("Invalid port (zero) with hostname");
          return;
        }
        if (result2.port > 65535) {
          hostParsingError = new MongoParseError("Invalid port (larger than 65535) with hostname");
          return;
        }
        if (result2.port < 0) {
          hostParsingError = new MongoParseError("Invalid port (negative number)");
          return;
        }
        return result2;
      }).filter((host2) => !!host2);
      if (hostParsingError) {
        return callback(hostParsingError);
      }
      if (hosts.length === 0 || hosts[0].host === "" || hosts[0].host === null) {
        return callback(new MongoParseError("No hostname or hostnames provided in connection string"));
      }
      const directConnection = !!parsedOptions.directConnection;
      if (directConnection && hosts.length !== 1) {
        return callback(new MongoParseError("directConnection option requires exactly one host"));
      }
      if (parsedOptions.directConnection == null && hosts.length === 1 && parsedOptions.replicaSet == null) {
        parsedOptions.directConnection = true;
      }
      const result = {
        hosts,
        auth: auth.db || auth.username ? auth : null,
        options: Object.keys(parsedOptions).length ? parsedOptions : null
      };
      if (result.auth && result.auth.db) {
        result.defaultDatabase = result.auth.db;
      } else {
        result.defaultDatabase = "test";
      }
      result.options = translateTLSOptions(result.options);
      try {
        applyAuthExpectations(result);
      } catch (authError) {
        return callback(authError);
      }
      callback(null, result);
    }
    module2.exports = parseConnectionString;
  }
});

// node_modules/mongodb/lib/core/index.js
var require_core = __commonJS({
  "node_modules/mongodb/lib/core/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var BSON2 = require_bson2();
    var require_optional = require_optional_require()(__require);
    var EJSON = require_utils2().retrieveEJSON();
    try {
      const BSONNative = require_optional("bson-ext");
      if (BSONNative) {
        BSON2 = BSONNative;
      }
    } catch (err) {
    }
    module2.exports = {
      MongoError: require_error().MongoError,
      MongoNetworkError: require_error().MongoNetworkError,
      MongoParseError: require_error().MongoParseError,
      MongoTimeoutError: require_error().MongoTimeoutError,
      MongoServerSelectionError: require_error().MongoServerSelectionError,
      MongoWriteConcernError: require_error().MongoWriteConcernError,
      Connection: require_connection(),
      Server: require_server(),
      ReplSet: require_replset(),
      Mongos: require_mongos(),
      Logger: require_logger(),
      Cursor: require_cursor().CoreCursor,
      ReadPreference: require_read_preference(),
      Sessions: require_sessions(),
      BSON: BSON2,
      EJSON,
      Topology: require_topology().Topology,
      Query: require_commands().Query,
      MongoCredentials: require_mongo_credentials().MongoCredentials,
      defaultAuthProviders: require_defaultAuthProviders().defaultAuthProviders,
      MongoCR: require_mongocr(),
      X509: require_x509(),
      Plain: require_plain(),
      GSSAPI: require_gssapi(),
      ScramSHA1: require_scram().ScramSHA1,
      ScramSHA256: require_scram().ScramSHA256,
      parseConnectionString: require_uri_parser()
    };
  }
});

// node_modules/mongodb/lib/apm.js
var require_apm2 = __commonJS({
  "node_modules/mongodb/lib/apm.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var Instrumentation = class extends EventEmitter {
      constructor() {
        super();
      }
      instrument(MongoClient2, callback) {
        this.$MongoClient = MongoClient2;
        const $prototypeConnect = this.$prototypeConnect = MongoClient2.prototype.connect;
        const instrumentation = this;
        MongoClient2.prototype.connect = function(callback2) {
          this.s.options.monitorCommands = true;
          this.on("commandStarted", (event) => instrumentation.emit("started", event));
          this.on("commandSucceeded", (event) => instrumentation.emit("succeeded", event));
          this.on("commandFailed", (event) => instrumentation.emit("failed", event));
          return $prototypeConnect.call(this, callback2);
        };
        if (typeof callback === "function")
          callback(null, this);
      }
      uninstrument() {
        this.$MongoClient.prototype.connect = this.$prototypeConnect;
      }
    };
    module2.exports = Instrumentation;
  }
});

// node_modules/mongodb/lib/error.js
var require_error2 = __commonJS({
  "node_modules/mongodb/lib/error.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoNetworkError = require_core().MongoNetworkError;
    var GET_MORE_RESUMABLE_CODES = new Set([
      6,
      7,
      89,
      91,
      189,
      262,
      9001,
      10107,
      11600,
      11602,
      13435,
      13436,
      63,
      150,
      13388,
      234,
      133,
      43
    ]);
    function isResumableError(error3, wireVersion) {
      if (error3 instanceof MongoNetworkError) {
        return true;
      }
      if (wireVersion >= 9) {
        if (error3.code === 43) {
          return true;
        }
        return error3.hasErrorLabel("ResumableChangeStreamError");
      }
      return GET_MORE_RESUMABLE_CODES.has(error3.code);
    }
    module2.exports = { GET_MORE_RESUMABLE_CODES, isResumableError };
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mongodb/lib/constants.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = {
      SYSTEM_NAMESPACE_COLLECTION: "system.namespaces",
      SYSTEM_INDEX_COLLECTION: "system.indexes",
      SYSTEM_PROFILE_COLLECTION: "system.profile",
      SYSTEM_USER_COLLECTION: "system.users",
      SYSTEM_COMMAND_COLLECTION: "$cmd",
      SYSTEM_JS_COLLECTION: "system.js"
    };
  }
});

// node_modules/mongodb/lib/operations/db_ops.js
var require_db_ops = __commonJS({
  "node_modules/mongodb/lib/operations/db_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CONSTANTS = require_constants2();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    function createIndex(db, name2, fieldOrSpec, options2, callback) {
      let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options2);
      finalOptions = applyWriteConcern(finalOptions, { db }, options2);
      if (finalOptions.writeConcern && typeof callback !== "function") {
        throw MongoError.create({
          message: "Cannot use a writeConcern without a provided callback",
          driver: true
        });
      }
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      createIndexUsingCreateIndexes(db, name2, fieldOrSpec, finalOptions, (err, result) => {
        if (err == null)
          return handleCallback(callback, err, result);
        if (err.code === 67 || err.code === 11e3 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {
          return handleCallback(callback, err, result);
        }
        const doc = createCreateIndexCommand(db, name2, fieldOrSpec, options2);
        finalOptions.checkKeys = false;
        db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err2, result2) => {
          if (callback == null)
            return;
          if (err2)
            return handleCallback(callback, err2);
          if (result2 == null)
            return handleCallback(callback, null, null);
          if (result2.result.writeErrors)
            return handleCallback(callback, MongoError.create(result2.result.writeErrors[0]), null);
          handleCallback(callback, null, doc.name);
        });
      });
    }
    function createListener(db, e, object) {
      function listener(err) {
        if (object.listeners(e).length > 0) {
          object.emit(e, err, db);
          for (let i = 0; i < db.s.children.length; i++) {
            db.s.children[i].emit(e, err, db.s.children[i]);
          }
        }
      }
      return listener;
    }
    function ensureIndex(db, name2, fieldOrSpec, options2, callback) {
      const finalOptions = applyWriteConcern({}, { db }, options2);
      const selector = createCreateIndexCommand(db, name2, fieldOrSpec, options2);
      const index_name = selector.name;
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      finalOptions.readPreference = ReadPreference.PRIMARY;
      indexInformation(db, name2, finalOptions, (err, indexInformation2) => {
        if (err != null && err.code !== 26)
          return handleCallback(callback, err, null);
        if (indexInformation2 == null || !indexInformation2[index_name]) {
          createIndex(db, name2, fieldOrSpec, options2, callback);
        } else {
          if (typeof callback === "function")
            return handleCallback(callback, null, index_name);
        }
      });
    }
    function evaluate(db, code, parameters, options2, callback) {
      let finalCode = code;
      let finalParameters = [];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      if (!(finalCode && finalCode._bsontype === "Code"))
        finalCode = new Code2(finalCode);
      if (parameters != null && !Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = [parameters];
      } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== "function") {
        finalParameters = parameters;
      }
      let cmd = { $eval: finalCode, args: finalParameters };
      if (options2["nolock"]) {
        cmd["nolock"] = options2["nolock"];
      }
      options2.readPreference = new ReadPreference(ReadPreference.PRIMARY);
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result && result.ok === 1)
          return handleCallback(callback, null, result.retval);
        if (result)
          return handleCallback(callback, MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }), null);
        handleCallback(callback, err, result);
      });
    }
    function executeCommand(db, command, options2, callback) {
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      const dbName = options2.dbName || options2.authdb || db.databaseName;
      options2.readPreference = ReadPreference.resolve(db, options2);
      if (db.s.logger.isDebug())
        db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
      db.s.topology.command(db.s.namespace.withCollection("$cmd"), command, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err);
        if (options2.full)
          return handleCallback(callback, null, result);
        handleCallback(callback, null, result.result);
      });
    }
    function executeDbAdminCommand(db, command, options2, callback) {
      const namespace = new MongoDBNamespace("admin", "$cmd");
      db.s.topology.command(namespace, command, options2, (err, result) => {
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, result.result);
      });
    }
    function indexInformation(db, name2, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name3 in index2.key) {
            info[index2.name].push([name3, index2.key[name3]]);
          }
        }
        return info;
      }
      db.collection(name2).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function profilingInfo(db, options2, callback) {
      try {
        db.collection("system.profile").find({}, options2).toArray(callback);
      } catch (err) {
        return callback(err, null);
      }
    }
    function validateDatabaseName(databaseName) {
      if (typeof databaseName !== "string")
        throw MongoError.create({ message: "database name must be a string", driver: true });
      if (databaseName.length === 0)
        throw MongoError.create({ message: "database name cannot be the empty string", driver: true });
      if (databaseName === "$external")
        return;
      const invalidChars = [" ", ".", "$", "/", "\\"];
      for (let i = 0; i < invalidChars.length; i++) {
        if (databaseName.indexOf(invalidChars[i]) !== -1)
          throw MongoError.create({
            message: "database names cannot contain the character '" + invalidChars[i] + "'",
            driver: true
          });
      }
    }
    function createCreateIndexCommand(db, name2, fieldOrSpec, options2) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const fieldHash = indexParameters.fieldHash;
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const selector = {
        ns: db.s.namespace.withCollection(name2).toString(),
        key: fieldHash,
        name: indexName
      };
      const finalUnique = options2 == null || typeof options2 === "object" ? false : options2;
      options2 = options2 == null || typeof options2 === "boolean" ? {} : options2;
      const keysToOmit = Object.keys(selector);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          selector[optionName] = options2[optionName];
        }
      }
      if (selector["unique"] == null)
        selector["unique"] = finalUnique;
      const removeKeys = ["w", "wtimeout", "j", "fsync", "readPreference", "session"];
      for (let i = 0; i < removeKeys.length; i++) {
        delete selector[removeKeys[i]];
      }
      return selector;
    }
    function createIndexUsingCreateIndexes(db, name2, fieldOrSpec, options2, callback) {
      const indexParameters = parseIndexOptions(fieldOrSpec);
      const indexName = typeof options2.name === "string" ? options2.name : indexParameters.name;
      const indexes = [{ name: indexName, key: indexParameters.fieldHash }];
      const keysToOmit = Object.keys(indexes[0]).concat([
        "writeConcern",
        "w",
        "wtimeout",
        "j",
        "fsync",
        "readPreference",
        "session"
      ]);
      for (let optionName in options2) {
        if (keysToOmit.indexOf(optionName) === -1) {
          indexes[0][optionName] = options2[optionName];
        }
      }
      const capabilities = db.s.topology.capabilities();
      if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
        const error3 = new MongoError("server/primary/mongos does not support collation");
        error3.code = 67;
        return callback(error3);
      }
      const cmd = applyWriteConcern({ createIndexes: name2, indexes }, { db }, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      executeCommand(db, cmd, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result.ok === 0)
          return handleCallback(callback, toError(result), null);
        handleCallback(callback, null, indexName);
      });
    }
    module2.exports = {
      createListener,
      createIndex,
      ensureIndex,
      evaluate,
      executeCommand,
      executeDbAdminCommand,
      indexInformation,
      profilingInfo,
      validateDatabaseName
    };
  }
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS({
  "node_modules/mongodb/lib/operations/common_functions.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var CursorState = require_cursor().CursorState;
    var maxWireVersion = require_utils2().maxWireVersion;
    function buildCountCommand(collectionOrCursor, query, options2) {
      const skip = options2.skip;
      const limit = options2.limit;
      let hint = options2.hint;
      const maxTimeMS = options2.maxTimeMS;
      query = query || {};
      const cmd = {
        count: options2.collectionName,
        query
      };
      if (collectionOrCursor.s.numberOfRetries) {
        if (collectionOrCursor.options.hint) {
          hint = collectionOrCursor.options.hint;
        } else if (collectionOrCursor.cmd.hint) {
          hint = collectionOrCursor.cmd.hint;
        }
        decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);
      } else {
        decorateWithCollation(cmd, collectionOrCursor, options2);
      }
      if (typeof skip === "number")
        cmd.skip = skip;
      if (typeof limit === "number")
        cmd.limit = limit;
      if (typeof maxTimeMS === "number")
        cmd.maxTimeMS = maxTimeMS;
      if (hint)
        cmd.hint = hint;
      decorateWithReadConcern(cmd, collectionOrCursor);
      return cmd;
    }
    function findAndModify(coll, query, sort, doc, options2, callback) {
      const queryObject = {
        findAndModify: coll.collectionName,
        query
      };
      sort = formattedOrderClause(sort);
      if (sort) {
        queryObject.sort = sort;
      }
      queryObject.new = options2.new ? true : false;
      queryObject.remove = options2.remove ? true : false;
      queryObject.upsert = options2.upsert ? true : false;
      const projection = options2.projection || options2.fields;
      if (projection) {
        queryObject.fields = projection;
      }
      if (options2.arrayFilters) {
        queryObject.arrayFilters = options2.arrayFilters;
        delete options2.arrayFilters;
      }
      if (doc && !options2.remove) {
        queryObject.update = doc;
      }
      if (options2.maxTimeMS)
        queryObject.maxTimeMS = options2.maxTimeMS;
      options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      options2.checkKeys = false;
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (finalOptions.writeConcern) {
        queryObject.writeConcern = finalOptions.writeConcern;
      }
      if (finalOptions.bypassDocumentValidation === true) {
        queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
      }
      finalOptions.readPreference = ReadPreference.primary;
      try {
        decorateWithCollation(queryObject, coll, finalOptions);
      } catch (err) {
        return callback(err, null);
      }
      executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        return handleCallback(callback, null, result);
      });
    }
    function indexInformation(db, name2, options2, callback) {
      const full = options2["full"] == null ? false : options2["full"];
      if (db.serverConfig && db.serverConfig.isDestroyed())
        return callback(new MongoError("topology was destroyed"));
      function processResults(indexes) {
        let info = {};
        for (let i = 0; i < indexes.length; i++) {
          const index2 = indexes[i];
          info[index2.name] = [];
          for (let name3 in index2.key) {
            info[index2.name].push([name3, index2.key[name3]]);
          }
        }
        return info;
      }
      db.collection(name2).listIndexes(options2).toArray((err, indexes) => {
        if (err)
          return callback(toError(err));
        if (!Array.isArray(indexes))
          return handleCallback(callback, null, []);
        if (full)
          return handleCallback(callback, null, indexes);
        handleCallback(callback, null, processResults(indexes));
      });
    }
    function prepareDocs(coll, docs, options2) {
      const forceServerObjectId = typeof options2.forceServerObjectId === "boolean" ? options2.forceServerObjectId : coll.s.db.options.forceServerObjectId;
      if (forceServerObjectId === true) {
        return docs;
      }
      return docs.map((doc) => {
        if (forceServerObjectId !== true && doc._id == null) {
          doc._id = coll.s.pkFactory.createPk();
        }
        return doc;
      });
    }
    function nextObject(cursor, callback) {
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {
        try {
          cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
        } catch (err) {
          return handleCallback(callback, err);
        }
      }
      cursor._next((err, doc) => {
        cursor.s.state = CursorState.OPEN;
        if (err)
          return handleCallback(callback, err);
        handleCallback(callback, null, doc);
      });
    }
    function insertDocuments(coll, docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      docs = Array.isArray(docs) ? docs : [docs];
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (finalOptions.keepGoing === true)
        finalOptions.ordered = false;
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      docs = prepareDocs(coll, docs, options2);
      coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        result.ops = docs;
        handleCallback(callback, null, result);
      });
    }
    function removeDocuments(coll, selector, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2, options2 = {};
      } else if (typeof selector === "function") {
        callback = selector;
        options2 = {};
        selector = {};
      }
      options2 = options2 || {};
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      if (selector == null)
        selector = {};
      const op = { q: selector, limit: 0 };
      if (options2.single) {
        op.limit = 1;
      } else if (finalOptions.retryWrites) {
        finalOptions.retryWrites = false;
      }
      if (options2.hint) {
        op.hint = options2.hint;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on remove`)) : void 0;
      }
      coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors) {
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        }
        handleCallback(callback, null, result);
      });
    }
    function updateDocuments(coll, selector, document2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = null;
      if (options2 == null)
        options2 = {};
      if (!(typeof callback === "function"))
        callback = null;
      if (selector == null || typeof selector !== "object")
        return callback(toError("selector must be a valid JavaScript object"));
      if (document2 == null || typeof document2 !== "object")
        return callback(toError("document must be a valid JavaScript object"));
      let finalOptions = Object.assign({}, options2);
      finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
      finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
      finalOptions.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
      const op = { q: selector, u: document2 };
      op.upsert = options2.upsert !== void 0 ? !!options2.upsert : false;
      op.multi = options2.multi !== void 0 ? !!options2.multi : false;
      if (options2.hint) {
        op.hint = options2.hint;
      }
      if (finalOptions.arrayFilters) {
        op.arrayFilters = finalOptions.arrayFilters;
        delete finalOptions.arrayFilters;
      }
      if (finalOptions.retryWrites && op.multi) {
        finalOptions.retryWrites = false;
      }
      try {
        decorateWithCollation(finalOptions, coll, options2);
      } catch (err) {
        return callback(err, null);
      }
      if (options2.explain !== void 0 && maxWireVersion(coll.s.topology) < 3) {
        return callback ? callback(new MongoError(`server does not support explain on update`)) : void 0;
      }
      coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, null, null);
        if (result.result.code)
          return handleCallback(callback, toError(result.result));
        if (result.result.writeErrors)
          return handleCallback(callback, toError(result.result.writeErrors[0]));
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      buildCountCommand,
      findAndModify,
      indexInformation,
      nextObject,
      prepareDocs,
      insertDocuments,
      removeDocuments,
      updateDocuments
    };
  }
});

// node_modules/mongodb/lib/operations/collection_ops.js
var require_collection_ops = __commonJS({
  "node_modules/mongodb/lib/operations/collection_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var createIndexDb = require_db_ops().createIndex;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var ensureIndexDb = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var insertDocuments = require_common_functions().insertDocuments;
    var updateDocuments = require_common_functions().updateDocuments;
    var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
    function createIndex(coll, fieldOrSpec, options2, callback) {
      createIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function createIndexes(coll, indexSpecs, options2, callback) {
      const capabilities = coll.s.topology.capabilities();
      for (let i = 0; i < indexSpecs.length; i++) {
        if (indexSpecs[i].name == null) {
          const keys = [];
          if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
            return callback(new MongoError("server/primary/mongos does not support collation"));
          }
          for (let name2 in indexSpecs[i].key) {
            keys.push(`${name2}_${indexSpecs[i].key[name2]}`);
          }
          indexSpecs[i].name = keys.join("_");
        }
      }
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      executeCommand(coll.s.db, {
        createIndexes: coll.collectionName,
        indexes: indexSpecs
      }, options2, callback);
    }
    function ensureIndex(coll, fieldOrSpec, options2, callback) {
      ensureIndexDb(coll.s.db, coll.collectionName, fieldOrSpec, options2, callback);
    }
    function group(coll, keys, condition, initial, reduce, finalize, command, options2, callback) {
      if (command) {
        const reduceFunction = reduce && reduce._bsontype === "Code" ? reduce : new Code2(reduce);
        const selector = {
          group: {
            ns: coll.collectionName,
            $reduce: reduceFunction,
            cond: condition,
            initial,
            out: "inline"
          }
        };
        if (finalize != null)
          selector.group["finalize"] = finalize;
        if (typeof keys === "function" || keys && keys._bsontype === "Code") {
          selector.group.$keyf = keys && keys._bsontype === "Code" ? keys : new Code2(keys);
        } else {
          const hash2 = {};
          keys.forEach((key) => {
            hash2[key] = 1;
          });
          selector.group.key = hash2;
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(selector, coll, options2);
        try {
          decorateWithCollation(selector, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        executeCommand(coll.s.db, selector, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result.retval);
        });
      } else {
        const scope = reduce != null && reduce._bsontype === "Code" ? reduce.scope : {};
        scope.ns = coll.collectionName;
        scope.keys = keys;
        scope.condition = condition;
        scope.initial = initial;
        const groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ";");
        evaluate(coll.s.db, new Code2(groupfn, scope), null, options2, (err, results) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, results.result || results);
        });
      }
    }
    function indexes(coll, options2, callback) {
      options2 = Object.assign({}, { full: true }, options2);
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function indexExists(coll, indexes2, options2, callback) {
      indexInformation(coll, options2, (err, indexInformation2) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (!Array.isArray(indexes2))
          return handleCallback(callback, null, indexInformation2[indexes2] != null);
        for (let i = 0; i < indexes2.length; i++) {
          if (indexInformation2[indexes2[i]] == null) {
            return handleCallback(callback, null, false);
          }
        }
        return handleCallback(callback, null, true);
      });
    }
    function indexInformation(coll, options2, callback) {
      indexInformationDb(coll.s.db, coll.collectionName, options2, callback);
    }
    function parallelCollectionScan(coll, options2, callback) {
      const commandObject = {
        parallelCollectionScan: coll.collectionName,
        numCursors: options2.numCursors
      };
      decorateWithReadConcern(commandObject, coll, options2);
      const raw = options2.raw;
      delete options2["raw"];
      executeCommand(coll.s.db, commandObject, options2, (err, result) => {
        if (err)
          return handleCallback(callback, err, null);
        if (result == null)
          return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
        options2 = Object.assign({ explicitlyIgnoreSession: true }, options2);
        const cursors = [];
        if (raw)
          options2.raw = raw;
        for (let i = 0; i < result.cursors.length; i++) {
          const rawId = result.cursors[i].cursor.id;
          const cursorId = typeof rawId === "number" ? Long2.fromNumber(rawId) : rawId;
          cursors.push(coll.s.topology.cursor(coll.namespace, cursorId, options2));
        }
        handleCallback(callback, null, cursors);
      });
    }
    function save(coll, doc, options2, callback) {
      const finalOptions = applyWriteConcern(Object.assign({}, options2), { db: coll.s.db, collection: coll }, options2);
      if (doc._id != null) {
        finalOptions.upsert = true;
        return updateDocuments(coll, { _id: doc._id }, doc, finalOptions, callback);
      }
      insertDocuments(coll, [doc], finalOptions, (err, result) => {
        if (callback == null)
          return;
        if (doc == null)
          return handleCallback(callback, null, null);
        if (err)
          return handleCallback(callback, err, null);
        handleCallback(callback, null, result);
      });
    }
    module2.exports = {
      createIndex,
      createIndexes,
      ensureIndex,
      group,
      indexes,
      indexExists,
      indexInformation,
      parallelCollectionScan,
      save
    };
  }
});

// node_modules/mongodb/lib/operations/cursor_ops.js
var require_cursor_ops = __commonJS({
  "node_modules/mongodb/lib/operations/cursor_ops.js"(exports2, module2) {
    init_shims();
    "use strict";
    var buildCountCommand = require_collection_ops().buildCountCommand;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var push = Array.prototype.push;
    var CursorState = require_cursor().CursorState;
    function count(cursor, applySkipLimit, opts, callback) {
      if (applySkipLimit) {
        if (typeof cursor.cursorSkip() === "number")
          opts.skip = cursor.cursorSkip();
        if (typeof cursor.cursorLimit() === "number")
          opts.limit = cursor.cursorLimit();
      }
      if (opts.readPreference) {
        cursor.setReadPreference(opts.readPreference);
      }
      if (typeof opts.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
        opts.maxTimeMS = cursor.cmd.maxTimeMS;
      }
      let options2 = {};
      options2.skip = opts.skip;
      options2.limit = opts.limit;
      options2.hint = opts.hint;
      options2.maxTimeMS = opts.maxTimeMS;
      options2.collectionName = cursor.namespace.collection;
      let command;
      try {
        command = buildCountCommand(cursor, cursor.cmd.query, options2);
      } catch (err) {
        return callback(err);
      }
      cursor.server = cursor.topology.s.coreTopology;
      cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
        callback(err, result ? result.result.n : null);
      });
    }
    function each2(cursor, callback) {
      if (!callback)
        throw MongoError.create({ message: "callback is mandatory", driver: true });
      if (cursor.isNotified())
        return;
      if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {
        return handleCallback(callback, MongoError.create({ message: "Cursor is closed", driver: true }));
      }
      if (cursor.s.state === CursorState.INIT) {
        cursor.s.state = CursorState.OPEN;
      }
      let fn = null;
      if (cursor.bufferedCount() > 0) {
        while (fn = loop(cursor, callback))
          fn(cursor, callback);
        each2(cursor, callback);
      } else {
        cursor.next((err, item) => {
          if (err)
            return handleCallback(callback, err);
          if (item == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));
          }
          if (handleCallback(callback, null, item) === false)
            return;
          each2(cursor, callback);
        });
      }
    }
    function loop(cursor, callback) {
      if (cursor.bufferedCount() === 0)
        return;
      cursor._next(callback);
      return loop;
    }
    function toArray(cursor, callback) {
      const items = [];
      cursor.rewind();
      cursor.s.state = CursorState.INIT;
      const fetchDocs = () => {
        cursor._next((err, doc) => {
          if (err) {
            return handleCallback(callback, err);
          }
          if (doc == null) {
            return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));
          }
          items.push(doc);
          if (cursor.bufferedCount() > 0) {
            let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
            if (cursor.s.transforms && typeof cursor.s.transforms.doc === "function") {
              docs = docs.map(cursor.s.transforms.doc);
            }
            push.apply(items, docs);
          }
          fetchDocs();
        });
      };
      fetchDocs();
    }
    module2.exports = { count, each: each2, toArray };
  }
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS({
  "node_modules/mongodb/lib/operations/count.js"(exports2, module2) {
    init_shims();
    "use strict";
    var buildCountCommand = require_common_functions().buildCountCommand;
    var OperationBase = require_operation().OperationBase;
    var CountOperation = class extends OperationBase {
      constructor(cursor, applySkipLimit, options2) {
        super(options2);
        this.cursor = cursor;
        this.applySkipLimit = applySkipLimit;
      }
      execute(callback) {
        const cursor = this.cursor;
        const applySkipLimit = this.applySkipLimit;
        const options2 = this.options;
        if (applySkipLimit) {
          if (typeof cursor.cursorSkip() === "number")
            options2.skip = cursor.cursorSkip();
          if (typeof cursor.cursorLimit() === "number")
            options2.limit = cursor.cursorLimit();
        }
        if (options2.readPreference) {
          cursor.setReadPreference(options2.readPreference);
        }
        if (typeof options2.maxTimeMS !== "number" && cursor.cmd && typeof cursor.cmd.maxTimeMS === "number") {
          options2.maxTimeMS = cursor.cmd.maxTimeMS;
        }
        let finalOptions = {};
        finalOptions.skip = options2.skip;
        finalOptions.limit = options2.limit;
        finalOptions.hint = options2.hint;
        finalOptions.maxTimeMS = options2.maxTimeMS;
        finalOptions.collectionName = cursor.namespace.collection;
        let command;
        try {
          command = buildCountCommand(cursor, cursor.cmd.query, finalOptions);
        } catch (err) {
          return callback(err);
        }
        cursor.server = cursor.topology.s.coreTopology;
        cursor.topology.command(cursor.namespace.withCollection("$cmd"), command, cursor.options, (err, result) => {
          callback(err, result ? result.result.n : null);
        });
      }
    };
    module2.exports = CountOperation;
  }
});

// node_modules/mongodb/lib/cursor.js
var require_cursor2 = __commonJS({
  "node_modules/mongodb/lib/cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Transform = __require("stream").Transform;
    var PassThrough2 = __require("stream").PassThrough;
    var deprecate = __require("util").deprecate;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var CoreCursor = require_cursor().CoreCursor;
    var CursorState = require_cursor().CursorState;
    var Map2 = require_core().BSON.Map;
    var maybePromise = require_utils4().maybePromise;
    var executeOperation = require_execute_operation();
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var Explain = require_explain().Explain;
    var Aspect = require_operation().Aspect;
    var each2 = require_cursor_ops().each;
    var CountOperation = require_count();
    var flags = ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
    var fields = ["numberOfRetries", "tailableRetryInterval"];
    var Cursor = class extends CoreCursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
        if (this.operation) {
          options2 = this.operation.options;
        }
        const numberOfRetries = options2.numberOfRetries || 5;
        const tailableRetryInterval = options2.tailableRetryInterval || 500;
        const currentNumberOfRetries = numberOfRetries;
        const promiseLibrary = options2.promiseLibrary || Promise;
        this.s = {
          numberOfRetries,
          tailableRetryInterval,
          currentNumberOfRetries,
          state: CursorState.INIT,
          promiseLibrary,
          explicitlyIgnoreSession: !!options2.explicitlyIgnoreSession
        };
        if (!options2.explicitlyIgnoreSession && options2.session) {
          this.cursorState.session = options2.session;
        }
        if (this.options.noCursorTimeout === true) {
          this.addCursorFlag("noCursorTimeout", true);
        }
        let batchSize = 1e3;
        if (this.cmd.cursor && this.cmd.cursor.batchSize) {
          batchSize = this.cmd.cursor.batchSize;
        } else if (options2.cursor && options2.cursor.batchSize) {
          batchSize = options2.cursor.batchSize;
        } else if (typeof options2.batchSize === "number") {
          batchSize = options2.batchSize;
        }
        this.setCursorBatchSize(batchSize);
      }
      get readPreference() {
        if (this.operation) {
          return this.operation.readPreference;
        }
        return this.options.readPreference;
      }
      get sortValue() {
        return this.cmd.sort;
      }
      _initializeCursor(callback) {
        if (this.operation && this.operation.session != null) {
          this.cursorState.session = this.operation.session;
        } else {
          if (!this.s.explicitlyIgnoreSession && !this.cursorState.session && this.topology.hasSessionSupport()) {
            this.cursorState.session = this.topology.startSession({ owner: this });
            if (this.operation) {
              this.operation.session = this.cursorState.session;
            }
          }
        }
        super._initializeCursor(callback);
      }
      hasNext(callback) {
        if (this.s.state === CursorState.CLOSED || this.isDead && this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.isNotified()) {
            return cb(null, false);
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            if (doc == null || cursor.s.state === Cursor.CLOSED || cursor.isDead()) {
              return cb(null, false);
            }
            cursor.s.state = CursorState.OPEN;
            cursor.cursorState.cursorIndex--;
            if (cursor.cursorState.limit > 0) {
              cursor.cursorState.currentLimit--;
            }
            cb(null, true);
          });
        });
      }
      next(callback) {
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {
            cb(MongoError.create({ message: "Cursor is closed", driver: true }));
            return;
          }
          if (cursor.s.state === CursorState.INIT && cursor.cmd.sort) {
            try {
              cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);
            } catch (err) {
              return cb(err);
            }
          }
          cursor._next((err, doc) => {
            if (err)
              return cb(err);
            cursor.s.state = CursorState.OPEN;
            cb(null, doc);
          });
        });
      }
      filter(filter2) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.query = filter2;
        return this;
      }
      maxScan(maxScan) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxScan = maxScan;
        return this;
      }
      hint(hint) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.hint = hint;
        return this;
      }
      min(min) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.min = min;
        return this;
      }
      max(max) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.max = max;
        return this;
      }
      returnKey(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.returnKey = value;
        return this;
      }
      showRecordId(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.showDiskLoc = value;
        return this;
      }
      snapshot(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.snapshot = value;
        return this;
      }
      setCursorOption(field, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (fields.indexOf(field) === -1) {
          throw MongoError.create({
            message: `option ${field} is not a supported option ${fields}`,
            driver: true
          });
        }
        this.s[field] = value;
        if (field === "numberOfRetries")
          this.s.currentNumberOfRetries = value;
        return this;
      }
      addCursorFlag(flag, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (flags.indexOf(flag) === -1) {
          throw MongoError.create({
            message: `flag ${flag} is not a supported flag ${flags}`,
            driver: true
          });
        }
        if (typeof value !== "boolean") {
          throw MongoError.create({ message: `flag ${flag} must be a boolean value`, driver: true });
        }
        this.cmd[flag] = value;
        return this;
      }
      addQueryModifier(name2, value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (name2[0] !== "$") {
          throw MongoError.create({ message: `${name2} is not a valid query modifier`, driver: true });
        }
        const field = name2.substr(1);
        this.cmd[field] = value;
        if (field === "orderby")
          this.cmd.sort = this.cmd[field];
        return this;
      }
      comment(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.comment = value;
        return this;
      }
      maxAwaitTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxAwaitTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxAwaitTimeMS = value;
        return this;
      }
      maxTimeMS(value) {
        if (typeof value !== "number") {
          throw MongoError.create({ message: "maxTimeMS must be a number", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.maxTimeMS = value;
        return this;
      }
      project(value) {
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        this.cmd.fields = value;
        return this;
      }
      sort(keyOrList, direction) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support sorting", driver: true });
        }
        if (this.s.state === CursorState.CLOSED || this.s.state === CursorState.OPEN || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        let order = keyOrList;
        if (Array.isArray(order) && Array.isArray(order[0])) {
          order = new Map2(order.map((x) => {
            const value = [x[0], null];
            if (x[1] === "asc") {
              value[1] = 1;
            } else if (x[1] === "desc") {
              value[1] = -1;
            } else if (x[1] === 1 || x[1] === -1 || x[1].$meta) {
              value[1] = x[1];
            } else {
              throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
            }
            return value;
          }));
        }
        if (direction != null) {
          order = [[keyOrList, direction]];
        }
        this.cmd.sort = order;
        return this;
      }
      batchSize(value) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor doesn't support batchSize",
            driver: true
          });
        }
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.cmd.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      collation(value) {
        this.cmd.collation = value;
        return this;
      }
      limit(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support limit", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "limit requires an integer", driver: true });
        }
        this.cmd.limit = value;
        this.setCursorLimit(value);
        return this;
      }
      skip(value) {
        if (this.options.tailable) {
          throw MongoError.create({ message: "Tailable cursor doesn't support skip", driver: true });
        }
        if (this.s.state === CursorState.OPEN || this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "skip requires an integer", driver: true });
        }
        this.cmd.skip = value;
        this.setCursorSkip(value);
        return this;
      }
      each(callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        each2(this, callback);
      }
      forEach(iterator, callback) {
        this.rewind();
        this.s.state = CursorState.INIT;
        if (typeof callback === "function") {
          each2(this, (err, doc) => {
            if (err) {
              callback(err);
              return false;
            }
            if (doc != null) {
              iterator(doc);
              return true;
            }
            if (doc == null && callback) {
              const internalCallback = callback;
              callback = null;
              internalCallback(null);
              return false;
            }
          });
        } else {
          return new this.s.promiseLibrary((fulfill, reject) => {
            each2(this, (err, doc) => {
              if (err) {
                reject(err);
                return false;
              } else if (doc == null) {
                fulfill(null);
                return false;
              } else {
                iterator(doc);
                return true;
              }
            });
          });
        }
      }
      setReadPreference(readPreference) {
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      toArray(callback) {
        if (this.options.tailable) {
          throw MongoError.create({
            message: "Tailable cursor cannot be converted to array",
            driver: true
          });
        }
        return maybePromise(this, callback, (cb) => {
          const cursor = this;
          const items = [];
          cursor.rewind();
          cursor.s.state = CursorState.INIT;
          const fetchDocs = () => {
            cursor._next((err, doc) => {
              if (err) {
                return handleCallback(cb, err);
              }
              if (doc == null) {
                return cursor.close({ skipKillCursors: true }, () => handleCallback(cb, null, items));
              }
              items.push(doc);
              if (cursor.bufferedCount() > 0) {
                let docs = cursor.readBufferedDocuments(cursor.bufferedCount());
                Array.prototype.push.apply(items, docs);
              }
              fetchDocs();
            });
          };
          fetchDocs();
        });
      }
      count(applySkipLimit, opts, callback) {
        if (this.cmd.query == null)
          throw MongoError.create({
            message: "count can only be used with find command",
            driver: true
          });
        if (typeof opts === "function")
          callback = opts, opts = {};
        opts = opts || {};
        if (typeof applySkipLimit === "function") {
          callback = applySkipLimit;
          applySkipLimit = true;
        }
        if (this.cursorState.session) {
          opts = Object.assign({}, opts, { session: this.cursorState.session });
        }
        const countOperation = new CountOperation(this, applySkipLimit, opts);
        return executeOperation(this.topology, countOperation, callback);
      }
      close(options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = Object.assign({}, { skipKillCursors: false }, options2);
        return maybePromise(this, callback, (cb) => {
          this.s.state = CursorState.CLOSED;
          if (!options2.skipKillCursors) {
            this.kill();
          }
          this._endSession(() => {
            this.emit("close");
            cb(null, this);
          });
        });
      }
      map(transform) {
        if (this.cursorState.transforms && this.cursorState.transforms.doc) {
          const oldTransform = this.cursorState.transforms.doc;
          this.cursorState.transforms.doc = (doc) => {
            return transform(oldTransform(doc));
          };
        } else {
          this.cursorState.transforms = { doc: transform };
        }
        return this;
      }
      isClosed() {
        return this.isDead();
      }
      destroy(err) {
        if (err)
          this.emit("error", err);
        this.pause();
        this.close();
      }
      stream(options2) {
        this.cursorState.streamOptions = options2 || {};
        return this;
      }
      transformStream(options2) {
        const streamOptions = options2 || {};
        if (typeof streamOptions.transform === "function") {
          const stream = new Transform({
            objectMode: true,
            transform: function(chunk, encoding3, callback) {
              this.push(streamOptions.transform(chunk));
              callback();
            }
          });
          return this.pipe(stream);
        }
        return this.pipe(new PassThrough2({ objectMode: true }));
      }
      explain(verbosity, callback) {
        if (typeof verbosity === "function")
          callback = verbosity, verbosity = true;
        if (verbosity === void 0)
          verbosity = true;
        if (!this.operation || !this.operation.hasAspect(Aspect.EXPLAINABLE)) {
          throw new MongoError("This command cannot be explained");
        }
        this.operation.explain = new Explain(verbosity);
        return maybePromise(this, callback, (cb) => {
          CoreCursor.prototype._next.apply(this, [cb]);
        });
      }
      getLogger() {
        return this.logger;
      }
    };
    Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
    deprecate(Cursor.prototype.each, "Cursor.each is deprecated. Use Cursor.forEach instead.");
    deprecate(Cursor.prototype.maxScan, "Cursor.maxScan is deprecated, and will be removed in a later version");
    deprecate(Cursor.prototype.snapshot, "Cursor Snapshot is deprecated, and will be removed in a later version");
    module2.exports = Cursor;
  }
});

// node_modules/mongodb/lib/operations/command_v2.js
var require_command_v2 = __commonJS({
  "node_modules/mongodb/lib/operations/command_v2.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var ReadConcern = require_read_concern();
    var WriteConcern = require_write_concern();
    var maxWireVersion = require_utils2().maxWireVersion;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var commandSupportsReadConcern = require_sessions().commandSupportsReadConcern;
    var MongoError = require_error().MongoError;
    var SUPPORTS_WRITE_CONCERN_AND_COLLATION = 5;
    var CommandOperationV2 = class extends OperationBase {
      constructor(parent, options2, operationOptions) {
        super(options2);
        this.ns = parent.s.namespace.withCollection("$cmd");
        const propertyProvider = this.hasAspect(Aspect.NO_INHERIT_OPTIONS) ? void 0 : parent;
        this.readPreference = this.hasAspect(Aspect.WRITE_OPERATION) ? ReadPreference.primary : ReadPreference.resolve(propertyProvider, this.options);
        this.readConcern = resolveReadConcern(propertyProvider, this.options);
        this.writeConcern = resolveWriteConcern(propertyProvider, this.options);
        if (operationOptions && typeof operationOptions.fullResponse === "boolean") {
          this.fullResponse = true;
        }
        this.options.readPreference = this.readPreference;
        if (parent.s.logger) {
          this.logger = parent.s.logger;
        } else if (parent.s.db && parent.s.db.logger) {
          this.logger = parent.s.db.logger;
        }
      }
      executeCommand(server, cmd, callback) {
        this.server = server;
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && commandSupportsReadConcern(cmd) && !inTransaction) {
          Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (options2.collation && serverWireVersion < SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
          return;
        }
        if (serverWireVersion >= SUPPORTS_WRITE_CONCERN_AND_COLLATION) {
          if (this.writeConcern && this.hasAspect(Aspect.WRITE_OPERATION)) {
            Object.assign(cmd, { writeConcern: this.writeConcern });
          }
          if (options2.collation && typeof options2.collation === "object") {
            Object.assign(cmd, { collation: options2.collation });
          }
        }
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        if (typeof options2.comment === "string") {
          cmd.comment = options2.comment;
        }
        if (this.hasAspect(Aspect.EXPLAINABLE) && this.explain) {
          if (serverWireVersion < 6 && cmd.aggregate) {
            cmd.explain = true;
          } else {
            cmd = decorateWithExplain(cmd, this.explain);
          }
        }
        if (this.logger && this.logger.isDebug()) {
          this.logger.debug(`executing command ${JSON.stringify(cmd)} against ${this.ns}`);
        }
        server.command(this.ns.toString(), cmd, this.options, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          if (this.fullResponse) {
            callback(null, result);
            return;
          }
          callback(null, result.result);
        });
      }
    };
    function resolveWriteConcern(parent, options2) {
      return WriteConcern.fromOptions(options2) || parent && parent.writeConcern;
    }
    function resolveReadConcern(parent, options2) {
      return ReadConcern.fromOptions(options2) || parent && parent.readConcern;
    }
    module2.exports = CommandOperationV2;
  }
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/mongodb/lib/operations/aggregate.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var maxWireVersion = require_utils2().maxWireVersion;
    var ReadPreference = require_core().ReadPreference;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DB_AGGREGATE_COLLECTION = 1;
    var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;
    var AggregateOperation = class extends CommandOperationV2 {
      constructor(parent, pipeline2, options2) {
        super(parent, options2, { fullResponse: true });
        this.target = parent.s.namespace && parent.s.namespace.collection ? parent.s.namespace.collection : DB_AGGREGATE_COLLECTION;
        this.pipeline = pipeline2;
        this.hasWriteStage = false;
        if (typeof options2.out === "string") {
          this.pipeline = this.pipeline.concat({ $out: options2.out });
          this.hasWriteStage = true;
        } else if (pipeline2.length > 0) {
          const finalStage = pipeline2[pipeline2.length - 1];
          if (finalStage.$out || finalStage.$merge) {
            this.hasWriteStage = true;
          }
        }
        if (this.hasWriteStage) {
          this.readPreference = ReadPreference.primary;
        }
        if (this.explain && this.writeConcern) {
          throw new MongoError('"explain" cannot be used on an aggregate call with writeConcern');
        }
        if (options2.cursor != null && typeof options2.cursor !== "object") {
          throw new MongoError("cursor options must be an object");
        }
      }
      get canRetryRead() {
        return !this.hasWriteStage;
      }
      addToPipeline(stage) {
        this.pipeline.push(stage);
      }
      execute(server, callback) {
        const options2 = this.options;
        const serverWireVersion = maxWireVersion(server);
        const command = { aggregate: this.target, pipeline: this.pipeline };
        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
          this.readConcern = null;
        }
        if (serverWireVersion >= 5) {
          if (this.hasWriteStage && this.writeConcern) {
            Object.assign(command, { writeConcern: this.writeConcern });
          }
        }
        if (options2.bypassDocumentValidation === true) {
          command.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        if (typeof options2.allowDiskUse === "boolean") {
          command.allowDiskUse = options2.allowDiskUse;
        }
        if (options2.hint) {
          command.hint = options2.hint;
        }
        if (this.explain) {
          options2.full = false;
        }
        command.cursor = options2.cursor || {};
        if (options2.batchSize && !this.hasWriteStage) {
          command.cursor.batchSize = options2.batchSize;
        }
        super.executeCommand(server, command, callback);
      }
    };
    defineAspects(AggregateOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = AggregateOperation;
  }
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS({
  "node_modules/mongodb/lib/bulk/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Long2 = require_core().BSON.Long;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().BSON.ObjectID;
    var BSON2 = require_core().BSON;
    var MongoWriteConcernError = require_core().MongoWriteConcernError;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var toError = require_utils4().toError;
    var handleCallback = require_utils4().handleCallback;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var isPromiseLike = require_utils4().isPromiseLike;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var maxWireVersion = require_utils2().maxWireVersion;
    var WRITE_CONCERN_ERROR = 64;
    var INSERT = 1;
    var UPDATE = 2;
    var REMOVE = 3;
    var bson = new BSON2([
      BSON2.Binary,
      BSON2.Code,
      BSON2.DBRef,
      BSON2.Decimal128,
      BSON2.Double,
      BSON2.Int32,
      BSON2.Long,
      BSON2.Map,
      BSON2.MaxKey,
      BSON2.MinKey,
      BSON2.ObjectId,
      BSON2.BSONRegExp,
      BSON2.Symbol,
      BSON2.Timestamp
    ]);
    var Batch = class {
      constructor(batchType, originalZeroIndex) {
        this.originalZeroIndex = originalZeroIndex;
        this.currentIndex = 0;
        this.originalIndexes = [];
        this.batchType = batchType;
        this.operations = [];
        this.size = 0;
        this.sizeBytes = 0;
      }
    };
    var kUpsertedIds = Symbol("upsertedIds");
    var kInsertedIds = Symbol("insertedIds");
    var BulkWriteResult = class {
      constructor(bulkResult) {
        this.result = bulkResult;
        this[kUpsertedIds] = void 0;
        this[kInsertedIds] = void 0;
      }
      get insertedCount() {
        return typeof this.result.nInserted !== "number" ? 0 : this.result.nInserted;
      }
      get matchedCount() {
        return typeof this.result.nMatched !== "number" ? 0 : this.result.nMatched;
      }
      get modifiedCount() {
        return typeof this.result.nModified !== "number" ? 0 : this.result.nModified;
      }
      get deletedCount() {
        return typeof this.result.nRemoved !== "number" ? 0 : this.result.nRemoved;
      }
      get upsertedCount() {
        return !this.result.upserted ? 0 : this.result.upserted.length;
      }
      get upsertedIds() {
        if (this[kUpsertedIds]) {
          return this[kUpsertedIds];
        }
        this[kUpsertedIds] = {};
        for (const doc of this.result.upserted || []) {
          this[kUpsertedIds][doc.index] = doc._id;
        }
        return this[kUpsertedIds];
      }
      get insertedIds() {
        if (this[kInsertedIds]) {
          return this[kInsertedIds];
        }
        this[kInsertedIds] = {};
        for (const doc of this.result.insertedIds || []) {
          this[kInsertedIds][doc.index] = doc._id;
        }
        return this[kInsertedIds];
      }
      get n() {
        return this.result.insertedCount;
      }
      get ok() {
        return this.result.ok;
      }
      get nInserted() {
        return this.result.nInserted;
      }
      get nUpserted() {
        return this.result.nUpserted;
      }
      get nMatched() {
        return this.result.nMatched;
      }
      get nModified() {
        return this.result.nModified;
      }
      get nRemoved() {
        return this.result.nRemoved;
      }
      getInsertedIds() {
        return this.result.insertedIds;
      }
      getUpsertedIds() {
        return this.result.upserted;
      }
      getUpsertedIdAt(index2) {
        return this.result.upserted[index2];
      }
      getRawResponse() {
        return this.result;
      }
      hasWriteErrors() {
        return this.result.writeErrors.length > 0;
      }
      getWriteErrorCount() {
        return this.result.writeErrors.length;
      }
      getWriteErrorAt(index2) {
        if (index2 < this.result.writeErrors.length) {
          return this.result.writeErrors[index2];
        }
        return null;
      }
      getWriteErrors() {
        return this.result.writeErrors;
      }
      getLastOp() {
        return this.result.lastOp;
      }
      getWriteConcernError() {
        if (this.result.writeConcernErrors.length === 0) {
          return null;
        } else if (this.result.writeConcernErrors.length === 1) {
          return this.result.writeConcernErrors[0];
        } else {
          let errmsg = "";
          for (let i = 0; i < this.result.writeConcernErrors.length; i++) {
            const err = this.result.writeConcernErrors[i];
            errmsg = errmsg + err.errmsg;
            if (i === 0)
              errmsg = errmsg + " and ";
          }
          return new WriteConcernError({ errmsg, code: WRITE_CONCERN_ERROR });
        }
      }
      toJSON() {
        return this.result;
      }
      toString() {
        return `BulkWriteResult(${this.toJSON(this.result)})`;
      }
      isOk() {
        return this.result.ok === 1;
      }
    };
    var WriteConcernError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      toJSON() {
        return { code: this.err.code, errmsg: this.err.errmsg };
      }
      toString() {
        return `WriteConcernError(${this.err.errmsg})`;
      }
    };
    var WriteError = class {
      constructor(err) {
        this.err = err;
      }
      get code() {
        return this.err.code;
      }
      get index() {
        return this.err.index;
      }
      get errmsg() {
        return this.err.errmsg;
      }
      getOperation() {
        return this.err.op;
      }
      toJSON() {
        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
      }
      toString() {
        return `WriteError(${JSON.stringify(this.toJSON())})`;
      }
    };
    function mergeBatchResults(batch, bulkResult, err, result) {
      if (err) {
        result = err;
      } else if (result && result.result) {
        result = result.result;
      } else if (result == null) {
        return;
      }
      if (result.ok === 0 && bulkResult.ok === 1) {
        bulkResult.ok = 0;
        const writeError = {
          index: 0,
          code: result.code || 0,
          errmsg: result.message,
          op: batch.operations[0]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
        return;
      } else if (result.ok === 0 && bulkResult.ok === 0) {
        return;
      }
      if (result.opTime || result.lastOp) {
        const opTime = result.lastOp || result.opTime;
        let lastOpTS = null;
        let lastOpT = null;
        if (opTime && opTime._bsontype === "Timestamp") {
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTime.greaterThan(bulkResult.lastOp)) {
            bulkResult.lastOp = opTime;
          }
        } else {
          if (bulkResult.lastOp) {
            lastOpTS = typeof bulkResult.lastOp.ts === "number" ? Long2.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
            lastOpT = typeof bulkResult.lastOp.t === "number" ? Long2.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
          }
          const opTimeTS = typeof opTime.ts === "number" ? Long2.fromNumber(opTime.ts) : opTime.ts;
          const opTimeT = typeof opTime.t === "number" ? Long2.fromNumber(opTime.t) : opTime.t;
          if (bulkResult.lastOp == null) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.greaterThan(lastOpTS)) {
            bulkResult.lastOp = opTime;
          } else if (opTimeTS.equals(lastOpTS)) {
            if (opTimeT.greaterThan(lastOpT)) {
              bulkResult.lastOp = opTime;
            }
          }
        }
      }
      if (batch.batchType === INSERT && result.n) {
        bulkResult.nInserted = bulkResult.nInserted + result.n;
      }
      if (batch.batchType === REMOVE && result.n) {
        bulkResult.nRemoved = bulkResult.nRemoved + result.n;
      }
      let nUpserted = 0;
      if (Array.isArray(result.upserted)) {
        nUpserted = result.upserted.length;
        for (let i = 0; i < result.upserted.length; i++) {
          bulkResult.upserted.push({
            index: result.upserted[i].index + batch.originalZeroIndex,
            _id: result.upserted[i]._id
          });
        }
      } else if (result.upserted) {
        nUpserted = 1;
        bulkResult.upserted.push({
          index: batch.originalZeroIndex,
          _id: result.upserted
        });
      }
      if (batch.batchType === UPDATE && result.n) {
        const nModified = result.nModified;
        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
        if (typeof nModified === "number") {
          bulkResult.nModified = bulkResult.nModified + nModified;
        } else {
          bulkResult.nModified = null;
        }
      }
      if (Array.isArray(result.writeErrors)) {
        for (let i = 0; i < result.writeErrors.length; i++) {
          const writeError = {
            index: batch.originalIndexes[result.writeErrors[i].index],
            code: result.writeErrors[i].code,
            errmsg: result.writeErrors[i].errmsg,
            op: batch.operations[result.writeErrors[i].index]
          };
          bulkResult.writeErrors.push(new WriteError(writeError));
        }
      }
      if (result.writeConcernError) {
        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
      }
    }
    function executeCommands(bulkOperation, options2, callback) {
      if (bulkOperation.s.batches.length === 0) {
        return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));
      }
      const batch = bulkOperation.s.batches.shift();
      function resultHandler(err, result) {
        if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {
          return handleCallback(callback, err);
        }
        if (err)
          err.ok = 0;
        if (err instanceof MongoWriteConcernError) {
          return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);
        }
        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
        if (mergeResult != null) {
          return handleCallback(callback, null, writeResult);
        }
        if (bulkOperation.handleWriteError(callback, writeResult))
          return;
        executeCommands(bulkOperation, options2, callback);
      }
      bulkOperation.finalOptionsHandler({ options: options2, batch, resultHandler }, callback);
    }
    function handleMongoWriteConcernError(batch, bulkResult, err, callback) {
      mergeBatchResults(batch, bulkResult, null, err.result);
      const wrappedWriteConcernError = new WriteConcernError({
        errmsg: err.result.writeConcernError.errmsg,
        code: err.result.writeConcernError.result
      });
      return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);
    }
    var BulkWriteError = class extends MongoError {
      constructor(error3, result) {
        const message = error3.err || error3.errmsg || error3.errMessage || error3;
        super(message);
        Object.assign(this, error3);
        this.name = "BulkWriteError";
        this.result = result;
      }
      get insertedCount() {
        return this.result.insertedCount;
      }
      get matchedCount() {
        return this.result.matchedCount;
      }
      get modifiedCount() {
        return this.result.modifiedCount;
      }
      get deletedCount() {
        return this.result.deletedCount;
      }
      get upsertedCount() {
        return this.result.upsertedCount;
      }
      get insertedIds() {
        return this.result.insertedIds;
      }
      get upsertedIds() {
        return this.result.upsertedIds;
      }
    };
    var FindOperators = class {
      constructor(bulkOperation) {
        this.s = bulkOperation.s;
      }
      update(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: true,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      updateOne(updateDocument) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: updateDocument,
          multi: false,
          upsert
        };
        if (updateDocument.hint) {
          document2.hint = updateDocument.hint;
        }
        if (!hasAtomicOperators(updateDocument)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      replaceOne(replacement) {
        const upsert = typeof this.s.currentOp.upsert === "boolean" ? this.s.currentOp.upsert : false;
        const document2 = {
          q: this.s.currentOp.selector,
          u: replacement,
          multi: false,
          upsert
        };
        if (replacement.hint) {
          document2.hint = replacement.hint;
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not use atomic operators");
        }
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, UPDATE, document2);
      }
      upsert() {
        this.s.currentOp.upsert = true;
        return this;
      }
      deleteOne() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 1
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      delete() {
        const document2 = {
          q: this.s.currentOp.selector,
          limit: 0
        };
        this.s.currentOp = null;
        return this.s.options.addToOperationsList(this, REMOVE, document2);
      }
      removeOne() {
        emitWarningOnce("bulk operation `removeOne` has been deprecated, please use `deleteOne`");
        return this.deleteOne();
      }
      remove() {
        emitWarningOnce("bulk operation `remove` has been deprecated, please use `delete`");
        return this.delete();
      }
    };
    var BulkOperationBase = class {
      constructor(topology, collection, options2, isOrdered) {
        this.isOrdered = isOrdered;
        options2 = options2 == null ? {} : options2;
        const namespace = collection.s.namespace;
        const executed = false;
        const currentOp = null;
        const bson2 = topology.bson;
        const isMaster = topology.lastIsMaster();
        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;
        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1e3;
        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, collection.s.db);
        finalOptions = applyWriteConcern(finalOptions, { collection }, options2);
        const writeConcern = finalOptions.writeConcern;
        const promiseLibrary = options2.promiseLibrary || Promise;
        const bulkResult = {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        };
        this.s = {
          bulkResult,
          currentBatch: null,
          currentIndex: 0,
          currentBatchSize: 0,
          currentBatchSizeBytes: 0,
          currentInsertBatch: null,
          currentUpdateBatch: null,
          currentRemoveBatch: null,
          batches: [],
          writeConcern,
          maxBsonObjectSize,
          maxBatchSizeBytes,
          maxWriteBatchSize,
          maxKeySize,
          namespace,
          bson: bson2,
          topology,
          options: finalOptions,
          currentOp,
          executed,
          collection,
          promiseLibrary,
          err: null,
          checkKeys: typeof options2.checkKeys === "boolean" ? options2.checkKeys : true
        };
        if (options2.bypassDocumentValidation === true) {
          this.s.bypassDocumentValidation = true;
        }
      }
      insert(document2) {
        if (this.s.collection.s.db.options.forceServerObjectId !== true && document2._id == null)
          document2._id = new ObjectID2();
        return this.s.options.addToOperationsList(this, INSERT, document2);
      }
      find(selector) {
        if (!selector) {
          throw toError("Bulk find operation must specify a selector");
        }
        this.s.currentOp = {
          selector
        };
        return new FindOperators(this);
      }
      raw(op) {
        const key = Object.keys(op)[0];
        const forceServerObjectId = typeof this.s.options.forceServerObjectId === "boolean" ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
        if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {
          op[key].multi = op.updateOne || op.replaceOne ? false : true;
          return this.s.options.addToOperationsList(this, UPDATE, op[key]);
        }
        if (op.updateOne || op.updateMany || op.replaceOne) {
          if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {
            throw new TypeError("Replacement document must not use atomic operators");
          } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {
            throw new TypeError("Update document requires atomic operators");
          }
          const multi = op.updateOne || op.replaceOne ? false : true;
          const operation = {
            q: op[key].filter,
            u: op[key].update || op[key].replacement,
            multi
          };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            operation.upsert = op[key].upsert ? true : false;
            if (op.collation)
              operation.collation = op.collation;
          } else {
            if (op[key].upsert)
              operation.upsert = true;
          }
          if (op[key].arrayFilters) {
            if (maxWireVersion(this.s.topology) < 6) {
              throw new TypeError("arrayFilters are only supported on MongoDB 3.6+");
            }
            operation.arrayFilters = op[key].arrayFilters;
          }
          return this.s.options.addToOperationsList(this, UPDATE, operation);
        }
        if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {
          op[key].limit = op.removeOne ? 1 : 0;
          return this.s.options.addToOperationsList(this, REMOVE, op[key]);
        }
        if (op.deleteOne || op.deleteMany) {
          const limit = op.deleteOne ? 1 : 0;
          const operation = { q: op[key].filter, limit };
          if (op[key].hint) {
            operation.hint = op[key].hint;
          }
          if (this.isOrdered) {
            if (op.collation)
              operation.collation = op.collation;
          }
          return this.s.options.addToOperationsList(this, REMOVE, operation);
        }
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null)
            op.insertOne._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne);
        } else if (op.insertOne && op.insertOne.document) {
          if (forceServerObjectId !== true && op.insertOne.document._id == null)
            op.insertOne.document._id = new ObjectID2();
          return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);
        }
        if (op.insertMany) {
          emitWarningOnce("bulk operation `insertMany` has been deprecated; use multiple `insertOne` ops instead");
          for (let i = 0; i < op.insertMany.length; i++) {
            if (forceServerObjectId !== true && op.insertMany[i]._id == null)
              op.insertMany[i]._id = new ObjectID2();
            this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);
          }
          return;
        }
        throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
      }
      _handleEarlyError(err, callback) {
        if (typeof callback === "function") {
          callback(err, null);
          return;
        }
        return this.s.promiseLibrary.reject(err);
      }
      bulkExecute(_writeConcern, options2, callback) {
        if (typeof options2 === "function")
          callback = options2, options2 = {};
        options2 = options2 || {};
        if (typeof _writeConcern === "function") {
          callback = _writeConcern;
        } else if (_writeConcern && typeof _writeConcern === "object") {
          this.s.writeConcern = _writeConcern;
        }
        if (this.s.executed) {
          const executedError = toError("batch cannot be re-executed");
          return this._handleEarlyError(executedError, callback);
        }
        if (this.isOrdered) {
          if (this.s.currentBatch)
            this.s.batches.push(this.s.currentBatch);
        } else {
          if (this.s.currentInsertBatch)
            this.s.batches.push(this.s.currentInsertBatch);
          if (this.s.currentUpdateBatch)
            this.s.batches.push(this.s.currentUpdateBatch);
          if (this.s.currentRemoveBatch)
            this.s.batches.push(this.s.currentRemoveBatch);
        }
        if (this.s.batches.length === 0) {
          const emptyBatchError = toError("Invalid Operation, no operations specified");
          return this._handleEarlyError(emptyBatchError, callback);
        }
        return { options: options2, callback };
      }
      execute(_writeConcern, options2, callback) {
        const ret = this.bulkExecute(_writeConcern, options2, callback);
        if (!ret || isPromiseLike(ret)) {
          return ret;
        }
        options2 = ret.options;
        callback = ret.callback;
        return executeLegacyOperation(this.s.topology, executeCommands, [this, options2, callback]);
      }
      finalOptionsHandler(config, callback) {
        const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);
        if (this.s.writeConcern != null) {
          finalOptions.writeConcern = this.s.writeConcern;
        }
        if (finalOptions.bypassDocumentValidation !== true) {
          delete finalOptions.bypassDocumentValidation;
        }
        if (this.operationId) {
          config.resultHandler.operationId = this.operationId;
        }
        if (this.s.options.serializeFunctions) {
          finalOptions.serializeFunctions = true;
        }
        if (this.s.options.ignoreUndefined) {
          finalOptions.ignoreUndefined = true;
        }
        if (this.s.bypassDocumentValidation === true) {
          finalOptions.bypassDocumentValidation = true;
        }
        if (this.s.checkKeys === false) {
          finalOptions.checkKeys = false;
        }
        if (finalOptions.retryWrites) {
          if (config.batch.batchType === UPDATE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.multi);
          }
          if (config.batch.batchType === REMOVE) {
            finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some((op) => op.limit === 0);
          }
        }
        try {
          if (config.batch.batchType === INSERT) {
            this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === UPDATE) {
            this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          } else if (config.batch.batchType === REMOVE) {
            this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);
          }
        } catch (err) {
          err.ok = 0;
          handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));
        }
      }
      handleWriteError(callback, writeResult) {
        if (this.s.bulkResult.writeErrors.length > 0) {
          const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
          handleCallback(callback, new BulkWriteError(toError({
            message: msg,
            code: this.s.bulkResult.writeErrors[0].code,
            writeErrors: this.s.bulkResult.writeErrors
          }), writeResult), null);
          return true;
        }
        if (writeResult.getWriteConcernError()) {
          handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);
          return true;
        }
      }
    };
    Object.defineProperty(BulkOperationBase.prototype, "length", {
      enumerable: true,
      get: function() {
        return this.s.currentIndex;
      }
    });
    module2.exports = {
      Batch,
      BulkOperationBase,
      bson,
      INSERT,
      UPDATE,
      REMOVE,
      BulkWriteError,
      BulkWriteResult
    };
  }
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS({
  "node_modules/mongodb/lib/bulk/unordered.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      bulkOperation.s.currentBatch = null;
      if (docType === common.INSERT) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;
      }
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      if (bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;
      if (docType === common.INSERT) {
        bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (docType === common.UPDATE) {
        bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;
      } else if (docType === common.REMOVE) {
        bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;
      }
      bulkOperation.s.currentBatch.size += 1;
      bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return bulkOperation;
    }
    var UnorderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, { addToOperationsList });
        super(topology, collection, options2, false);
      }
      handleWriteError(callback, writeResult) {
        if (this.s.batches.length) {
          return false;
        }
        return super.handleWriteError(callback, writeResult);
      }
    };
    function initializeUnorderedBulkOp(topology, collection, options2) {
      return new UnorderedBulkOperation(topology, collection, options2);
    }
    initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
    module2.exports = initializeUnorderedBulkOp;
    module2.exports.Bulk = UnorderedBulkOperation;
  }
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS({
  "node_modules/mongodb/lib/bulk/ordered.js"(exports2, module2) {
    init_shims();
    "use strict";
    var common = require_common2();
    var BulkOperationBase = common.BulkOperationBase;
    var Batch = common.Batch;
    var bson = common.bson;
    var utils2 = require_utils4();
    var toError = utils2.toError;
    function addToOperationsList(bulkOperation, docType, document2) {
      const bsonSize = bson.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= bulkOperation.s.maxBsonObjectSize)
        throw toError("document is larger than the maximum size " + bulkOperation.s.maxBsonObjectSize);
      if (bulkOperation.s.currentBatch == null)
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
      const maxKeySize = bulkOperation.s.maxKeySize;
      if (bulkOperation.s.currentBatchSize + 1 >= bulkOperation.s.maxWriteBatchSize || bulkOperation.s.currentBatchSize > 0 && bulkOperation.s.currentBatchSizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || bulkOperation.s.currentBatch.batchType !== docType) {
        bulkOperation.s.batches.push(bulkOperation.s.currentBatch);
        bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);
        bulkOperation.s.currentBatchSize = 0;
        bulkOperation.s.currentBatchSizeBytes = 0;
      }
      if (docType === common.INSERT) {
        bulkOperation.s.bulkResult.insertedIds.push({
          index: bulkOperation.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw toError("operation passed in cannot be an Array");
      }
      bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);
      bulkOperation.s.currentBatch.operations.push(document2);
      bulkOperation.s.currentBatchSize += 1;
      bulkOperation.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      bulkOperation.s.currentIndex += 1;
      return bulkOperation;
    }
    var OrderedBulkOperation = class extends BulkOperationBase {
      constructor(topology, collection, options2) {
        options2 = options2 || {};
        options2 = Object.assign(options2, { addToOperationsList });
        super(topology, collection, options2, true);
      }
    };
    function initializeOrderedBulkOp(topology, collection, options2) {
      return new OrderedBulkOperation(topology, collection, options2);
    }
    initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
    module2.exports = initializeOrderedBulkOp;
    module2.exports.Bulk = OrderedBulkOperation;
  }
});

// node_modules/mongodb/lib/aggregation_cursor.js
var require_aggregation_cursor = __commonJS({
  "node_modules/mongodb/lib/aggregation_cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var AggregationCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        this.operation.options.batchSize = value;
        this.setCursorBatchSize(value);
        return this;
      }
      geoNear(document2) {
        this.operation.addToPipeline({ $geoNear: document2 });
        return this;
      }
      group(document2) {
        this.operation.addToPipeline({ $group: document2 });
        return this;
      }
      limit(value) {
        this.operation.addToPipeline({ $limit: value });
        return this;
      }
      match(document2) {
        this.operation.addToPipeline({ $match: document2 });
        return this;
      }
      maxTimeMS(value) {
        this.operation.options.maxTimeMS = value;
        return this;
      }
      out(destination) {
        this.operation.addToPipeline({ $out: destination });
        return this;
      }
      project(document2) {
        this.operation.addToPipeline({ $project: document2 });
        return this;
      }
      lookup(document2) {
        this.operation.addToPipeline({ $lookup: document2 });
        return this;
      }
      redact(document2) {
        this.operation.addToPipeline({ $redact: document2 });
        return this;
      }
      skip(value) {
        this.operation.addToPipeline({ $skip: value });
        return this;
      }
      sort(document2) {
        this.operation.addToPipeline({ $sort: document2 });
        return this;
      }
      unwind(field) {
        this.operation.addToPipeline({ $unwind: field });
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
    module2.exports = AggregationCursor;
  }
});

// node_modules/mongodb/lib/command_cursor.js
var require_command_cursor = __commonJS({
  "node_modules/mongodb/lib/command_cursor.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var CursorState = require_cursor().CursorState;
    var CommandCursor = class extends Cursor {
      constructor(topology, ns, cmd, options2) {
        super(topology, ns, cmd, options2);
      }
      setReadPreference(readPreference) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (this.s.state !== CursorState.INIT) {
          throw MongoError.create({
            message: "cannot change cursor readPreference after cursor has been accessed",
            driver: true
          });
        }
        if (readPreference instanceof ReadPreference) {
          this.options.readPreference = readPreference;
        } else if (typeof readPreference === "string") {
          this.options.readPreference = new ReadPreference(readPreference);
        } else {
          throw new TypeError("Invalid read preference: " + readPreference);
        }
        return this;
      }
      batchSize(value) {
        if (this.s.state === CursorState.CLOSED || this.isDead()) {
          throw MongoError.create({ message: "Cursor is closed", driver: true });
        }
        if (typeof value !== "number") {
          throw MongoError.create({ message: "batchSize requires an integer", driver: true });
        }
        if (this.cmd.cursor) {
          this.cmd.cursor.batchSize = value;
        }
        this.setCursorBatchSize(value);
        return this;
      }
      maxTimeMS(value) {
        if (this.topology.lastIsMaster().minWireVersion > 2) {
          this.cmd.maxTimeMS = value;
        }
        return this;
      }
      getLogger() {
        return this.logger;
      }
    };
    CommandCursor.prototype.get = CommandCursor.prototype.toArray;
    module2.exports = CommandCursor;
  }
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS({
  "node_modules/mongodb/lib/operations/bulk_write.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = class extends OperationBase {
      constructor(collection, operations, options2) {
        super(options2);
        this.collection = collection;
        this.operations = operations;
      }
      execute(callback) {
        const coll = this.collection;
        const operations = this.operations;
        let options2 = this.options;
        if (coll.s.options.ignoreUndefined) {
          options2 = Object.assign({}, options2);
          options2.ignoreUndefined = coll.s.options.ignoreUndefined;
        }
        const bulk = options2.ordered === true || options2.ordered == null ? coll.initializeOrderedBulkOp(options2) : coll.initializeUnorderedBulkOp(options2);
        let collation = false;
        try {
          for (let i = 0; i < operations.length; i++) {
            const key = Object.keys(operations[i])[0];
            if (operations[i][key].collation) {
              collation = true;
            }
            bulk.raw(operations[i]);
          }
        } catch (err) {
          return callback(err, null);
        }
        let finalOptions = Object.assign({}, options2);
        finalOptions = applyRetryableWrites(finalOptions, coll.s.db);
        finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options2);
        const writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
        const capabilities = coll.s.topology.capabilities();
        if (collation && capabilities && !capabilities.commandsTakeCollation) {
          return callback(new MongoError("server/primary/mongos does not support collation"));
        }
        bulk.execute(writeCon, finalOptions, (err, r) => {
          if (!r && err) {
            return callback(err, null);
          }
          callback(null, r);
        });
      }
    };
    module2.exports = BulkWriteOperation;
  }
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS({
  "node_modules/mongodb/lib/operations/count_documents.js"(exports2, module2) {
    init_shims();
    "use strict";
    var AggregateOperation = require_aggregate();
    var CountDocumentsOperation = class extends AggregateOperation {
      constructor(collection, query, options2) {
        const pipeline2 = [{ $match: query }];
        if (typeof options2.skip === "number") {
          pipeline2.push({ $skip: options2.skip });
        }
        if (typeof options2.limit === "number") {
          pipeline2.push({ $limit: options2.limit });
        }
        pipeline2.push({ $group: { _id: 1, n: { $sum: 1 } } });
        super(collection, pipeline2, options2);
      }
      execute(server, callback) {
        super.execute(server, (err, result) => {
          if (err) {
            callback(err, null);
            return;
          }
          const response = result.result;
          if (response.cursor == null || response.cursor.firstBatch == null) {
            callback(null, 0);
            return;
          }
          const docs = response.cursor.firstBatch;
          callback(null, docs.length ? docs[0].n : 0);
        });
      }
    };
    module2.exports = CountDocumentsOperation;
  }
});

// node_modules/mongodb/lib/operations/create_indexes.js
var require_create_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/create_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var MongoError = require_core().MongoError;
    var parseIndexOptions = require_utils4().parseIndexOptions;
    var maxWireVersion = require_utils2().maxWireVersion;
    var VALID_INDEX_OPTIONS = new Set([
      "background",
      "unique",
      "name",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "storageEngine",
      "collation",
      "weights",
      "default_language",
      "language_override",
      "textIndexVersion",
      "2dsphereIndexVersion",
      "bits",
      "min",
      "max",
      "bucketSize",
      "wildcardProjection"
    ]);
    var CreateIndexesOperation = class extends CommandOperationV2 {
      constructor(parent, collection, indexes, options2) {
        super(parent, options2);
        this.collection = collection;
        if (!Array.isArray(indexes) || Array.isArray(indexes[0])) {
          this.onlyReturnNameOfCreatedIndex = true;
          const indexParameters = parseIndexOptions(indexes);
          const name2 = typeof options2.name === "string" ? options2.name : indexParameters.name;
          const indexSpec = { name: name2, key: indexParameters.fieldHash };
          for (let optionName in options2) {
            if (VALID_INDEX_OPTIONS.has(optionName)) {
              indexSpec[optionName] = options2[optionName];
            }
          }
          this.indexes = [indexSpec];
          return;
        }
        this.indexes = indexes;
      }
      execute(server, callback) {
        const options2 = this.options;
        const indexes = this.indexes;
        const serverWireVersion = maxWireVersion(server);
        for (let i = 0; i < indexes.length; i++) {
          if (indexes[i].collation && serverWireVersion < 5) {
            callback(new MongoError(`Server ${server.name}, which reports wire version ${serverWireVersion}, does not support collation`));
            return;
          }
          if (indexes[i].name == null) {
            const keys = [];
            for (let name2 in indexes[i].key) {
              keys.push(`${name2}_${indexes[i].key[name2]}`);
            }
            indexes[i].name = keys.join("_");
          }
        }
        const cmd = { createIndexes: this.collection, indexes };
        if (options2.commitQuorum != null) {
          if (serverWireVersion < 9) {
            callback(new MongoError("`commitQuorum` option for `createIndexes` not supported on servers < 4.4"));
            return;
          }
          cmd.commitQuorum = options2.commitQuorum;
        }
        this.options.collation = void 0;
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.onlyReturnNameOfCreatedIndex ? indexes[0].name : result);
        });
      }
    };
    defineAspects(CreateIndexesOperation, [Aspect.WRITE_OPERATION, Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = CreateIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_many.js
var require_delete_many = __commonJS({
  "node_modules/mongodb/lib/operations/delete_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteManyOperation = class extends OperationBase {
      constructor(collection, filter2, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter2;
      }
      execute(callback) {
        const coll = this.collection;
        const filter2 = this.filter;
        const options2 = this.options;
        options2.single = false;
        removeDocuments(coll, filter2, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteManyOperation;
  }
});

// node_modules/mongodb/lib/operations/delete_one.js
var require_delete_one = __commonJS({
  "node_modules/mongodb/lib/operations/delete_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var removeDocuments = require_common_functions().removeDocuments;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DeleteOneOperation = class extends OperationBase {
      constructor(collection, filter2, options2) {
        super(options2);
        this.collection = collection;
        this.filter = filter2;
      }
      execute(callback) {
        const coll = this.collection;
        const filter2 = this.filter;
        const options2 = this.options;
        options2.single = true;
        removeDocuments(coll, filter2, options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.deletedCount = r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(DeleteOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = DeleteOneOperation;
  }
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS({
  "node_modules/mongodb/lib/operations/distinct.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var DistinctOperation = class extends CommandOperationV2 {
      constructor(collection, key, query, options2) {
        super(collection, options2);
        this.collection = collection;
        this.key = key;
        this.query = query;
      }
      execute(server, callback) {
        const coll = this.collection;
        const key = this.key;
        const query = this.query;
        const options2 = this.options;
        const cmd = {
          distinct: coll.collectionName,
          key,
          query
        };
        if (typeof options2.maxTimeMS === "number") {
          cmd.maxTimeMS = options2.maxTimeMS;
        }
        decorateWithReadConcern(cmd, coll, options2);
        try {
          decorateWithCollation(cmd, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain && maxWireVersion(server) < 4) {
          callback(new MongoError(`server does not support explain on distinct`));
          return;
        }
        super.executeCommand(server, cmd, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, this.options.full || this.explain ? result : result.values);
        });
      }
    };
    defineAspects(DistinctOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = DistinctOperation;
  }
});

// node_modules/mongodb/lib/operations/command.js
var require_command2 = __commonJS({
  "node_modules/mongodb/lib/operations/command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var debugOptions = require_utils4().debugOptions;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var debugFields = [
      "authSource",
      "w",
      "wtimeout",
      "j",
      "native_parser",
      "forceServerObjectId",
      "serializeFunctions",
      "raw",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "bufferMaxEntries",
      "numberOfRetries",
      "retryMiliSeconds",
      "readPreference",
      "pkFactory",
      "parentDb",
      "promiseLibrary",
      "noListener"
    ];
    var CommandOperation = class extends OperationBase {
      constructor(db, options2, collection, command) {
        super(options2);
        if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (collection != null) {
            this.options.readPreference = ReadPreference.resolve(collection, options2);
          } else {
            this.options.readPreference = ReadPreference.resolve(db, options2);
          }
        } else {
          if (collection != null) {
            applyWriteConcern(this.options, { db, coll: collection }, this.options);
          } else {
            applyWriteConcern(this.options, { db }, this.options);
          }
          this.options.readPreference = ReadPreference.primary;
        }
        this.db = db;
        if (command != null) {
          this.command = command;
        }
        if (collection != null) {
          this.collection = collection;
        }
      }
      _buildCommand() {
        if (this.command != null) {
          return this.command;
        }
      }
      execute(callback) {
        const db = this.db;
        const options2 = Object.assign({}, this.options);
        if (db.serverConfig && db.serverConfig.isDestroyed()) {
          return callback(new MongoError("topology was destroyed"));
        }
        let command;
        try {
          command = this._buildCommand();
        } catch (e) {
          return callback(e);
        }
        const dbName = options2.dbName || options2.authdb || db.databaseName;
        if (this.hasAspect(Aspect.WRITE_OPERATION)) {
          if (options2.writeConcern && (!options2.session || !options2.session.inTransaction())) {
            command.writeConcern = options2.writeConcern;
          }
        }
        if (db.s.logger.isDebug()) {
          db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options2))}]`);
        }
        const namespace = this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, "$cmd");
        db.s.topology.command(namespace, command, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (options2.full)
            return handleCallback(callback, null, result);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = CommandOperation;
  }
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS({
  "node_modules/mongodb/lib/operations/drop.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var DropOperation = class extends CommandOperation {
      constructor(db, options2) {
        const finalOptions = Object.assign({}, options2, db.s.options);
        if (options2.session) {
          finalOptions.session = options2.session;
        }
        super(db, finalOptions);
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok)
            return handleCallback(callback, null, true);
          handleCallback(callback, null, false);
        });
      }
    };
    defineAspects(DropOperation, Aspect.WRITE_OPERATION);
    var DropCollectionOperation = class extends DropOperation {
      constructor(db, name2, options2) {
        super(db, options2);
        this.name = name2;
        this.namespace = `${db.namespace}.${name2}`;
      }
      _buildCommand() {
        return { drop: this.name };
      }
    };
    var DropDatabaseOperation = class extends DropOperation {
      _buildCommand() {
        return { dropDatabase: 1 };
      }
    };
    module2.exports = {
      DropOperation,
      DropCollectionOperation,
      DropDatabaseOperation
    };
  }
});

// node_modules/mongodb/lib/operations/drop_index.js
var require_drop_index = __commonJS({
  "node_modules/mongodb/lib/operations/drop_index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var handleCallback = require_utils4().handleCallback;
    var DropIndexOperation = class extends CommandOperation {
      constructor(collection, indexName, options2) {
        super(collection.s.db, options2, collection);
        this.collection = collection;
        this.indexName = indexName;
      }
      _buildCommand() {
        const collection = this.collection;
        const indexName = this.indexName;
        const options2 = this.options;
        let cmd = { dropIndexes: collection.collectionName, index: indexName };
        cmd = applyWriteConcern(cmd, { db: collection.s.db, collection }, options2);
        return cmd;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (typeof callback !== "function")
            return;
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(DropIndexOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/drop_indexes.js
var require_drop_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/drop_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var DropIndexOperation = require_drop_index();
    var handleCallback = require_utils4().handleCallback;
    var DropIndexesOperation = class extends DropIndexOperation {
      constructor(collection, options2) {
        super(collection, "*", options2);
      }
      execute(callback) {
        super.execute((err) => {
          if (err)
            return handleCallback(callback, err, false);
          handleCallback(callback, null, true);
        });
      }
    };
    defineAspects(DropIndexesOperation, Aspect.WRITE_OPERATION);
    module2.exports = DropIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS({
  "node_modules/mongodb/lib/operations/estimated_document_count.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var EstimatedDocumentCountOperation = class extends CommandOperationV2 {
      constructor(collection, query, options2) {
        if (typeof options2 === "undefined") {
          options2 = query;
          query = void 0;
        }
        super(collection, options2);
        this.collectionName = collection.s.namespace.collection;
        if (query) {
          this.query = query;
        }
      }
      execute(server, callback) {
        const options2 = this.options;
        const cmd = { count: this.collectionName };
        if (this.query) {
          cmd.query = this.query;
        }
        if (typeof options2.skip === "number") {
          cmd.skip = options2.skip;
        }
        if (typeof options2.limit === "number") {
          cmd.limit = options2.limit;
        }
        if (options2.hint) {
          cmd.hint = options2.hint;
        }
        super.executeCommand(server, cmd, (err, response) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, response.n);
        });
      }
    };
    defineAspects(EstimatedDocumentCountOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = EstimatedDocumentCountOperation;
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS({
  "node_modules/mongodb/lib/operations/find.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error().MongoError;
    var FindOperation = class extends OperationBase {
      constructor(collection, ns, command, options2) {
        super(options2);
        this.ns = ns;
        this.cmd = command;
        this.readPreference = ReadPreference.resolve(collection, this.options);
      }
      execute(server, callback) {
        this.server = server;
        this.readPreference = ReadPreference.resolve(this, this.options);
        if (typeof this.cmd.allowDiskUse !== "undefined" && maxWireVersion(server) < 4) {
          callback(new MongoError("The `allowDiskUse` option is not supported on MongoDB < 3.2"));
          return;
        }
        if (this.explain) {
          this.options.explain = this.explain.verbosity;
        }
        const cursorState = this.cursorState || {};
        server.query(this.ns.toString(), this.cmd, cursorState, this.options, callback);
      }
    };
    defineAspects(FindOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION,
      Aspect.EXPLAINABLE
    ]);
    module2.exports = FindOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one.js
var require_find_one = __commonJS({
  "node_modules/mongodb/lib/operations/find_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var handleCallback = require_utils4().handleCallback;
    var OperationBase = require_operation().OperationBase;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var FindOneOperation = class extends OperationBase {
      constructor(collection, query, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const options2 = this.options;
        try {
          const cursor = coll.find(query, options2).limit(-1).batchSize(1);
          cursor.next((err, item) => {
            if (err != null)
              return handleCallback(callback, toError(err), null);
            handleCallback(callback, null, item);
          });
        } catch (e) {
          callback(e);
        }
      }
    };
    defineAspects(FindOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindOneOperation;
  }
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS({
  "node_modules/mongodb/lib/operations/find_and_modify.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyRetryableWrites = require_utils4().applyRetryableWrites;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var executeCommand = require_db_ops().executeCommand;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var FindAndModifyOperation = class extends OperationBase {
      constructor(collection, query, sort, doc, options2) {
        super(options2);
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const query = this.query;
        const sort = formattedOrderClause(this.sort);
        const doc = this.doc;
        let options2 = this.options;
        let queryObject = {
          findAndModify: coll.collectionName,
          query
        };
        if (sort) {
          queryObject.sort = sort;
        }
        queryObject.new = options2.new ? true : false;
        queryObject.remove = options2.remove ? true : false;
        queryObject.upsert = options2.upsert ? true : false;
        const projection = options2.projection || options2.fields;
        if (projection) {
          queryObject.fields = projection;
        }
        if (options2.arrayFilters) {
          queryObject.arrayFilters = options2.arrayFilters;
        }
        if (doc && !options2.remove) {
          queryObject.update = doc;
        }
        if (options2.maxTimeMS)
          queryObject.maxTimeMS = options2.maxTimeMS;
        options2.serializeFunctions = options2.serializeFunctions || coll.s.serializeFunctions;
        options2.checkKeys = false;
        options2 = applyRetryableWrites(options2, coll.s.db);
        options2 = applyWriteConcern(options2, { db: coll.s.db, collection: coll }, options2);
        if (options2.writeConcern) {
          queryObject.writeConcern = options2.writeConcern;
        }
        if (options2.bypassDocumentValidation === true) {
          queryObject.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        options2.readPreference = ReadPreference.primary;
        try {
          decorateWithCollation(queryObject, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (options2.hint) {
          const unacknowledgedWrite = options2.writeConcern && options2.writeConcern.w === 0;
          if (unacknowledgedWrite || maxWireVersion(coll.s.topology) < 8) {
            callback(new MongoError("The current topology does not support a hint on findAndModify commands"));
            return;
          }
          queryObject.hint = options2.hint;
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 4) {
            callback(new MongoError(`server does not support explain on findAndModify`));
            return;
          }
          queryObject = decorateWithExplain(queryObject, this.explain);
        }
        executeCommand(coll.s.db, queryObject, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          return handleCallback(callback, null, result);
        });
      }
    };
    defineAspects(FindAndModifyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = FindAndModifyOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_delete.js
var require_find_one_and_delete = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_delete.js"(exports2, module2) {
    init_shims();
    "use strict";
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, options2) {
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.remove = true;
        if (filter2 == null || typeof filter2 !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        super(collection, filter2, finalOptions.sort, null, finalOptions);
      }
    };
    module2.exports = FindOneAndDeleteOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_replace.js
var require_find_one_and_replace = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_replace.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndReplaceOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, replacement, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndReplace option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter2 == null || typeof filter2 !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (replacement == null || typeof replacement !== "object") {
          throw new TypeError("Replacement parameter must be an object");
        }
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        super(collection, filter2, finalOptions.sort, replacement, finalOptions);
      }
    };
    module2.exports = FindOneAndReplaceOperation;
  }
});

// node_modules/mongodb/lib/operations/find_one_and_update.js
var require_find_one_and_update = __commonJS({
  "node_modules/mongodb/lib/operations/find_one_and_update.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var FindAndModifyOperation = require_find_and_modify();
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var FindOneAndUpdateOperation = class extends FindAndModifyOperation {
      constructor(collection, filter2, update2, options2) {
        if ("returnDocument" in options2 && "returnOriginal" in options2) {
          throw new MongoError("findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined");
        }
        const finalOptions = Object.assign({}, options2);
        finalOptions.fields = options2.projection;
        finalOptions.update = true;
        finalOptions.new = options2.returnDocument === "after" || options2.returnOriginal === false;
        finalOptions.upsert = options2.upsert === true;
        if (filter2 == null || typeof filter2 !== "object") {
          throw new TypeError("Filter parameter must be an object");
        }
        if (update2 == null || typeof update2 !== "object") {
          throw new TypeError("Update parameter must be an object");
        }
        if (!hasAtomicOperators(update2)) {
          throw new TypeError("Update document requires atomic operators");
        }
        super(collection, filter2, finalOptions.sort, update2, finalOptions);
      }
    };
    module2.exports = FindOneAndUpdateOperation;
  }
});

// node_modules/mongodb/lib/operations/geo_haystack_search.js
var require_geo_haystack_search = __commonJS({
  "node_modules/mongodb/lib/operations/geo_haystack_search.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var OperationBase = require_operation().OperationBase;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var GeoHaystackSearchOperation = class extends OperationBase {
      constructor(collection, x, y2, options2) {
        super(options2);
        this.collection = collection;
        this.x = x;
        this.y = y2;
      }
      execute(callback) {
        const coll = this.collection;
        const x = this.x;
        const y2 = this.y;
        let options2 = this.options;
        let commandObject = {
          geoSearch: coll.collectionName,
          near: [x, y2]
        };
        commandObject = decorateCommand(commandObject, options2, ["readPreference", "session"]);
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        decorateWithReadConcern(commandObject, coll, options2);
        executeCommand(coll.s.db, commandObject, options2, (err, res) => {
          if (err)
            return handleCallback(callback, err);
          if (res.err || res.errmsg)
            handleCallback(callback, toError(res));
          handleCallback(callback, null, res);
        });
      }
    };
    defineAspects(GeoHaystackSearchOperation, Aspect.READ_OPERATION);
    module2.exports = GeoHaystackSearchOperation;
  }
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexesOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        let options2 = this.options;
        options2 = Object.assign({}, { full: true }, options2);
        indexInformation(coll.s.db, coll.collectionName, options2, callback);
      }
    };
    module2.exports = IndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/index_exists.js
var require_index_exists = __commonJS({
  "node_modules/mongodb/lib/operations/index_exists.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var indexInformationDb = require_db_ops().indexInformation;
    var IndexExistsOperation = class extends OperationBase {
      constructor(collection, indexes, options2) {
        super(options2);
        this.collection = collection;
        this.indexes = indexes;
      }
      execute(callback) {
        const coll = this.collection;
        const indexes = this.indexes;
        const options2 = this.options;
        indexInformationDb(coll.s.db, coll.collectionName, options2, (err, indexInformation) => {
          if (err != null)
            return handleCallback(callback, err, null);
          if (!Array.isArray(indexes))
            return handleCallback(callback, null, indexInformation[indexes] != null);
          for (let i = 0; i < indexes.length; i++) {
            if (indexInformation[indexes[i]] == null) {
              return handleCallback(callback, null, false);
            }
          }
          return handleCallback(callback, null, true);
        });
      }
    };
    module2.exports = IndexExistsOperation;
  }
});

// node_modules/mongodb/lib/operations/index_information.js
var require_index_information = __commonJS({
  "node_modules/mongodb/lib/operations/index_information.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var indexInformation = require_common_functions().indexInformation;
    var IndexInformationOperation = class extends OperationBase {
      constructor(db, name2, options2) {
        super(options2);
        this.db = db;
        this.name = name2;
      }
      execute(callback) {
        const db = this.db;
        const name2 = this.name;
        const options2 = this.options;
        indexInformation(db, name2, options2, callback);
      }
    };
    module2.exports = IndexInformationOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_many.js
var require_insert_many = __commonJS({
  "node_modules/mongodb/lib/operations/insert_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var BulkWriteOperation = require_bulk_write();
    var MongoError = require_core().MongoError;
    var prepareDocs = require_common_functions().prepareDocs;
    var InsertManyOperation = class extends OperationBase {
      constructor(collection, docs, options2) {
        super(options2);
        this.collection = collection;
        this.docs = docs;
      }
      execute(callback) {
        const coll = this.collection;
        let docs = this.docs;
        const options2 = this.options;
        if (!Array.isArray(docs)) {
          return callback(MongoError.create({ message: "docs parameter must be an array of documents", driver: true }));
        }
        options2["serializeFunctions"] = options2["serializeFunctions"] || coll.s.serializeFunctions;
        docs = prepareDocs(coll, docs, options2);
        const operations = docs.map((document2) => ({ insertOne: { document: document2 } }));
        const bulkWriteOperation = new BulkWriteOperation(coll, operations, options2);
        bulkWriteOperation.execute((err, result) => {
          if (err)
            return callback(err, null);
          callback(null, mapInsertManyResults(docs, result));
        });
      }
    };
    function mapInsertManyResults(docs, r) {
      const finalResult = {
        result: { ok: 1, n: r.insertedCount },
        ops: docs,
        insertedCount: r.insertedCount,
        insertedIds: r.insertedIds
      };
      if (r.getLastOp()) {
        finalResult.result.opTime = r.getLastOp();
      }
      return finalResult;
    }
    module2.exports = InsertManyOperation;
  }
});

// node_modules/mongodb/lib/operations/insert_one.js
var require_insert_one = __commonJS({
  "node_modules/mongodb/lib/operations/insert_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoError = require_core().MongoError;
    var OperationBase = require_operation().OperationBase;
    var insertDocuments = require_common_functions().insertDocuments;
    var InsertOneOperation = class extends OperationBase {
      constructor(collection, doc, options2) {
        super(options2);
        this.collection = collection;
        this.doc = doc;
      }
      execute(callback) {
        const coll = this.collection;
        const doc = this.doc;
        const options2 = this.options;
        if (Array.isArray(doc)) {
          return callback(MongoError.create({ message: "doc parameter must be an object", driver: true }));
        }
        insertDocuments(coll, [doc], options2, (err, r) => {
          if (callback == null)
            return;
          if (err && callback)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          r.insertedCount = r.result.n;
          r.insertedId = doc._id;
          if (callback)
            callback(null, r);
        });
      }
    };
    module2.exports = InsertOneOperation;
  }
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS({
  "node_modules/mongodb/lib/operations/options_operation.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var OptionsOperation = class extends OperationBase {
      constructor(collection, options2) {
        super(options2);
        this.collection = collection;
      }
      execute(callback) {
        const coll = this.collection;
        const opts = this.options;
        coll.s.db.listCollections({ name: coll.collectionName }, opts).toArray((err, collections) => {
          if (err)
            return handleCallback(callback, err);
          if (collections.length === 0) {
            return handleCallback(callback, MongoError.create({ message: `collection ${coll.namespace} not found`, driver: true }));
          }
          handleCallback(callback, err, collections[0].options || null);
        });
      }
    };
    module2.exports = OptionsOperation;
  }
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS({
  "node_modules/mongodb/lib/operations/is_capped.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OptionsOperation = require_options_operation();
    var handleCallback = require_utils4().handleCallback;
    var IsCappedOperation = class extends OptionsOperation {
      constructor(collection, options2) {
        super(collection, options2);
      }
      execute(callback) {
        super.execute((err, document2) => {
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, !!(document2 && document2.capped));
        });
      }
    };
    module2.exports = IsCappedOperation;
  }
});

// node_modules/mongodb/lib/operations/list_indexes.js
var require_list_indexes = __commonJS({
  "node_modules/mongodb/lib/operations/list_indexes.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var LIST_INDEXES_WIRE_VERSION = 3;
    var ListIndexesOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2, { fullResponse: true });
        this.collectionNamespace = collection.s.namespace;
      }
      execute(server, callback) {
        const serverWireVersion = maxWireVersion(server);
        if (serverWireVersion < LIST_INDEXES_WIRE_VERSION) {
          const systemIndexesNS = this.collectionNamespace.withCollection("system.indexes").toString();
          const collectionNS = this.collectionNamespace.toString();
          server.query(systemIndexesNS, { query: { ns: collectionNS } }, {}, this.options, callback);
          return;
        }
        const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
        super.executeCommand(server, { listIndexes: this.collectionNamespace.collection, cursor }, callback);
      }
    };
    defineAspects(ListIndexesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListIndexesOperation;
  }
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS({
  "node_modules/mongodb/lib/operations/add_user.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var crypto = __require("crypto");
    var handleCallback = require_utils4().handleCallback;
    var toError = require_utils4().toError;
    var emitWarning = require_utils4().emitWarning;
    var AddUserOperation = class extends CommandOperation {
      constructor(db, username, password, options2) {
        super(db, options2);
        this.username = username;
        this.password = password;
      }
      _buildCommand() {
        const db = this.db;
        const username = this.username;
        const password = this.password;
        const options2 = this.options;
        let roles = [];
        if (Array.isArray(options2.roles))
          roles = options2.roles;
        if (typeof options2.roles === "string")
          roles = [options2.roles];
        if (roles.length === 0) {
          emitWarning("Creating a user without roles is deprecated in MongoDB >= 2.6");
        }
        if ((db.databaseName.toLowerCase() === "admin" || options2.dbName === "admin") && !Array.isArray(options2.roles)) {
          roles = ["root"];
        } else if (!Array.isArray(options2.roles)) {
          roles = ["dbOwner"];
        }
        const digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7;
        let userPassword = password;
        if (!digestPassword) {
          const md5 = crypto.createHash("md5");
          md5.update(username + ":mongo:" + password);
          userPassword = md5.digest("hex");
        }
        const command = {
          createUser: username,
          customData: options2.customData || {},
          roles,
          digestPassword
        };
        if (typeof password === "string") {
          command.pwd = userPassword;
        }
        return command;
      }
      execute(callback) {
        const options2 = this.options;
        if (options2.digestPassword != null) {
          return callback(toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option."));
        }
        super.execute((err, r) => {
          if (!err) {
            return handleCallback(callback, err, r);
          }
          return handleCallback(callback, err, null);
        });
      }
    };
    defineAspects(AddUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = AddUserOperation;
  }
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS({
  "node_modules/mongodb/lib/operations/collections.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var collection;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    var CollectionsOperation = class extends OperationBase {
      constructor(db, options2) {
        super(options2);
        this.db = db;
      }
      execute(callback) {
        const db = this.db;
        let options2 = this.options;
        let Collection = loadCollection();
        options2 = Object.assign({}, options2, { nameOnly: true });
        db.listCollections({}, options2).toArray((err, documents) => {
          if (err != null)
            return handleCallback(callback, err, null);
          documents = documents.filter((doc) => {
            return doc.name.indexOf("$") === -1;
          });
          handleCallback(callback, null, documents.map((d3) => {
            return new Collection(db, db.s.topology, db.databaseName, d3.name, db.s.pkFactory, db.s.options);
          }));
        });
      }
    };
    module2.exports = CollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS({
  "node_modules/mongodb/lib/operations/run_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var defineAspects = require_operation().defineAspects;
    var Aspect = require_operation().Aspect;
    var RunCommandOperation = class extends CommandOperationV2 {
      constructor(parent, command, options2) {
        super(parent, options2);
        this.command = command;
      }
      execute(server, callback) {
        const command = this.command;
        this.executeCommand(server, command, callback);
      }
    };
    defineAspects(RunCommandOperation, [Aspect.EXECUTE_WITH_SELECTION, Aspect.NO_INHERIT_OPTIONS]);
    module2.exports = RunCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS({
  "node_modules/mongodb/lib/operations/create_collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperation = require_command2();
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var MongoError = require_core().MongoError;
    var ReadPreference = require_core().ReadPreference;
    var ILLEGAL_COMMAND_FIELDS = new Set([
      "w",
      "wtimeout",
      "j",
      "fsync",
      "autoIndexId",
      "strict",
      "serializeFunctions",
      "pkFactory",
      "raw",
      "readPreference",
      "session",
      "readConcern",
      "writeConcern"
    ]);
    var CreateCollectionOperation = class extends CommandOperation {
      constructor(db, name2, options2) {
        super(db, options2);
        this.name = name2;
      }
      _buildCommand() {
        const name2 = this.name;
        const options2 = this.options;
        const cmd = { create: name2 };
        for (let n in options2) {
          if (options2[n] != null && typeof options2[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options2[n];
          }
        }
        return cmd;
      }
      execute(callback) {
        const db = this.db;
        const name2 = this.name;
        const options2 = this.options;
        const Collection = loadCollection();
        let listCollectionOptions = Object.assign({ nameOnly: true, strict: false }, options2);
        listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);
        function done(err) {
          if (err) {
            return callback(err);
          }
          try {
            callback(null, new Collection(db, db.s.topology, db.databaseName, name2, db.s.pkFactory, options2));
          } catch (err2) {
            callback(err2);
          }
        }
        const strictMode = listCollectionOptions.strict;
        if (strictMode) {
          db.listCollections({ name: name2 }, listCollectionOptions).setReadPreference(ReadPreference.PRIMARY).toArray((err, collections) => {
            if (err) {
              return callback(err);
            }
            if (collections.length > 0) {
              return callback(new MongoError(`Collection ${name2} already exists. Currently in strict mode.`));
            }
            super.execute(done);
          });
          return;
        }
        super.execute(done);
      }
    };
    defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
    module2.exports = CreateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/execute_db_admin_command.js
var require_execute_db_admin_command = __commonJS({
  "node_modules/mongodb/lib/operations/execute_db_admin_command.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var handleCallback = require_utils4().handleCallback;
    var MongoError = require_core().MongoError;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ExecuteDbAdminCommandOperation = class extends OperationBase {
      constructor(db, selector, options2) {
        super(options2);
        this.db = db;
        this.selector = selector;
      }
      execute(callback) {
        const db = this.db;
        const selector = this.selector;
        const options2 = this.options;
        const namespace = new MongoDBNamespace("admin", "$cmd");
        db.s.topology.command(namespace, selector, options2, (err, result) => {
          if (db.serverConfig && db.serverConfig.isDestroyed()) {
            return callback(new MongoError("topology was destroyed"));
          }
          if (err)
            return handleCallback(callback, err);
          handleCallback(callback, null, result.result);
        });
      }
    };
    module2.exports = ExecuteDbAdminCommandOperation;
  }
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS({
  "node_modules/mongodb/lib/operations/list_collections.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var maxWireVersion = require_utils2().maxWireVersion;
    var CONSTANTS = require_constants2();
    var LIST_COLLECTIONS_WIRE_VERSION = 3;
    function listCollectionsTransforms(databaseName) {
      const matching = `${databaseName}.`;
      return {
        doc: (doc) => {
          const index2 = doc.name.indexOf(matching);
          if (doc.name && index2 === 0) {
            doc.name = doc.name.substr(index2 + matching.length);
          }
          return doc;
        }
      };
    }
    var ListCollectionsOperation = class extends CommandOperationV2 {
      constructor(db, filter2, options2) {
        super(db, options2, { fullResponse: true });
        this.db = db;
        this.filter = filter2;
        this.nameOnly = !!this.options.nameOnly;
        if (typeof this.options.batchSize === "number") {
          this.batchSize = this.options.batchSize;
        }
      }
      execute(server, callback) {
        if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {
          let filter2 = this.filter;
          const databaseName = this.db.s.namespace.db;
          if (typeof filter2.name === "string" && !new RegExp("^" + databaseName + "\\.").test(filter2.name)) {
            filter2 = Object.assign({}, filter2);
            filter2.name = this.db.s.namespace.withCollection(filter2.name).toString();
          }
          if (filter2 == null) {
            filter2.name = `/${databaseName}/`;
          }
          if (filter2.name) {
            filter2 = { $and: [{ name: filter2.name }, { name: /^((?!\$).)*$/ }] };
          } else {
            filter2 = { name: /^((?!\$).)*$/ };
          }
          const transforms = listCollectionsTransforms(databaseName);
          server.query(`${databaseName}.${CONSTANTS.SYSTEM_NAMESPACE_COLLECTION}`, { query: filter2 }, { batchSize: this.batchSize || 1e3 }, {}, (err, result) => {
            if (result && result.message && result.message.documents && Array.isArray(result.message.documents)) {
              result.message.documents = result.message.documents.map(transforms.doc);
            }
            callback(err, result);
          });
          return;
        }
        const command = {
          listCollections: 1,
          filter: this.filter,
          cursor: this.batchSize ? { batchSize: this.batchSize } : {},
          nameOnly: this.nameOnly
        };
        return super.executeCommand(server, command, callback);
      }
    };
    defineAspects(ListCollectionsOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListCollectionsOperation;
  }
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/profiling_level.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var ProfilingLevelOperation = class extends CommandOperation {
      constructor(db, command, options2) {
        super(db, options2);
      }
      _buildCommand() {
        const command = { profile: -1 };
        return command;
      }
      execute(callback) {
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1) {
            const was = doc.was;
            if (was === 0)
              return callback(null, "off");
            if (was === 1)
              return callback(null, "slow_only");
            if (was === 2)
              return callback(null, "all");
            return callback(new Error("Error: illegal profiling level value " + was), null);
          } else {
            err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
          }
        });
      }
    };
    module2.exports = ProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS({
  "node_modules/mongodb/lib/operations/remove_user.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var handleCallback = require_utils4().handleCallback;
    var WriteConcern = require_write_concern();
    var RemoveUserOperation = class extends CommandOperation {
      constructor(db, username, options2) {
        const commandOptions = {};
        const writeConcern = WriteConcern.fromOptions(options2);
        if (writeConcern != null) {
          commandOptions.writeConcern = writeConcern;
        }
        if (options2.dbName) {
          commandOptions.dbName = options2.dbName;
        }
        if (typeof options2.maxTimeMS === "number") {
          commandOptions.maxTimeMS = options2.maxTimeMS;
        }
        super(db, commandOptions);
        this.username = username;
      }
      _buildCommand() {
        const username = this.username;
        const command = { dropUser: username };
        return command;
      }
      execute(callback) {
        super.execute((err, result) => {
          if (err)
            return handleCallback(callback, err, null);
          handleCallback(callback, err, result.ok ? true : false);
        });
      }
    };
    defineAspects(RemoveUserOperation, Aspect.WRITE_OPERATION);
    module2.exports = RemoveUserOperation;
  }
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS({
  "node_modules/mongodb/lib/operations/rename.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var checkCollectionName = require_utils4().checkCollectionName;
    var executeDbAdminCommand = require_db_ops().executeDbAdminCommand;
    var handleCallback = require_utils4().handleCallback;
    var loadCollection = require_dynamic_loaders().loadCollection;
    var toError = require_utils4().toError;
    var RenameOperation = class extends OperationBase {
      constructor(collection, newName, options2) {
        super(options2);
        this.collection = collection;
        this.newName = newName;
      }
      execute(callback) {
        const coll = this.collection;
        const newName = this.newName;
        const options2 = this.options;
        let Collection = loadCollection();
        checkCollectionName(newName);
        const renameCollection = coll.namespace;
        const toCollection = coll.s.namespace.withCollection(newName).toString();
        const dropTarget = typeof options2.dropTarget === "boolean" ? options2.dropTarget : false;
        const cmd = { renameCollection, to: toCollection, dropTarget };
        applyWriteConcern(cmd, { db: coll.s.db, collection: coll }, options2);
        executeDbAdminCommand(coll.s.db.admin().s.db, cmd, options2, (err, doc) => {
          if (err)
            return handleCallback(callback, err, null);
          if (doc.errmsg)
            return handleCallback(callback, toError(doc), null);
          try {
            return handleCallback(callback, null, new Collection(coll.s.db, coll.s.topology, coll.s.namespace.db, newName, coll.s.pkFactory, coll.s.options));
          } catch (err2) {
            return handleCallback(callback, toError(err2), null);
          }
        });
      }
    };
    module2.exports = RenameOperation;
  }
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS({
  "node_modules/mongodb/lib/operations/set_profiling_level.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var levelValues = new Set(["off", "slow_only", "all"]);
    var SetProfilingLevelOperation = class extends CommandOperation {
      constructor(db, level, options2) {
        let profile = 0;
        if (level === "off") {
          profile = 0;
        } else if (level === "slow_only") {
          profile = 1;
        } else if (level === "all") {
          profile = 2;
        }
        super(db, options2);
        this.level = level;
        this.profile = profile;
      }
      _buildCommand() {
        const profile = this.profile;
        const command = { profile };
        return command;
      }
      execute(callback) {
        const level = this.level;
        if (!levelValues.has(level)) {
          return callback(new Error("Error: illegal profiling level value " + level));
        }
        super.execute((err, doc) => {
          if (err == null && doc.ok === 1)
            return callback(null, level);
          return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
        });
      }
    };
    module2.exports = SetProfilingLevelOperation;
  }
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS({
  "node_modules/mongodb/lib/operations/validate_collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperation = require_command2();
    var ValidateCollectionOperation = class extends CommandOperation {
      constructor(admin, collectionName, options2) {
        let command = { validate: collectionName };
        const keys = Object.keys(options2);
        for (let i = 0; i < keys.length; i++) {
          if (Object.prototype.hasOwnProperty.call(options2, keys[i]) && keys[i] !== "session") {
            command[keys[i]] = options2[keys[i]];
          }
        }
        super(admin.s.db, options2, null, command);
        this.collectionName = collectionName;
      }
      execute(callback) {
        const collectionName = this.collectionName;
        super.execute((err, doc) => {
          if (err != null)
            return callback(err, null);
          if (doc.ok === 0)
            return callback(new Error("Error with validate command"), null);
          if (doc.result != null && doc.result.constructor !== String)
            return callback(new Error("Error with validation data"), null);
          if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          if (doc.valid != null && !doc.valid)
            return callback(new Error("Error: invalid collection " + collectionName), null);
          return callback(null, doc);
        });
      }
    };
    module2.exports = ValidateCollectionOperation;
  }
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS({
  "node_modules/mongodb/lib/operations/list_databases.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CommandOperationV2 = require_command_v2();
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ListDatabasesOperation = class extends CommandOperationV2 {
      constructor(db, options2) {
        super(db, options2);
        this.ns = new MongoDBNamespace("admin", "$cmd");
      }
      execute(server, callback) {
        const cmd = { listDatabases: 1 };
        if (this.options.nameOnly) {
          cmd.nameOnly = Number(cmd.nameOnly);
        }
        if (this.options.filter) {
          cmd.filter = this.options.filter;
        }
        if (typeof this.options.authorizedDatabases === "boolean") {
          cmd.authorizedDatabases = this.options.authorizedDatabases;
        }
        super.executeCommand(server, cmd, callback);
      }
    };
    defineAspects(ListDatabasesOperation, [
      Aspect.READ_OPERATION,
      Aspect.RETRYABLE,
      Aspect.EXECUTE_WITH_SELECTION
    ]);
    module2.exports = ListDatabasesOperation;
  }
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS({
  "node_modules/mongodb/lib/admin.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var AddUserOperation = require_add_user();
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var RemoveUserOperation = require_remove_user();
    var ValidateCollectionOperation = require_validate_collection();
    var ListDatabasesOperation = require_list_databases();
    var executeOperation = require_execute_operation();
    function Admin(db, topology, promiseLibrary) {
      if (!(this instanceof Admin))
        return new Admin(db, topology);
      this.s = {
        db,
        topology,
        promiseLibrary
      };
    }
    Admin.prototype.command = function(command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      const commandOperation = new ExecuteDbAdminCommandOperation(this.s.db, command, options2);
      return executeOperation(this.s.db.s.topology, commandOperation, callback);
    };
    Admin.prototype.buildInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { buildinfo: 1 };
      const buildInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, buildInfoOperation, callback);
    };
    Admin.prototype.serverInfo = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { buildinfo: 1 };
      const serverInfoOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, serverInfoOperation, callback);
    };
    Admin.prototype.serverStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const serverStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { serverStatus: 1 }, options2);
      return executeOperation(this.s.db.s.topology, serverStatusOperation, callback);
    };
    Admin.prototype.ping = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const cmd = { ping: 1 };
      const pingOperation = new ExecuteDbAdminCommandOperation(this.s.db, cmd, options2);
      return executeOperation(this.s.db.s.topology, pingOperation, callback);
    };
    Admin.prototype.addUser = function(username, password, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, { db: this.s.db });
      options2.dbName = "admin";
      const addUserOperation = new AddUserOperation(this.s.db, username, password, options2);
      return executeOperation(this.s.db.s.topology, addUserOperation, callback);
    };
    Admin.prototype.removeUser = function(username, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = Object.assign({}, options2);
      options2 = applyWriteConcern(options2, { db: this.s.db });
      options2.dbName = "admin";
      const removeUserOperation = new RemoveUserOperation(this.s.db, username, options2);
      return executeOperation(this.s.db.s.topology, removeUserOperation, callback);
    };
    Admin.prototype.validateCollection = function(collectionName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const validateCollectionOperation = new ValidateCollectionOperation(this, collectionName, options2);
      return executeOperation(this.s.db.s.topology, validateCollectionOperation, callback);
    };
    Admin.prototype.listDatabases = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.db.s.topology, new ListDatabasesOperation(this.s.db, options2), callback);
    };
    Admin.prototype.replSetGetStatus = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const replSetGetStatusOperation = new ExecuteDbAdminCommandOperation(this.s.db, { replSetGetStatus: 1 }, options2);
      return executeOperation(this.s.db.s.topology, replSetGetStatusOperation, callback);
    };
    module2.exports = Admin;
  }
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS({
  "node_modules/mongodb/lib/db.js"(exports2, module2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var getSingleProperty = require_utils4().getSingleProperty;
    var CommandCursor = require_command_cursor();
    var handleCallback = require_utils4().handleCallback;
    var filterOptions = require_utils4().filterOptions;
    var toError = require_utils4().toError;
    var ReadPreference = require_core().ReadPreference;
    var MongoError = require_core().MongoError;
    var ObjectID2 = require_core().ObjectID;
    var Logger = require_core().Logger;
    var Collection = require_collection();
    var conditionallyMergeWriteConcern = require_utils4().conditionallyMergeWriteConcern;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var ChangeStream = require_change_stream();
    var deprecate = __require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var CONSTANTS = require_constants2();
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var AggregationCursor = require_aggregation_cursor();
    var createListener = require_db_ops().createListener;
    var ensureIndex = require_db_ops().ensureIndex;
    var evaluate = require_db_ops().evaluate;
    var profilingInfo = require_db_ops().profilingInfo;
    var validateDatabaseName = require_db_ops().validateDatabaseName;
    var AggregateOperation = require_aggregate();
    var AddUserOperation = require_add_user();
    var CollectionsOperation = require_collections();
    var CommandOperation = require_command2();
    var RunCommandOperation = require_run_command();
    var CreateCollectionOperation = require_create_collection();
    var CreateIndexesOperation = require_create_indexes();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropDatabaseOperation = require_drop().DropDatabaseOperation;
    var ExecuteDbAdminCommandOperation = require_execute_db_admin_command();
    var IndexInformationOperation = require_index_information();
    var ListCollectionsOperation = require_list_collections();
    var ProfilingLevelOperation = require_profiling_level();
    var RemoveUserOperation = require_remove_user();
    var RenameOperation = require_rename();
    var SetProfilingLevelOperation = require_set_profiling_level();
    var executeOperation = require_execute_operation();
    var legalOptionNames = [
      "w",
      "wtimeout",
      "fsync",
      "j",
      "writeConcern",
      "readPreference",
      "readPreferenceTags",
      "native_parser",
      "forceServerObjectId",
      "pkFactory",
      "serializeFunctions",
      "raw",
      "bufferMaxEntries",
      "authSource",
      "ignoreUndefined",
      "promoteLongs",
      "promiseLibrary",
      "readConcern",
      "retryMiliSeconds",
      "numberOfRetries",
      "parentDb",
      "noListener",
      "loggerLevel",
      "logger",
      "promoteBuffers",
      "promoteLongs",
      "promoteValues",
      "compression",
      "retryWrites"
    ];
    function Db(databaseName, topology, options2) {
      options2 = options2 || {};
      if (!(this instanceof Db))
        return new Db(databaseName, topology, options2);
      EventEmitter.call(this);
      const promiseLibrary = options2.promiseLibrary || Promise;
      options2 = filterOptions(options2, legalOptionNames);
      options2.promiseLibrary = promiseLibrary;
      this.s = {
        dbCache: {},
        children: [],
        topology,
        options: options2,
        logger: Logger("Db", options2),
        bson: topology ? topology.bson : null,
        readPreference: ReadPreference.fromOptions(options2),
        bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : -1,
        parentDb: options2.parentDb || null,
        pkFactory: options2.pkFactory || ObjectID2,
        nativeParser: options2.nativeParser || options2.native_parser,
        promiseLibrary,
        noListener: typeof options2.noListener === "boolean" ? options2.noListener : false,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2),
        namespace: new MongoDBNamespace(databaseName)
      };
      validateDatabaseName(databaseName);
      getSingleProperty(this, "serverConfig", this.s.topology);
      getSingleProperty(this, "bufferMaxEntries", this.s.bufferMaxEntries);
      getSingleProperty(this, "databaseName", this.s.namespace.db);
      if (options2.parentDb)
        return;
      if (this.s.noListener)
        return;
      topology.on("error", createListener(this, "error", this));
      topology.on("timeout", createListener(this, "timeout", this));
      topology.on("close", createListener(this, "close", this));
      topology.on("parseError", createListener(this, "parseError", this));
      topology.once("open", createListener(this, "open", this));
      topology.once("fullsetup", createListener(this, "fullsetup", this));
      topology.once("all", createListener(this, "all", this));
      topology.on("reconnect", createListener(this, "reconnect", this));
    }
    inherits(Db, EventEmitter);
    Db.prototype.on = deprecate(function() {
      return Db.super_.prototype.on.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Db.prototype.once = deprecate(function() {
      return Db.super_.prototype.once.apply(this, arguments);
    }, "Listening to events on the Db class has been deprecated and will be removed in the next major version.");
    Object.defineProperty(Db.prototype, "topology", {
      enumerable: true,
      get: function() {
        return this.s.topology;
      }
    });
    Object.defineProperty(Db.prototype, "options", {
      enumerable: true,
      get: function() {
        return this.s.options;
      }
    });
    Object.defineProperty(Db.prototype, "slaveOk", {
      enumerable: true,
      get: function() {
        if (this.s.options.readPreference != null && (this.s.options.readPreference !== "primary" || this.s.options.readPreference.mode !== "primary")) {
          return true;
        }
        return false;
      }
    });
    Object.defineProperty(Db.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Db.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return ReadPreference.primary;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Db.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Db.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Db.prototype.command = function(command, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      const commandOperation = new RunCommandOperation(this, command, options2);
      return executeOperation(this.s.topology, commandOperation, callback);
    };
    Db.prototype.aggregate = function(pipeline2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2 == null && callback == null) {
        options2 = {};
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Db.prototype.admin = function() {
      const Admin = require_admin();
      return new Admin(this, this.s.topology, this.s.promiseLibrary);
    };
    var COLLECTION_OPTION_KEYS = [
      "pkFactory",
      "readPreference",
      "serializeFunctions",
      "strict",
      "readConcern",
      "ignoreUndefined",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs"
    ];
    Db.prototype.collection = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2 = Object.assign({}, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      if (this.s.options.ignoreUndefined) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      for (const collectionOptionKey of COLLECTION_OPTION_KEYS) {
        if (!(collectionOptionKey in options2) && this.s.options[collectionOptionKey] !== void 0) {
          options2[collectionOptionKey] = this.s.options[collectionOptionKey];
        }
      }
      options2 = conditionallyMergeWriteConcern(options2, this.s.options);
      if (options2 == null || !options2.strict) {
        try {
          const collection = new Collection(this, this.s.topology, this.databaseName, name2, this.s.pkFactory, options2);
          if (callback)
            callback(null, collection);
          return collection;
        } catch (err) {
          if (err instanceof MongoError && callback)
            return callback(err);
          throw err;
        }
      }
      if (typeof callback !== "function") {
        throw toError(`A callback is required in strict mode. While getting collection ${name2}`);
      }
      if (this.serverConfig && this.serverConfig.isDestroyed()) {
        return callback(new MongoError("topology was destroyed"));
      }
      const listCollectionOptions = Object.assign({}, options2, { nameOnly: true });
      this.listCollections({ name: name2 }, listCollectionOptions).toArray((err, collections) => {
        if (err != null)
          return handleCallback(callback, err, null);
        if (collections.length === 0)
          return handleCallback(callback, toError(`Collection ${name2} does not exist. Currently in strict mode.`), null);
        try {
          return handleCallback(callback, null, new Collection(this, this.s.topology, this.databaseName, name2, this.s.pkFactory, options2));
        } catch (err2) {
          return handleCallback(callback, err2, null);
        }
      });
    };
    Db.prototype.createCollection = deprecateOptions({
      name: "Db.createCollection",
      deprecatedOptions: ["autoIndexId", "strict", "w", "wtimeout", "j"],
      optionsIndex: 1
    }, function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.promiseLibrary = options2.promiseLibrary || this.s.promiseLibrary;
      options2.readConcern = options2.readConcern ? new ReadConcern(options2.readConcern.level) : this.readConcern;
      const createCollectionOperation = new CreateCollectionOperation(this, name2, options2);
      return executeOperation(this.s.topology, createCollectionOperation, callback);
    });
    Db.prototype.stats = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const commandObject = { dbStats: true };
      if (options2["scale"] != null)
        commandObject["scale"] = options2["scale"];
      if (options2.readPreference == null && this.s.readPreference) {
        options2.readPreference = this.s.readPreference;
      }
      const statsOperation = new CommandOperation(this, options2, null, commandObject);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Db.prototype.listCollections = function(filter2, options2) {
      filter2 = filter2 || {};
      options2 = options2 || {};
      return new CommandCursor(this.s.topology, new ListCollectionsOperation(this, filter2, options2), options2);
    };
    Db.prototype.eval = deprecate(function(code, parameters, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      parameters = args.length ? args.shift() : parameters;
      options2 = args.length ? args.shift() || {} : {};
      return executeLegacyOperation(this.s.topology, evaluate, [
        this,
        code,
        parameters,
        options2,
        callback
      ]);
    }, "Db.eval is deprecated as of MongoDB version 3.2");
    Db.prototype.renameCollection = function(fromCollection, toCollection, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      options2.new_collection = true;
      const renameOperation = new RenameOperation(this.collection(fromCollection), toCollection, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Db.prototype.dropCollection = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this, name2, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Db.prototype.dropDatabase = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropDatabaseOperation = new DropDatabaseOperation(this, options2);
      return executeOperation(this.s.topology, dropDatabaseOperation, callback);
    };
    Db.prototype.collections = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const collectionsOperation = new CollectionsOperation(this, options2);
      return executeOperation(this.s.topology, collectionsOperation, callback);
    };
    Db.prototype.executeDbAdminCommand = function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      options2.readPreference = ReadPreference.resolve(this, options2);
      const executeDbAdminCommandOperation = new ExecuteDbAdminCommandOperation(this, selector, options2);
      return executeOperation(this.s.topology, executeDbAdminCommandOperation, callback);
    };
    Db.prototype.createIndex = function(name2, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      const createIndexesOperation = new CreateIndexesOperation(this, name2, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Db.prototype.ensureIndex = deprecate(function(name2, fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        name2,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "Db.ensureIndex is deprecated as of MongoDB version 3.0 / driver version 2.0");
    Db.prototype.addChild = function(db) {
      if (this.s.parentDb)
        return this.s.parentDb.addChild(db);
      this.s.children.push(db);
    };
    Db.prototype.addUser = function(username, password, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (typeof username === "string" && password != null && typeof password === "object") {
        options2 = password;
        password = null;
      }
      const addUserOperation = new AddUserOperation(this, username, password, options2);
      return executeOperation(this.s.topology, addUserOperation, callback);
    };
    Db.prototype.removeUser = function(username, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const removeUserOperation = new RemoveUserOperation(this, username, options2);
      return executeOperation(this.s.topology, removeUserOperation, callback);
    };
    Db.prototype.setProfilingLevel = function(level, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const setProfilingLevelOperation = new SetProfilingLevelOperation(this, level, options2);
      return executeOperation(this.s.topology, setProfilingLevelOperation, callback);
    };
    Db.prototype.profilingInfo = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, profilingInfo, [this, options2, callback]);
    }, "Db.profilingInfo is deprecated. Query the system.profile collection directly.");
    Db.prototype.profilingLevel = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const profilingLevelOperation = new ProfilingLevelOperation(this, options2);
      return executeOperation(this.s.topology, profilingLevelOperation, callback);
    };
    Db.prototype.indexInformation = function(name2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexInformationOperation = new IndexInformationOperation(this, name2, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Db.prototype.unref = function() {
      this.s.topology.unref();
    };
    Db.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Db.prototype.getLogger = function() {
      return this.s.logger;
    };
    Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
    Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
    Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
    Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
    Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
    Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
    module2.exports = Db;
  }
});

// node_modules/mongodb/lib/dynamic_loaders.js
var require_dynamic_loaders = __commonJS({
  "node_modules/mongodb/lib/dynamic_loaders.js"(exports2, module2) {
    init_shims();
    "use strict";
    var collection;
    var cursor;
    var db;
    function loadCollection() {
      if (!collection) {
        collection = require_collection();
      }
      return collection;
    }
    function loadCursor() {
      if (!cursor) {
        cursor = require_cursor2();
      }
      return cursor;
    }
    function loadDb() {
      if (!db) {
        db = require_db();
      }
      return db;
    }
    module2.exports = {
      loadCollection,
      loadCursor,
      loadDb
    };
  }
});

// node_modules/mongodb/lib/operations/map_reduce.js
var require_map_reduce = __commonJS({
  "node_modules/mongodb/lib/operations/map_reduce.js"(exports2, module2) {
    init_shims();
    "use strict";
    var applyWriteConcern = require_utils4().applyWriteConcern;
    var Code2 = require_core().BSON.Code;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var executeCommand = require_db_ops().executeCommand;
    var handleCallback = require_utils4().handleCallback;
    var isObject = require_utils4().isObject;
    var loadDb = require_dynamic_loaders().loadDb;
    var OperationBase = require_operation().OperationBase;
    var ReadPreference = require_core().ReadPreference;
    var toError = require_utils4().toError;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var decorateWithExplain = require_utils4().decorateWithExplain;
    var maxWireVersion = require_utils2().maxWireVersion;
    var MongoError = require_error2().MongoError;
    var exclusionList = [
      "explain",
      "readPreference",
      "session",
      "bypassDocumentValidation",
      "w",
      "wtimeout",
      "j",
      "writeConcern"
    ];
    var MapReduceOperation = class extends OperationBase {
      constructor(collection, map2, reduce, options2) {
        super(options2);
        this.collection = collection;
        this.map = map2;
        this.reduce = reduce;
      }
      execute(callback) {
        const coll = this.collection;
        const map2 = this.map;
        const reduce = this.reduce;
        let options2 = this.options;
        let mapCommandHash = {
          mapReduce: coll.collectionName,
          map: map2,
          reduce
        };
        for (let n in options2) {
          if (n === "scope") {
            mapCommandHash[n] = processScope(options2[n]);
          } else {
            if (exclusionList.indexOf(n) === -1) {
              mapCommandHash[n] = options2[n];
            }
          }
        }
        options2 = Object.assign({}, options2);
        options2.readPreference = ReadPreference.resolve(coll, options2);
        if (options2.readPreference !== false && options2.readPreference !== "primary" && options2["out"] && options2["out"].inline !== 1 && options2["out"] !== "inline") {
          options2.readPreference = "primary";
          applyWriteConcern(mapCommandHash, { db: coll.s.db, collection: coll }, options2);
        } else {
          decorateWithReadConcern(mapCommandHash, coll, options2);
        }
        if (options2.bypassDocumentValidation === true) {
          mapCommandHash.bypassDocumentValidation = options2.bypassDocumentValidation;
        }
        try {
          decorateWithCollation(mapCommandHash, coll, options2);
        } catch (err) {
          return callback(err, null);
        }
        if (this.explain) {
          if (maxWireVersion(coll.s.topology) < 9) {
            callback(new MongoError(`server does not support explain on mapReduce`));
            return;
          }
          mapCommandHash = decorateWithExplain(mapCommandHash, this.explain);
        }
        executeCommand(coll.s.db, mapCommandHash, options2, (err, result) => {
          if (err)
            return handleCallback(callback, err);
          if (result.ok !== 1 || result.err || result.errmsg) {
            return handleCallback(callback, toError(result));
          }
          if (this.explain)
            return callback(void 0, result);
          const stats = {};
          if (result.timeMillis)
            stats["processtime"] = result.timeMillis;
          if (result.counts)
            stats["counts"] = result.counts;
          if (result.timing)
            stats["timing"] = result.timing;
          if (result.results) {
            if (options2["verbose"] == null || !options2["verbose"]) {
              return handleCallback(callback, null, result.results);
            }
            return handleCallback(callback, null, { results: result.results, stats });
          }
          let collection = null;
          if (result.result != null && typeof result.result === "object") {
            const doc = result.result;
            let Db = loadDb();
            collection = new Db(doc.db, coll.s.db.s.topology, coll.s.db.s.options).collection(doc.collection);
          } else {
            collection = coll.s.db.collection(result.result);
          }
          if (options2["verbose"] == null || !options2["verbose"]) {
            return handleCallback(callback, err, collection);
          }
          handleCallback(callback, err, { collection, stats });
        });
      }
    };
    function processScope(scope) {
      if (!isObject(scope) || scope._bsontype === "ObjectID") {
        return scope;
      }
      const keys = Object.keys(scope);
      let key;
      const new_scope = {};
      for (let i = keys.length - 1; i >= 0; i--) {
        key = keys[i];
        if (typeof scope[key] === "function") {
          new_scope[key] = new Code2(String(scope[key]));
        } else {
          new_scope[key] = processScope(scope[key]);
        }
      }
      return new_scope;
    }
    defineAspects(MapReduceOperation, [Aspect.EXPLAINABLE]);
    module2.exports = MapReduceOperation;
  }
});

// node_modules/mongodb/lib/operations/re_index.js
var require_re_index = __commonJS({
  "node_modules/mongodb/lib/operations/re_index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var CommandOperationV2 = require_command_v2();
    var serverType = require_common().serverType;
    var ServerType = require_common().ServerType;
    var MongoError = require_core().MongoError;
    var ReIndexOperation = class extends CommandOperationV2 {
      constructor(collection, options2) {
        super(collection, options2);
        this.collectionName = collection.collectionName;
      }
      execute(server, callback) {
        if (serverType(server) !== ServerType.Standalone) {
          callback(new MongoError(`reIndex can only be executed on standalone servers.`));
          return;
        }
        super.executeCommand(server, { reIndex: this.collectionName }, (err, result) => {
          if (err) {
            callback(err);
            return;
          }
          callback(null, !!result.ok);
        });
      }
    };
    defineAspects(ReIndexOperation, [Aspect.EXECUTE_WITH_SELECTION]);
    module2.exports = ReIndexOperation;
  }
});

// node_modules/mongodb/lib/operations/replace_one.js
var require_replace_one = __commonJS({
  "node_modules/mongodb/lib/operations/replace_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var ReplaceOneOperation = class extends OperationBase {
      constructor(collection, filter2, replacement, options2) {
        super(options2);
        if (hasAtomicOperators(replacement)) {
          throw new TypeError("Replacement document must not contain atomic operators");
        }
        this.collection = collection;
        this.filter = filter2;
        this.replacement = replacement;
      }
      execute(callback) {
        const coll = this.collection;
        const filter2 = this.filter;
        const replacement = this.replacement;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter2, replacement, options2, (err, r) => replaceCallback(err, r, replacement, callback));
      }
    };
    function replaceCallback(err, r, doc, callback) {
      if (callback == null)
        return;
      if (err && callback)
        return callback(err);
      if (r == null)
        return callback(null, { result: { ok: 1 } });
      r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
      r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
      r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
      r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
      r.ops = [doc];
      if (callback)
        callback(null, r);
    }
    module2.exports = ReplaceOneOperation;
  }
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS({
  "node_modules/mongodb/lib/operations/stats.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Aspect = require_operation().Aspect;
    var CommandOperation = require_command2();
    var defineAspects = require_operation().defineAspects;
    var StatsOperation = class extends CommandOperation {
      constructor(collection, options2) {
        super(collection.s.db, options2, collection);
      }
      _buildCommand() {
        const collection = this.collection;
        const options2 = this.options;
        const command = {
          collStats: collection.collectionName
        };
        if (options2["scale"] != null) {
          command["scale"] = options2["scale"];
        }
        return command;
      }
    };
    defineAspects(StatsOperation, Aspect.READ_OPERATION);
    module2.exports = StatsOperation;
  }
});

// node_modules/mongodb/lib/operations/update_many.js
var require_update_many = __commonJS({
  "node_modules/mongodb/lib/operations/update_many.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateManyOperation = class extends OperationBase {
      constructor(collection, filter2, update2, options2) {
        super(options2);
        if (!hasAtomicOperators(update2)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter2;
        this.update = update2;
      }
      execute(callback) {
        const coll = this.collection;
        const filter2 = this.filter;
        const update2 = this.update;
        const options2 = this.options;
        options2.multi = true;
        updateDocuments(coll, filter2, update2, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateManyOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateManyOperation;
  }
});

// node_modules/mongodb/lib/operations/update_one.js
var require_update_one = __commonJS({
  "node_modules/mongodb/lib/operations/update_one.js"(exports2, module2) {
    init_shims();
    "use strict";
    var OperationBase = require_operation().OperationBase;
    var updateDocuments = require_common_functions().updateDocuments;
    var hasAtomicOperators = require_utils4().hasAtomicOperators;
    var Aspect = require_operation().Aspect;
    var defineAspects = require_operation().defineAspects;
    var UpdateOneOperation = class extends OperationBase {
      constructor(collection, filter2, update2, options2) {
        super(options2);
        if (!hasAtomicOperators(update2)) {
          throw new TypeError("Update document requires atomic operators");
        }
        this.collection = collection;
        this.filter = filter2;
        this.update = update2;
      }
      execute(callback) {
        const coll = this.collection;
        const filter2 = this.filter;
        const update2 = this.update;
        const options2 = this.options;
        options2.multi = false;
        updateDocuments(coll, filter2, update2, options2, (err, r) => {
          if (callback == null)
            return;
          if (err)
            return callback(err);
          if (r == null)
            return callback(null, { result: { ok: 1 } });
          if (this.explain)
            return callback(void 0, r.result);
          r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
          r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
          r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
          r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
          callback(null, r);
        });
      }
    };
    defineAspects(UpdateOneOperation, [Aspect.EXPLAINABLE]);
    module2.exports = UpdateOneOperation;
  }
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS({
  "node_modules/mongodb/lib/collection.js"(exports2, module2) {
    init_shims();
    "use strict";
    var deprecate = __require("util").deprecate;
    var deprecateOptions = require_utils4().deprecateOptions;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var checkCollectionName = require_utils4().checkCollectionName;
    var ObjectID2 = require_core().BSON.ObjectID;
    var MongoError = require_core().MongoError;
    var normalizeHintField = require_utils4().normalizeHintField;
    var decorateCommand = require_utils4().decorateCommand;
    var decorateWithCollation = require_utils4().decorateWithCollation;
    var decorateWithReadConcern = require_utils4().decorateWithReadConcern;
    var formattedOrderClause = require_utils4().formattedOrderClause;
    var ReadPreference = require_core().ReadPreference;
    var unordered = require_unordered();
    var ordered = require_ordered();
    var ChangeStream = require_change_stream();
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var WriteConcern = require_write_concern();
    var ReadConcern = require_read_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var AggregationCursor = require_aggregation_cursor();
    var CommandCursor = require_command_cursor();
    var ensureIndex = require_collection_ops().ensureIndex;
    var group = require_collection_ops().group;
    var parallelCollectionScan = require_collection_ops().parallelCollectionScan;
    var removeDocuments = require_common_functions().removeDocuments;
    var save = require_collection_ops().save;
    var updateDocuments = require_common_functions().updateDocuments;
    var AggregateOperation = require_aggregate();
    var BulkWriteOperation = require_bulk_write();
    var CountDocumentsOperation = require_count_documents();
    var CreateIndexesOperation = require_create_indexes();
    var DeleteManyOperation = require_delete_many();
    var DeleteOneOperation = require_delete_one();
    var DistinctOperation = require_distinct();
    var DropCollectionOperation = require_drop().DropCollectionOperation;
    var DropIndexOperation = require_drop_index();
    var DropIndexesOperation = require_drop_indexes();
    var EstimatedDocumentCountOperation = require_estimated_document_count();
    var FindOperation = require_find();
    var FindOneOperation = require_find_one();
    var FindAndModifyOperation = require_find_and_modify();
    var FindOneAndDeleteOperation = require_find_one_and_delete();
    var FindOneAndReplaceOperation = require_find_one_and_replace();
    var FindOneAndUpdateOperation = require_find_one_and_update();
    var GeoHaystackSearchOperation = require_geo_haystack_search();
    var IndexesOperation = require_indexes();
    var IndexExistsOperation = require_index_exists();
    var IndexInformationOperation = require_index_information();
    var InsertManyOperation = require_insert_many();
    var InsertOneOperation = require_insert_one();
    var IsCappedOperation = require_is_capped();
    var ListIndexesOperation = require_list_indexes();
    var MapReduceOperation = require_map_reduce();
    var OptionsOperation = require_options_operation();
    var RenameOperation = require_rename();
    var ReIndexOperation = require_re_index();
    var ReplaceOneOperation = require_replace_one();
    var StatsOperation = require_stats();
    var UpdateManyOperation = require_update_many();
    var UpdateOneOperation = require_update_one();
    var executeOperation = require_execute_operation();
    var mergeKeys = ["ignoreUndefined"];
    function Collection(db, topology, dbName, name2, pkFactory, options2) {
      checkCollectionName(name2);
      const internalHint = null;
      const slaveOk = options2 == null || options2.slaveOk == null ? db.slaveOk : options2.slaveOk;
      const serializeFunctions = options2 == null || options2.serializeFunctions == null ? db.s.options.serializeFunctions : options2.serializeFunctions;
      const raw = options2 == null || options2.raw == null ? db.s.options.raw : options2.raw;
      const promoteLongs = options2 == null || options2.promoteLongs == null ? db.s.options.promoteLongs : options2.promoteLongs;
      const promoteValues = options2 == null || options2.promoteValues == null ? db.s.options.promoteValues : options2.promoteValues;
      const promoteBuffers = options2 == null || options2.promoteBuffers == null ? db.s.options.promoteBuffers : options2.promoteBuffers;
      const collectionHint = null;
      const namespace = new MongoDBNamespace(dbName, name2);
      const promiseLibrary = options2.promiseLibrary || Promise;
      pkFactory = pkFactory == null ? ObjectID2 : pkFactory;
      this.s = {
        pkFactory,
        db,
        topology,
        options: options2,
        namespace,
        readPreference: ReadPreference.fromOptions(options2),
        slaveOk,
        serializeFunctions,
        raw,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        internalHint,
        collectionHint,
        promiseLibrary,
        readConcern: ReadConcern.fromOptions(options2),
        writeConcern: WriteConcern.fromOptions(options2)
      };
    }
    Object.defineProperty(Collection.prototype, "dbName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.db;
      }
    });
    Object.defineProperty(Collection.prototype, "collectionName", {
      enumerable: true,
      get: function() {
        return this.s.namespace.collection;
      }
    });
    Object.defineProperty(Collection.prototype, "namespace", {
      enumerable: true,
      get: function() {
        return this.s.namespace.toString();
      }
    });
    Object.defineProperty(Collection.prototype, "readConcern", {
      enumerable: true,
      get: function() {
        if (this.s.readConcern == null) {
          return this.s.db.readConcern;
        }
        return this.s.readConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        if (this.s.readPreference == null) {
          return this.s.db.readPreference;
        }
        return this.s.readPreference;
      }
    });
    Object.defineProperty(Collection.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        if (this.s.writeConcern == null) {
          return this.s.db.writeConcern;
        }
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(Collection.prototype, "hint", {
      enumerable: true,
      get: function() {
        return this.s.collectionHint;
      },
      set: function(v) {
        this.s.collectionHint = normalizeHintField(v);
      }
    });
    var DEPRECATED_FIND_OPTIONS = ["maxScan", "fields", "snapshot", "oplogReplay"];
    Collection.prototype.find = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `find()` must be a callback or undefined");
      }
      let selector = query;
      if (typeof callback !== "function") {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = void 0;
        } else if (options2 == null) {
          callback = typeof selector === "function" ? selector : void 0;
          selector = typeof selector === "object" ? selector : void 0;
        }
      }
      selector = selector == null ? {} : selector;
      const object = selector;
      if (Buffer.isBuffer(object)) {
        const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
        if (object_size !== object.length) {
          const error3 = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
          error3.name = "MongoError";
          throw error3;
        }
      }
      if (selector != null && selector._bsontype === "ObjectID") {
        selector = { _id: selector };
      }
      if (!options2)
        options2 = {};
      let projection = options2.projection || options2.fields;
      if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      let newOptions = Object.assign({}, options2);
      for (let key in this.s.options) {
        if (mergeKeys.indexOf(key) !== -1) {
          newOptions[key] = this.s.options[key];
        }
      }
      newOptions.skip = options2.skip ? options2.skip : 0;
      newOptions.limit = options2.limit ? options2.limit : 0;
      newOptions.raw = typeof options2.raw === "boolean" ? options2.raw : this.s.raw;
      newOptions.hint = options2.hint != null ? normalizeHintField(options2.hint) : this.s.collectionHint;
      newOptions.timeout = typeof options2.timeout === "undefined" ? void 0 : options2.timeout;
      newOptions.slaveOk = options2.slaveOk != null ? options2.slaveOk : this.s.db.slaveOk;
      newOptions.readPreference = ReadPreference.resolve(this, newOptions);
      if (newOptions.readPreference != null && (newOptions.readPreference !== "primary" || newOptions.readPreference.mode !== "primary")) {
        newOptions.slaveOk = true;
      }
      if (selector != null && typeof selector !== "object") {
        throw MongoError.create({ message: "query selector must be an object", driver: true });
      }
      const findCommand = {
        find: this.s.namespace.toString(),
        limit: newOptions.limit,
        skip: newOptions.skip,
        query: selector
      };
      if (typeof options2.allowDiskUse === "boolean") {
        findCommand.allowDiskUse = options2.allowDiskUse;
      }
      if (typeof newOptions.awaitdata === "boolean") {
        newOptions.awaitData = newOptions.awaitdata;
      }
      if (typeof newOptions.timeout === "boolean")
        newOptions.noCursorTimeout = !newOptions.timeout;
      decorateCommand(findCommand, newOptions, ["session", "collation"]);
      if (projection)
        findCommand.fields = projection;
      newOptions.db = this.s.db;
      newOptions.promiseLibrary = this.s.promiseLibrary;
      if (newOptions.raw == null && typeof this.s.raw === "boolean")
        newOptions.raw = this.s.raw;
      if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === "boolean")
        newOptions.promoteLongs = this.s.promoteLongs;
      if (newOptions.promoteValues == null && typeof this.s.promoteValues === "boolean")
        newOptions.promoteValues = this.s.promoteValues;
      if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === "boolean")
        newOptions.promoteBuffers = this.s.promoteBuffers;
      if (findCommand.sort) {
        findCommand.sort = formattedOrderClause(findCommand.sort);
      }
      decorateWithReadConcern(findCommand, this, options2);
      try {
        decorateWithCollation(findCommand, this, options2);
      } catch (err) {
        if (typeof callback === "function")
          return callback(err, null);
        throw err;
      }
      const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    });
    Collection.prototype.insertOne = function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const insertOneOperation = new InsertOneOperation(this, doc, options2);
      return executeOperation(this.s.topology, insertOneOperation, callback);
    };
    Collection.prototype.insertMany = function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : { ordered: true };
      const insertManyOperation = new InsertManyOperation(this, docs, options2);
      return executeOperation(this.s.topology, insertManyOperation, callback);
    };
    Collection.prototype.bulkWrite = function(operations, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || { ordered: true };
      if (!Array.isArray(operations)) {
        throw MongoError.create({ message: "operations must be an array of documents", driver: true });
      }
      const bulkWriteOperation = new BulkWriteOperation(this, operations, options2);
      return executeOperation(this.s.topology, bulkWriteOperation, callback);
    };
    Collection.prototype.insert = deprecate(function(docs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || { ordered: false };
      docs = !Array.isArray(docs) ? [docs] : docs;
      if (options2.keepGoing === true) {
        options2.ordered = false;
      }
      return this.insertMany(docs, options2, callback);
    }, "collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.");
    Collection.prototype.updateOne = function(filter2, update2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateOneOperation(this, filter2, update2, options2), callback);
    };
    Collection.prototype.replaceOne = function(filter2, doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter2, doc, options2), callback);
    };
    Collection.prototype.updateMany = function(filter2, update2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new UpdateManyOperation(this, filter2, update2, options2), callback);
    };
    Collection.prototype.update = deprecate(function(selector, update2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, updateDocuments, [
        this,
        selector,
        update2,
        options2,
        callback
      ]);
    }, "collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.");
    Collection.prototype.deleteOne = function(filter2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteOneOperation = new DeleteOneOperation(this, filter2, options2);
      return executeOperation(this.s.topology, deleteOneOperation, callback);
    };
    Collection.prototype.removeOne = Collection.prototype.deleteOne;
    Collection.prototype.deleteMany = function(filter2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2);
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      const deleteManyOperation = new DeleteManyOperation(this, filter2, options2);
      return executeOperation(this.s.topology, deleteManyOperation, callback);
    };
    Collection.prototype.removeMany = Collection.prototype.deleteMany;
    Collection.prototype.remove = deprecate(function(selector, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, removeDocuments, [
        this,
        selector,
        options2,
        callback
      ]);
    }, "collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.");
    Collection.prototype.save = deprecate(function(doc, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeLegacyOperation(this.s.topology, save, [this, doc, options2, callback]);
    }, "collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.");
    Collection.prototype.findOne = deprecateOptions({
      name: "collection.find",
      deprecatedOptions: DEPRECATED_FIND_OPTIONS,
      optionsIndex: 1
    }, function(query, options2, callback) {
      if (typeof callback === "object") {
        emitWarningOnce("Third parameter to `findOne()` must be a callback or undefined");
      }
      if (typeof query === "function")
        callback = query, query = {}, options2 = {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      query = query || {};
      options2 = options2 || {};
      const findOneOperation = new FindOneOperation(this, query, options2);
      return executeOperation(this.s.topology, findOneOperation, callback);
    });
    Collection.prototype.rename = function(newName, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = Object.assign({}, options2, { readPreference: ReadPreference.PRIMARY });
      const renameOperation = new RenameOperation(this, newName, options2);
      return executeOperation(this.s.topology, renameOperation, callback);
    };
    Collection.prototype.drop = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, dropCollectionOperation, callback);
    };
    Collection.prototype.options = function(opts, callback) {
      if (typeof opts === "function")
        callback = opts, opts = {};
      opts = opts || {};
      const optionsOperation = new OptionsOperation(this, opts);
      return executeOperation(this.s.topology, optionsOperation, callback);
    };
    Collection.prototype.isCapped = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const isCappedOperation = new IsCappedOperation(this, options2);
      return executeOperation(this.s.topology, isCappedOperation, callback);
    };
    Collection.prototype.createIndex = function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.createIndexes = function(indexSpecs, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options2);
      return executeOperation(this.s.topology, createIndexesOperation, callback);
    };
    Collection.prototype.dropIndex = function(indexName, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      options2.readPreference = ReadPreference.PRIMARY;
      const dropIndexOperation = new DropIndexOperation(this, indexName, options2);
      return executeOperation(this.s.topology, dropIndexOperation, callback);
    };
    Collection.prototype.dropIndexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 ? Object.assign({}, options2) : {};
      if (typeof options2.maxTimeMS !== "number")
        delete options2.maxTimeMS;
      const dropIndexesOperation = new DropIndexesOperation(this, options2);
      return executeOperation(this.s.topology, dropIndexesOperation, callback);
    };
    Collection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, "collection.dropAllIndexes is deprecated. Use dropIndexes instead.");
    Collection.prototype.reIndex = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const reIndexOperation = new ReIndexOperation(this, options2);
      return executeOperation(this.s.topology, reIndexOperation, callback);
    }, "collection.reIndex is deprecated. Use db.command instead.");
    Collection.prototype.listIndexes = function(options2) {
      const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options2), options2);
      return cursor;
    };
    Collection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.s.topology, ensureIndex, [
        this,
        fieldOrSpec,
        options2,
        callback
      ]);
    }, "collection.ensureIndex is deprecated. Use createIndexes instead.");
    Collection.prototype.indexExists = function(indexes, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexExistsOperation = new IndexExistsOperation(this, indexes, options2);
      return executeOperation(this.s.topology, indexExistsOperation, callback);
    };
    Collection.prototype.indexInformation = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options2);
      return executeOperation(this.s.topology, indexInformationOperation, callback);
    };
    Collection.prototype.count = deprecate(function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options2), callback);
    }, "collection.count is deprecated, and will be removed in a future version. Use Collection.countDocuments or Collection.estimatedDocumentCount instead");
    Collection.prototype.estimatedDocumentCount = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options2);
      return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);
    };
    Collection.prototype.countDocuments = function(query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      query = args.length ? args.shift() || {} : {};
      options2 = args.length ? args.shift() || {} : {};
      const countDocumentsOperation = new CountDocumentsOperation(this, query, options2);
      return executeOperation(this.s.topology, countDocumentsOperation, callback);
    };
    Collection.prototype.distinct = function(key, query, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      const queryOption = args.length ? args.shift() || {} : {};
      const optionsOption = args.length ? args.shift() || {} : {};
      const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);
      return executeOperation(this.s.topology, distinctOperation, callback);
    };
    Collection.prototype.indexes = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      const indexesOperation = new IndexesOperation(this, options2);
      return executeOperation(this.s.topology, indexesOperation, callback);
    };
    Collection.prototype.stats = function(options2, callback) {
      const args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const statsOperation = new StatsOperation(this, options2);
      return executeOperation(this.s.topology, statsOperation, callback);
    };
    Collection.prototype.findOneAndDelete = function(filter2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter2, options2), callback);
    };
    Collection.prototype.findOneAndReplace = deprecateOptions({
      name: "collection.findOneAndReplace",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter2, replacement, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter2, replacement, options2), callback);
    });
    Collection.prototype.findOneAndUpdate = deprecateOptions({
      name: "collection.findOneAndUpdate",
      deprecatedOptions: ["returnOriginal"],
      optionsIndex: 2
    }, function(filter2, update2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.s.options.ignoreUndefined) {
        options2 = Object.assign({}, options2);
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter2, update2, options2), callback);
    });
    Collection.prototype.findAndModify = deprecate(_findAndModify, "collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.");
    Collection.prototype._findAndModify = _findAndModify;
    function _findAndModify(query, sort, doc, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      doc = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.PRIMARY;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options2), callback);
    }
    Collection.prototype.findAndRemove = deprecate(function(query, sort, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      sort = args.length ? args.shift() || [] : [];
      options2 = args.length ? args.shift() || {} : {};
      options2.remove = true;
      return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options2), callback);
    }, "collection.findAndRemove is deprecated. Use findOneAndDelete instead.");
    Collection.prototype.aggregate = function(pipeline2, options2, callback) {
      if (Array.isArray(pipeline2)) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        if (options2 == null && callback == null) {
          options2 = {};
        }
      } else {
        const args = Array.prototype.slice.call(arguments, 0);
        callback = args.pop();
        const opts = args[args.length - 1];
        options2 = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {};
        pipeline2 = args;
      }
      const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline2, options2), options2);
      if (typeof callback === "function") {
        callback(null, cursor);
        return;
      }
      return cursor;
    };
    Collection.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    Collection.prototype.parallelCollectionScan = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = { numCursors: 1 };
      options2.numCursors = options2.numCursors || 1;
      options2.batchSize = options2.batchSize || 1e3;
      options2 = Object.assign({}, options2);
      options2.readPreference = ReadPreference.resolve(this, options2);
      options2.promiseLibrary = this.s.promiseLibrary;
      if (options2.session) {
        options2.session = void 0;
      }
      return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options2, callback], { skipSessions: true });
    }, "parallelCollectionScan is deprecated in MongoDB v4.1");
    Collection.prototype.geoHaystackSearch = deprecate(function(x, y2, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() || {} : {};
      const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y2, options2);
      return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);
    }, "geoHaystackSearch is deprecated, and will be removed in a future version.");
    Collection.prototype.group = deprecate(function(keys, condition, initial, reduce, finalize, command, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 3);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      reduce = args.length ? args.shift() : null;
      finalize = args.length ? args.shift() : null;
      command = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() || {} : {};
      if (!(typeof finalize === "function")) {
        command = finalize;
        finalize = null;
      }
      if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== "function" && !(keys._bsontype === "Code")) {
        keys = Object.keys(keys);
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof finalize === "function") {
        finalize = finalize.toString();
      }
      command = command == null ? true : command;
      return executeLegacyOperation(this.s.topology, group, [
        this,
        keys,
        condition,
        initial,
        reduce,
        finalize,
        command,
        options2,
        callback
      ]);
    }, "MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.");
    Collection.prototype.mapReduce = function(map2, reduce, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (options2.out == null) {
        throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
      }
      if (typeof map2 === "function") {
        map2 = map2.toString();
      }
      if (typeof reduce === "function") {
        reduce = reduce.toString();
      }
      if (typeof options2.finalize === "function") {
        options2.finalize = options2.finalize.toString();
      }
      const mapReduceOperation = new MapReduceOperation(this, map2, reduce, options2);
      return executeOperation(this.s.topology, mapReduceOperation, callback);
    };
    Collection.prototype.initializeUnorderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return unordered(this.s.topology, this, options2);
    };
    Collection.prototype.initializeOrderedBulkOp = function(options2) {
      options2 = options2 || {};
      if (options2.ignoreUndefined == null) {
        options2.ignoreUndefined = this.s.options.ignoreUndefined;
      }
      options2.promiseLibrary = this.s.promiseLibrary;
      return ordered(this.s.topology, this, options2);
    };
    Collection.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    module2.exports = Collection;
  }
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS({
  "node_modules/mongodb/lib/change_stream.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Denque = require_denque();
    var EventEmitter = __require("events");
    var isResumableError = require_error2().isResumableError;
    var MongoError = require_core().MongoError;
    var Cursor = require_cursor2();
    var relayEvents = require_utils2().relayEvents;
    var maxWireVersion = require_utils2().maxWireVersion;
    var maybePromise = require_utils4().maybePromise;
    var now = require_utils4().now;
    var calculateDurationInMs = require_utils4().calculateDurationInMs;
    var AggregateOperation = require_aggregate();
    var kResumeQueue = Symbol("resumeQueue");
    var CHANGE_STREAM_OPTIONS = ["resumeAfter", "startAfter", "startAtOperationTime", "fullDocument"];
    var CURSOR_OPTIONS = ["batchSize", "maxAwaitTimeMS", "collation", "readPreference"].concat(CHANGE_STREAM_OPTIONS);
    var CHANGE_DOMAIN_TYPES = {
      COLLECTION: Symbol("Collection"),
      DATABASE: Symbol("Database"),
      CLUSTER: Symbol("Cluster")
    };
    var ChangeStream = class extends EventEmitter {
      constructor(parent, pipeline2, options2) {
        super();
        const Collection = require_collection();
        const Db = require_db();
        const MongoClient2 = require_mongo_client();
        this.pipeline = pipeline2 || [];
        this.options = options2 || {};
        this.parent = parent;
        this.namespace = parent.s.namespace;
        if (parent instanceof Collection) {
          this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
          this.topology = parent.s.db.serverConfig;
        } else if (parent instanceof Db) {
          this.type = CHANGE_DOMAIN_TYPES.DATABASE;
          this.topology = parent.serverConfig;
        } else if (parent instanceof MongoClient2) {
          this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
          this.topology = parent.topology;
        } else {
          throw new TypeError("parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient");
        }
        this.promiseLibrary = parent.s.promiseLibrary;
        if (!this.options.readPreference && parent.s.readPreference) {
          this.options.readPreference = parent.s.readPreference;
        }
        this[kResumeQueue] = new Denque();
        this.cursor = createChangeStreamCursor(this, options2);
        this.closed = false;
        this.on("newListener", (eventName) => {
          if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
            this.cursor.on("data", (change) => processNewChange(this, change));
          }
        });
        this.on("removeListener", (eventName) => {
          if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
            this.cursor.removeAllListeners("data");
          }
        });
      }
      get resumeToken() {
        return this.cursor.resumeToken;
      }
      hasNext(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.hasNext(cb);
          });
        });
      }
      next(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          getCursor(this, (err, cursor) => {
            if (err)
              return cb(err);
            cursor.next((error3, change) => {
              if (error3) {
                this[kResumeQueue].push(() => this.next(cb));
                processError(this, error3, cb);
                return;
              }
              processNewChange(this, change, cb);
            });
          });
        });
      }
      isClosed() {
        return this.closed || this.cursor && this.cursor.isClosed();
      }
      close(callback) {
        return maybePromise(this.parent, callback, (cb) => {
          if (this.closed)
            return cb();
          this.closed = true;
          if (!this.cursor)
            return cb();
          const cursor = this.cursor;
          return cursor.close((err) => {
            ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
            this.cursor = void 0;
            return cb(err);
          });
        });
      }
      pipe(destination, options2) {
        if (!this.pipeDestinations) {
          this.pipeDestinations = [];
        }
        this.pipeDestinations.push(destination);
        return this.cursor.pipe(destination, options2);
      }
      unpipe(destination) {
        if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {
          this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);
        }
        return this.cursor.unpipe(destination);
      }
      stream(options2) {
        this.streamOptions = options2;
        return this.cursor.stream(options2);
      }
      pause() {
        return this.cursor.pause();
      }
      resume() {
        return this.cursor.resume();
      }
    };
    var ChangeStreamCursor = class extends Cursor {
      constructor(topology, operation, options2) {
        super(topology, operation, options2);
        options2 = options2 || {};
        this._resumeToken = null;
        this.startAtOperationTime = options2.startAtOperationTime;
        if (options2.startAfter) {
          this.resumeToken = options2.startAfter;
        } else if (options2.resumeAfter) {
          this.resumeToken = options2.resumeAfter;
        }
      }
      set resumeToken(token) {
        this._resumeToken = token;
        this.emit("resumeTokenChanged", token);
      }
      get resumeToken() {
        return this._resumeToken;
      }
      get resumeOptions() {
        const result = {};
        for (const optionName of CURSOR_OPTIONS) {
          if (this.options[optionName])
            result[optionName] = this.options[optionName];
        }
        if (this.resumeToken || this.startAtOperationTime) {
          ["resumeAfter", "startAfter", "startAtOperationTime"].forEach((key) => delete result[key]);
          if (this.resumeToken) {
            const resumeKey = this.options.startAfter && !this.hasReceived ? "startAfter" : "resumeAfter";
            result[resumeKey] = this.resumeToken;
          } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {
            result.startAtOperationTime = this.startAtOperationTime;
          }
        }
        return result;
      }
      cacheResumeToken(resumeToken) {
        if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {
          this.resumeToken = this.cursorState.postBatchResumeToken;
        } else {
          this.resumeToken = resumeToken;
        }
        this.hasReceived = true;
      }
      _processBatch(batchName, response) {
        const cursor = response.cursor;
        if (cursor.postBatchResumeToken) {
          this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;
          if (cursor[batchName].length === 0) {
            this.resumeToken = cursor.postBatchResumeToken;
          }
        }
      }
      _initializeCursor(callback) {
        super._initializeCursor((err, result) => {
          if (err || result == null) {
            callback(err, result);
            return;
          }
          const response = result.documents[0];
          if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {
            this.startAtOperationTime = response.operationTime;
          }
          this._processBatch("firstBatch", response);
          this.emit("init", result);
          this.emit("response");
          callback(err, result);
        });
      }
      _getMore(callback) {
        super._getMore((err, response) => {
          if (err) {
            callback(err);
            return;
          }
          this._processBatch("nextBatch", response);
          this.emit("more", response);
          this.emit("response");
          callback(err, response);
        });
      }
    };
    function createChangeStreamCursor(self2, options2) {
      const changeStreamStageOptions = { fullDocument: options2.fullDocument || "default" };
      applyKnownOptions(changeStreamStageOptions, options2, CHANGE_STREAM_OPTIONS);
      if (self2.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline2 = [{ $changeStream: changeStreamStageOptions }].concat(self2.pipeline);
      const cursorOptions = applyKnownOptions({}, options2, CURSOR_OPTIONS);
      const changeStreamCursor = new ChangeStreamCursor(self2.topology, new AggregateOperation(self2.parent, pipeline2, options2), cursorOptions);
      relayEvents(changeStreamCursor, self2, ["resumeTokenChanged", "end", "close"]);
      if (self2.listenerCount("change") > 0) {
        changeStreamCursor.on("data", function(change) {
          processNewChange(self2, change);
        });
      }
      changeStreamCursor.on("error", function(error3) {
        processError(self2, error3);
      });
      if (self2.pipeDestinations) {
        const cursorStream = changeStreamCursor.stream(self2.streamOptions);
        for (let pipeDestination of self2.pipeDestinations) {
          cursorStream.pipe(pipeDestination);
        }
      }
      return changeStreamCursor;
    }
    function applyKnownOptions(target, source, optionNames) {
      optionNames.forEach((name2) => {
        if (source[name2]) {
          target[name2] = source[name2];
        }
      });
      return target;
    }
    var SELECTION_TIMEOUT = 3e4;
    function waitForTopologyConnected(topology, options2, callback) {
      setTimeout(() => {
        if (options2 && options2.start == null) {
          options2.start = now();
        }
        const start = options2.start || now();
        const timeout = options2.timeout || SELECTION_TIMEOUT;
        const readPreference = options2.readPreference;
        if (topology.isConnected({ readPreference })) {
          return callback();
        }
        if (calculateDurationInMs(start) > timeout) {
          return callback(new MongoError("Timed out waiting for connection"));
        }
        waitForTopologyConnected(topology, options2, callback);
      }, 500);
    }
    function processNewChange(changeStream, change, callback) {
      const cursor = changeStream.cursor;
      if (change == null) {
        changeStream.closed = true;
      }
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      if (change && !change._id) {
        const noResumeTokenError = new Error("A change stream document has been received that lacks a resume token (_id).");
        if (!callback)
          return changeStream.emit("error", noResumeTokenError);
        return callback(noResumeTokenError);
      }
      cursor.cacheResumeToken(change._id);
      changeStream.options.startAtOperationTime = void 0;
      if (!callback)
        return changeStream.emit("change", change);
      return callback(void 0, change);
    }
    function processError(changeStream, error3, callback) {
      const topology = changeStream.topology;
      const cursor = changeStream.cursor;
      if (changeStream.closed) {
        if (callback)
          callback(new MongoError("ChangeStream is closed"));
        return;
      }
      function resumeWithCursor(newCursor) {
        changeStream.cursor = newCursor;
        processResumeQueue(changeStream);
      }
      function unresumableError(err) {
        if (!callback) {
          changeStream.emit("error", err);
          changeStream.emit("close");
        }
        processResumeQueue(changeStream, err);
        changeStream.closed = true;
      }
      if (cursor && isResumableError(error3, maxWireVersion(cursor.server))) {
        changeStream.cursor = void 0;
        ["data", "close", "end", "error"].forEach((event) => cursor.removeAllListeners(event));
        cursor.close();
        waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, (err) => {
          if (err)
            return unresumableError(err);
          const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);
          if (!callback)
            return resumeWithCursor(newCursor);
          newCursor.hasNext((err2) => {
            if (err2)
              return unresumableError(err2);
            resumeWithCursor(newCursor);
          });
        });
        return;
      }
      if (!callback)
        return changeStream.emit("error", error3);
      return callback(error3);
    }
    function getCursor(changeStream, callback) {
      if (changeStream.isClosed()) {
        callback(new MongoError("ChangeStream is closed."));
        return;
      }
      if (changeStream.cursor) {
        callback(void 0, changeStream.cursor);
        return;
      }
      changeStream[kResumeQueue].push(callback);
    }
    function processResumeQueue(changeStream, err) {
      while (changeStream[kResumeQueue].length) {
        const request = changeStream[kResumeQueue].pop();
        if (changeStream.isClosed() && !err) {
          request(new MongoError("Change Stream is not open."));
          return;
        }
        request(err, changeStream.cursor);
      }
    }
    module2.exports = ChangeStream;
  }
});

// node_modules/mongodb/lib/topologies/topology_base.js
var require_topology_base = __commonJS({
  "node_modules/mongodb/lib/topologies/topology_base.js"(exports2) {
    init_shims();
    "use strict";
    var EventEmitter = __require("events");
    var MongoError = require_core().MongoError;
    var f = __require("util").format;
    var ReadPreference = require_core().ReadPreference;
    var ClientSession = require_core().Sessions.ClientSession;
    var Store = function(topology, storeOptions) {
      var self2 = this;
      var storedOps = [];
      storeOptions = storeOptions || { force: false, bufferMaxEntries: -1 };
      this.s = {
        storedOps,
        storeOptions,
        topology
      };
      Object.defineProperty(this, "length", {
        enumerable: true,
        get: function() {
          return self2.s.storedOps.length;
        }
      });
    };
    Store.prototype.add = function(opType, ns, ops, options2, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, n: ns, o: ops, op: options2, c: callback });
    };
    Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
      if (this.s.storeOptions.force) {
        return callback(MongoError.create({ message: "db closed by application", driver: true }));
      }
      if (this.s.storeOptions.bufferMaxEntries === 0) {
        return callback(MongoError.create({
          message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
          driver: true
        }));
      }
      if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
        while (this.s.storedOps.length > 0) {
          var op = this.s.storedOps.shift();
          op.c(MongoError.create({
            message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries),
            driver: true
          }));
        }
        return;
      }
      this.s.storedOps.push({ t: opType, m: method, o: object, p: params, c: callback });
    };
    Store.prototype.flush = function(err) {
      while (this.s.storedOps.length > 0) {
        this.s.storedOps.shift().c(err || MongoError.create({ message: f("no connection available for operation"), driver: true }));
      }
    };
    var primaryOptions = ["primary", "primaryPreferred", "nearest", "secondaryPreferred"];
    var secondaryOptions = ["secondary", "secondaryPreferred"];
    Store.prototype.execute = function(options2) {
      options2 = options2 || {};
      var ops = this.s.storedOps;
      this.s.storedOps = [];
      var executePrimary = typeof options2.executePrimary === "boolean" ? options2.executePrimary : true;
      var executeSecondary = typeof options2.executeSecondary === "boolean" ? options2.executeSecondary : true;
      while (ops.length > 0) {
        var op = ops.shift();
        if (op.t === "cursor") {
          if (executePrimary && executeSecondary) {
            op.o[op.m].apply(op.o, op.p);
          } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {
            op.o[op.m].apply(op.o, op.p);
          }
        } else if (op.t === "auth") {
          this.s.topology[op.t].apply(this.s.topology, op.o);
        } else {
          if (executePrimary && executeSecondary) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {
            this.s.topology[op.t](op.n, op.o, op.op, op.c);
          }
        }
      }
    };
    Store.prototype.all = function() {
      return this.s.storedOps;
    };
    var ServerCapabilities = function(ismaster) {
      var setup_get_property = function(object, name2, value) {
        Object.defineProperty(object, name2, {
          enumerable: true,
          get: function() {
            return value;
          }
        });
      };
      var aggregationCursor = false;
      var writeCommands = false;
      var textSearch = false;
      var authCommands = false;
      var listCollections = false;
      var listIndexes = false;
      var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1e3;
      var commandsTakeWriteConcern = false;
      var commandsTakeCollation = false;
      if (ismaster.minWireVersion >= 0) {
        textSearch = true;
      }
      if (ismaster.maxWireVersion >= 1) {
        aggregationCursor = true;
        authCommands = true;
      }
      if (ismaster.maxWireVersion >= 2) {
        writeCommands = true;
      }
      if (ismaster.maxWireVersion >= 3) {
        listCollections = true;
        listIndexes = true;
      }
      if (ismaster.maxWireVersion >= 5) {
        commandsTakeWriteConcern = true;
        commandsTakeCollation = true;
      }
      if (ismaster.minWireVersion == null) {
        ismaster.minWireVersion = 0;
      }
      if (ismaster.maxWireVersion == null) {
        ismaster.maxWireVersion = 0;
      }
      setup_get_property(this, "hasAggregationCursor", aggregationCursor);
      setup_get_property(this, "hasWriteCommands", writeCommands);
      setup_get_property(this, "hasTextSearch", textSearch);
      setup_get_property(this, "hasAuthCommands", authCommands);
      setup_get_property(this, "hasListCollectionsCommand", listCollections);
      setup_get_property(this, "hasListIndexesCommand", listIndexes);
      setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
      setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
      setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
      setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
      setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
    };
    var TopologyBase = class extends EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      hasSessionSupport() {
        return this.logicalSessionTimeoutMinutes != null;
      }
      startSession(options2, clientOptions) {
        const session = new ClientSession(this, this.s.sessionPool, options2, clientOptions);
        session.once("ended", () => {
          this.s.sessions.delete(session);
        });
        this.s.sessions.add(session);
        return session;
      }
      endSessions(sessions, callback) {
        return this.s.coreTopology.endSessions(sessions, callback);
      }
      get clientMetadata() {
        return this.s.coreTopology.s.options.metadata;
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.s.coreTopology.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        this.s.coreTopology.command(ns.toString(), cmd, ReadPreference.translate(options2), callback);
      }
      insert(ns, ops, options2, callback) {
        this.s.coreTopology.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        this.s.coreTopology.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        this.s.coreTopology.remove(ns.toString(), ops, options2, callback);
      }
      isConnected(options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        return this.s.coreTopology.isConnected(options2);
      }
      isDestroyed() {
        return this.s.coreTopology.isDestroyed();
      }
      cursor(ns, cmd, options2) {
        options2 = options2 || {};
        options2 = ReadPreference.translate(options2);
        options2.disconnectHandler = this.s.store;
        options2.topology = this;
        return this.s.coreTopology.cursor(ns, cmd, options2);
      }
      lastIsMaster() {
        return this.s.coreTopology.lastIsMaster();
      }
      selectServer(selector, options2, callback) {
        return this.s.coreTopology.selectServer(selector, options2, callback);
      }
      unref() {
        return this.s.coreTopology.unref();
      }
      connections() {
        return this.s.coreTopology.connections();
      }
      close(forceClosed, callback) {
        this.s.sessions.forEach((session) => session.endSession());
        if (this.s.sessionPool) {
          this.s.sessionPool.endAllPooledSessions();
        }
        if (forceClosed === true) {
          this.s.storeOptions.force = forceClosed;
          this.s.store.flush();
        }
        this.s.coreTopology.destroy({
          force: typeof forceClosed === "boolean" ? forceClosed : false
        }, callback);
      }
    };
    Object.defineProperty(TopologyBase.prototype, "bson", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.bson;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "parserType", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.parserType;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "logicalSessionTimeoutMinutes", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.logicalSessionTimeoutMinutes;
      }
    });
    Object.defineProperty(TopologyBase.prototype, "type", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.type;
      }
    });
    exports2.Store = Store;
    exports2.ServerCapabilities = ServerCapabilities;
    exports2.TopologyBase = TopologyBase;
  }
});

// node_modules/mongodb/lib/topologies/native_topology.js
var require_native_topology = __commonJS({
  "node_modules/mongodb/lib/topologies/native_topology.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Topology = require_core().Topology;
    var ServerCapabilities = require_topology_base().ServerCapabilities;
    var Cursor = require_cursor2();
    var translateOptions = require_utils4().translateOptions;
    var NativeTopology = class extends Topology {
      constructor(servers, options2) {
        options2 = options2 || {};
        let clonedOptions = Object.assign({}, {
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          maxPoolSize: typeof options2.maxPoolSize === "number" ? options2.maxPoolSize : typeof options2.poolSize === "number" ? options2.poolSize : 10,
          minPoolSize: typeof options2.minPoolSize === "number" ? options2.minPoolSize : typeof options2.minSize === "number" ? options2.minSize : 0,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        super(servers, clonedOptions);
      }
      capabilities() {
        if (this.s.sCapabilities)
          return this.s.sCapabilities;
        if (this.lastIsMaster() == null)
          return null;
        this.s.sCapabilities = new ServerCapabilities(this.lastIsMaster());
        return this.s.sCapabilities;
      }
      command(ns, cmd, options2, callback) {
        super.command(ns.toString(), cmd, options2, callback);
      }
      insert(ns, ops, options2, callback) {
        super.insert(ns.toString(), ops, options2, callback);
      }
      update(ns, ops, options2, callback) {
        super.update(ns.toString(), ops, options2, callback);
      }
      remove(ns, ops, options2, callback) {
        super.remove(ns.toString(), ops, options2, callback);
      }
    };
    module2.exports = NativeTopology;
  }
});

// node_modules/mongodb/lib/topologies/server.js
var require_server3 = __commonJS({
  "node_modules/mongodb/lib/topologies/server.js"(exports2, module2) {
    init_shims();
    "use strict";
    var CServer = require_core().Server;
    var Cursor = require_cursor2();
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var MongoError = require_core().MongoError;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "reconnectInterval",
      "monitoring",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "compression",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Server = class extends TopologyBase {
      constructor(host2, port2, options2) {
        super();
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        const promiseLibrary = options2.promiseLibrary;
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        if (host2.indexOf("/") !== -1) {
          if (port2 != null && typeof port2 === "object") {
            options2 = port2;
            port2 = null;
          }
        } else if (port2 == null) {
          throw MongoError.create({ message: "port must be specified", driver: true });
        }
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          host: host2,
          port: port2,
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CServer(clonedOptions),
          sCapabilities: null,
          clonedOptions,
          reconnect: clonedOptions.reconnect,
          emitError: clonedOptions.emitError,
          poolSize: clonedOptions.size,
          storeOptions,
          store,
          host: host2,
          port: port2,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = this.s.clonedOptions;
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events = ["timeout", "error", "close"];
            events.forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectHandlers[e]);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect", self2);
          self2.s.store.execute();
        };
        var reconnectFailedHandler = function(err) {
          self2.emit("reconnectFailed", err);
          self2.s.store.flush(err);
        };
        var destroyHandler = function() {
          self2.s.store.flush();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          ["timeout", "error", "close", "destroy"].forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("destroy", destroyHandler);
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectHandlers = {
          timeout: connectErrorHandler("timeout"),
          error: connectErrorHandler("error"),
          close: connectErrorHandler("close")
        };
        [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ].forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.once("timeout", connectHandlers.timeout);
        self2.s.coreTopology.once("error", connectHandlers.error);
        self2.s.coreTopology.once("close", connectHandlers.close);
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.on("reconnectFailed", reconnectFailedHandler);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("attemptReconnect", relay("attemptReconnect"));
        self2.s.coreTopology.on("monitoring", relay("monitoring"));
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Server.prototype, "poolSize", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.connections().length;
      }
    });
    Object.defineProperty(Server.prototype, "autoReconnect", {
      enumerable: true,
      get: function() {
        return this.s.reconnect;
      }
    });
    Object.defineProperty(Server.prototype, "host", {
      enumerable: true,
      get: function() {
        return this.s.host;
      }
    });
    Object.defineProperty(Server.prototype, "port", {
      enumerable: true,
      get: function() {
        return this.s.port;
      }
    });
    module2.exports = Server;
  }
});

// node_modules/mongodb/lib/topologies/mongos.js
var require_mongos2 = __commonJS({
  "node_modules/mongodb/lib/topologies/mongos.js"(exports2, module2) {
    init_shims();
    "use strict";
    var TopologyBase = require_topology_base().TopologyBase;
    var MongoError = require_core().MongoError;
    var CMongos = require_core().Mongos;
    var Cursor = require_cursor2();
    var Server = require_server3();
    var Store = require_topology_base().Store;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "acceptableLatencyMS",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCRL",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "promiseLibrary",
      "monitorCommands"
    ];
    var Mongos = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var reconnect = typeof options2.auto_reconnect === "boolean" ? options2.auto_reconnect : true;
        reconnect = typeof options2.autoReconnect === "boolean" ? options2.autoReconnect : reconnect;
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        this.s = {
          coreTopology: new CMongos(seedlist, clonedOptions),
          sCapabilities: null,
          debug: clonedOptions.debug,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var connectErrorHandler = function() {
          return function(err) {
            var events2 = ["timeout", "error", "close"];
            events2.forEach(function(e) {
              self2.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.close(true);
            try {
              callback(err);
            } catch (err2) {
              process.nextTick(function() {
                throw err2;
              });
            }
          };
        };
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var reconnectHandler = function() {
          self2.emit("reconnect");
          self2.s.store.execute();
        };
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var connectHandler = function() {
          var events2 = ["timeout", "error", "close", "fullsetup"];
          events2.forEach(function(e) {
            self2.s.coreTopology.removeAllListeners(e);
          });
          self2.s.coreTopology.on("timeout", errorHandler("timeout"));
          self2.s.coreTopology.on("error", errorHandler("error"));
          self2.s.coreTopology.on("close", errorHandler("close"));
          self2.s.coreTopology.on("fullsetup", function() {
            self2.emit("fullsetup", self2);
          });
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.on("joined", relay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("reconnect", reconnectHandler);
        self2.s.coreTopology.connect(_options);
      }
    };
    Object.defineProperty(Mongos.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = Mongos;
  }
});

// node_modules/mongodb/lib/topologies/replset.js
var require_replset2 = __commonJS({
  "node_modules/mongodb/lib/topologies/replset.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Server = require_server3();
    var Cursor = require_cursor2();
    var MongoError = require_core().MongoError;
    var TopologyBase = require_topology_base().TopologyBase;
    var Store = require_topology_base().Store;
    var CReplSet = require_core().ReplSet;
    var MAX_JS_INT = require_utils4().MAX_JS_INT;
    var translateOptions = require_utils4().translateOptions;
    var filterOptions = require_utils4().filterOptions;
    var mergeOptions = require_utils4().mergeOptions;
    var legalOptionNames = [
      "ha",
      "haInterval",
      "replicaSet",
      "rs_name",
      "secondaryAcceptableLatencyMS",
      "connectWithNoPrimary",
      "poolSize",
      "ssl",
      "checkServerIdentity",
      "sslValidate",
      "sslCA",
      "sslCert",
      "ciphers",
      "ecdhCurve",
      "sslCRL",
      "sslKey",
      "sslPass",
      "socketOptions",
      "bufferMaxEntries",
      "store",
      "auto_reconnect",
      "autoReconnect",
      "emitError",
      "keepAlive",
      "keepAliveInitialDelay",
      "noDelay",
      "connectTimeoutMS",
      "socketTimeoutMS",
      "strategy",
      "debug",
      "family",
      "loggerLevel",
      "logger",
      "reconnectTries",
      "appname",
      "domainsEnabled",
      "servername",
      "promoteLongs",
      "promoteValues",
      "promoteBuffers",
      "maxStalenessSeconds",
      "promiseLibrary",
      "minSize",
      "monitorCommands"
    ];
    var ReplSet = class extends TopologyBase {
      constructor(servers, options2) {
        super();
        options2 = options2 || {};
        var self2 = this;
        options2 = filterOptions(options2, legalOptionNames);
        for (var i = 0; i < servers.length; i++) {
          if (!(servers[i] instanceof Server)) {
            throw MongoError.create({
              message: "all seed list instances must be of the Server type",
              driver: true
            });
          }
        }
        var storeOptions = {
          force: false,
          bufferMaxEntries: typeof options2.bufferMaxEntries === "number" ? options2.bufferMaxEntries : MAX_JS_INT
        };
        var store = options2.store || new Store(self2, storeOptions);
        var seedlist = servers.map(function(x) {
          return { host: x.host, port: x.port };
        });
        var clonedOptions = mergeOptions({}, {
          disconnectHandler: store,
          cursorFactory: Cursor,
          reconnect: false,
          emitError: typeof options2.emitError === "boolean" ? options2.emitError : true,
          size: typeof options2.poolSize === "number" ? options2.poolSize : 5,
          monitorCommands: typeof options2.monitorCommands === "boolean" ? options2.monitorCommands : false
        });
        clonedOptions = translateOptions(clonedOptions, options2);
        var socketOptions = options2.socketOptions && Object.keys(options2.socketOptions).length > 0 ? options2.socketOptions : options2;
        clonedOptions = translateOptions(clonedOptions, socketOptions);
        var coreTopology = new CReplSet(seedlist, clonedOptions);
        coreTopology.on("reconnect", function() {
          self2.emit("reconnect");
          store.execute();
        });
        this.s = {
          coreTopology,
          sCapabilities: null,
          tag: options2.tag,
          storeOptions,
          clonedOptions,
          store,
          options: options2,
          sessionPool: null,
          sessions: new Set(),
          promiseLibrary: options2.promiseLibrary || Promise
        };
        if (clonedOptions.debug) {
          Object.defineProperty(this, "replset", {
            enumerable: true,
            get: function() {
              return coreTopology;
            }
          });
        }
      }
      connect(_options, callback) {
        var self2 = this;
        if (typeof _options === "function")
          callback = _options, _options = {};
        if (_options == null)
          _options = {};
        if (!(typeof callback === "function"))
          callback = null;
        _options = Object.assign({}, this.s.clonedOptions, _options);
        self2.s.options = _options;
        self2.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === "number" ? _options.bufferMaxEntries : -1;
        var errorHandler = function(event) {
          return function(err) {
            if (event !== "error") {
              self2.emit(event, err);
            }
          };
        };
        var events = [
          "timeout",
          "error",
          "close",
          "serverOpening",
          "serverDescriptionChanged",
          "serverHeartbeatStarted",
          "serverHeartbeatSucceeded",
          "serverHeartbeatFailed",
          "serverClosed",
          "topologyOpening",
          "topologyClosed",
          "topologyDescriptionChanged",
          "commandStarted",
          "commandSucceeded",
          "commandFailed",
          "joined",
          "left",
          "ping",
          "ha"
        ];
        events.forEach(function(e) {
          self2.s.coreTopology.removeAllListeners(e);
        });
        var relay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server);
          };
        };
        var replsetRelay = function(event) {
          return function(t, server) {
            self2.emit(event, t, server.lastIsMaster(), server);
          };
        };
        var relayHa = function(t, state) {
          self2.emit("ha", t, state);
          if (t === "start") {
            self2.emit("ha_connect", t, state);
          } else if (t === "end") {
            self2.emit("ha_ismaster", t, state);
          }
        };
        self2.s.coreTopology.on("joined", replsetRelay("joined"));
        self2.s.coreTopology.on("left", relay("left"));
        self2.s.coreTopology.on("ping", relay("ping"));
        self2.s.coreTopology.on("ha", relayHa);
        self2.s.coreTopology.on("serverDescriptionChanged", relay("serverDescriptionChanged"));
        self2.s.coreTopology.on("serverHeartbeatStarted", relay("serverHeartbeatStarted"));
        self2.s.coreTopology.on("serverHeartbeatSucceeded", relay("serverHeartbeatSucceeded"));
        self2.s.coreTopology.on("serverHeartbeatFailed", relay("serverHeartbeatFailed"));
        self2.s.coreTopology.on("serverOpening", relay("serverOpening"));
        self2.s.coreTopology.on("serverClosed", relay("serverClosed"));
        self2.s.coreTopology.on("topologyOpening", relay("topologyOpening"));
        self2.s.coreTopology.on("topologyClosed", relay("topologyClosed"));
        self2.s.coreTopology.on("topologyDescriptionChanged", relay("topologyDescriptionChanged"));
        self2.s.coreTopology.on("commandStarted", relay("commandStarted"));
        self2.s.coreTopology.on("commandSucceeded", relay("commandSucceeded"));
        self2.s.coreTopology.on("commandFailed", relay("commandFailed"));
        self2.s.coreTopology.on("fullsetup", function() {
          self2.emit("fullsetup", self2, self2);
        });
        self2.s.coreTopology.on("all", function() {
          self2.emit("all", null, self2);
        });
        var connectHandler = function() {
          self2.s.coreTopology.once("timeout", errorHandler("timeout"));
          self2.s.coreTopology.once("error", errorHandler("error"));
          self2.s.coreTopology.once("close", errorHandler("close"));
          self2.emit("open", null, self2);
          try {
            callback(null, self2);
          } catch (err) {
            process.nextTick(function() {
              throw err;
            });
          }
        };
        var connectErrorHandler = function() {
          return function(err) {
            ["timeout", "error", "close"].forEach(function(e) {
              self2.s.coreTopology.removeListener(e, connectErrorHandler);
            });
            self2.s.coreTopology.removeListener("connect", connectErrorHandler);
            self2.s.coreTopology.destroy();
            try {
              callback(err);
            } catch (err2) {
              if (!self2.s.coreTopology.isConnected())
                process.nextTick(function() {
                  throw err2;
                });
            }
          };
        };
        self2.s.coreTopology.once("timeout", connectErrorHandler("timeout"));
        self2.s.coreTopology.once("error", connectErrorHandler("error"));
        self2.s.coreTopology.once("close", connectErrorHandler("close"));
        self2.s.coreTopology.once("connect", connectHandler);
        self2.s.coreTopology.connect(_options);
      }
      close(forceClosed, callback) {
        ["timeout", "error", "close", "joined", "left"].forEach((e) => this.removeAllListeners(e));
        super.close(forceClosed, callback);
      }
    };
    Object.defineProperty(ReplSet.prototype, "haInterval", {
      enumerable: true,
      get: function() {
        return this.s.coreTopology.s.haInterval;
      }
    });
    module2.exports = ReplSet;
  }
});

// node_modules/mongodb/lib/url_parser.js
var require_url_parser = __commonJS({
  "node_modules/mongodb/lib/url_parser.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ReadPreference = require_core().ReadPreference;
    var parser = __require("url");
    var f = __require("util").format;
    var Logger = require_core().Logger;
    var dns = __require("dns");
    var ReadConcern = require_read_concern();
    var qs2 = __require("querystring");
    var MongoParseError = require_error().MongoParseError;
    module2.exports = function(url, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      let result;
      try {
        result = parser.parse(url, true);
      } catch (e) {
        return callback(new Error("URL malformed, cannot be parsed"));
      }
      if (result.protocol !== "mongodb:" && result.protocol !== "mongodb+srv:") {
        return callback(new Error("Invalid schema, expected `mongodb` or `mongodb+srv`"));
      }
      if (result.protocol === "mongodb:") {
        return parseHandler(url, options2, callback);
      }
      if (result.hostname.split(".").length < 3) {
        return callback(new Error("URI does not have hostname, domain name and tld"));
      }
      result.domainLength = result.hostname.split(".").length;
      const hostname = url.substring("mongodb+srv://".length).split("/")[0];
      if (hostname.match(",")) {
        return callback(new Error("Invalid URI, cannot contain multiple hostnames"));
      }
      if (result.port) {
        return callback(new Error("Ports not accepted with `mongodb+srv` URIs"));
      }
      let srvAddress = `_mongodb._tcp.${result.host}`;
      dns.resolveSrv(srvAddress, function(err, addresses) {
        if (err)
          return callback(err);
        if (addresses.length === 0) {
          return callback(new Error("No addresses found at host"));
        }
        for (let i = 0; i < addresses.length; i++) {
          if (!matchesParentDomain(addresses[i].name, result.hostname, result.domainLength)) {
            return callback(new Error("Server record does not share hostname with parent URI"));
          }
        }
        let base = result.auth ? `mongodb://${result.auth}@` : `mongodb://`;
        let connectionStrings = addresses.map(function(address, i) {
          if (i === 0)
            return `${base}${address.name}:${address.port}`;
          else
            return `${address.name}:${address.port}`;
        });
        let connectionString = connectionStrings.join(",") + "/";
        let connectionStringOptions = [];
        if (result.path) {
          let defaultDb = result.path.slice(1);
          if (defaultDb.indexOf("?") !== -1) {
            defaultDb = defaultDb.slice(0, defaultDb.indexOf("?"));
          }
          connectionString += defaultDb;
        }
        if (!options2.ssl && !result.search) {
          connectionStringOptions.push("ssl=true");
        } else if (!options2.ssl && result.search && !result.search.match("ssl")) {
          connectionStringOptions.push("ssl=true");
        }
        if (result.search) {
          connectionStringOptions.push(result.search.replace("?", ""));
        }
        dns.resolveTxt(result.host, function(err2, record) {
          if (err2 && err2.code !== "ENODATA" && err2.code !== "ENOTFOUND")
            return callback(err2);
          if (err2 && err2.code === "ENODATA")
            record = null;
          if (record) {
            if (record.length > 1) {
              return callback(new MongoParseError("Multiple text records not allowed"));
            }
            record = record[0].join("");
            const parsedRecord = qs2.parse(record);
            const items = Object.keys(parsedRecord);
            if (items.some((item) => item !== "authSource" && item !== "replicaSet")) {
              return callback(new MongoParseError("Text record must only set `authSource` or `replicaSet`"));
            }
            if (items.length > 0) {
              connectionStringOptions.push(record);
            }
          }
          if (connectionStringOptions.length) {
            connectionString += `?${connectionStringOptions.join("&")}`;
          }
          parseHandler(connectionString, options2, callback);
        });
      });
    };
    function matchesParentDomain(srvAddress, parentDomain) {
      let regex = /^.*?\./;
      let srv = `.${srvAddress.replace(regex, "")}`;
      let parent = `.${parentDomain.replace(regex, "")}`;
      if (srv.endsWith(parent))
        return true;
      else
        return false;
    }
    function parseHandler(address, options2, callback) {
      let result, err;
      try {
        result = parseConnectionString(address, options2);
      } catch (e) {
        err = e;
      }
      return err ? callback(err, null) : callback(null, result);
    }
    function parseConnectionString(url, options2) {
      let connection_part = "";
      let auth_part = "";
      let query_string_part = "";
      let dbName = "admin";
      let result = parser.parse(url, true);
      if ((result.hostname == null || result.hostname === "") && url.indexOf(".sock") === -1) {
        throw new Error("No hostname or hostnames provided in connection string");
      }
      if (result.port === "0") {
        throw new Error("Invalid port (zero) with hostname");
      }
      if (!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
        throw new Error("Invalid port (larger than 65535) with hostname");
      }
      if (result.path && result.path.length > 0 && result.path[0] !== "/" && url.indexOf(".sock") === -1) {
        throw new Error("Missing delimiting slash between hosts and options");
      }
      if (result.query) {
        for (let name2 in result.query) {
          if (name2.indexOf("::") !== -1) {
            throw new Error("Double colon in host identifier");
          }
          if (result.query[name2] === "") {
            throw new Error("Query parameter " + name2 + " is an incomplete value pair");
          }
        }
      }
      if (result.auth) {
        let parts = result.auth.split(":");
        if (url.indexOf(result.auth) !== -1 && parts.length > 2) {
          throw new Error("Username with password containing an unescaped colon");
        }
        if (url.indexOf(result.auth) !== -1 && result.auth.indexOf("@") !== -1) {
          throw new Error("Username containing an unescaped at-sign");
        }
      }
      let clean = url.split("?").shift();
      let strings = clean.split(",");
      let hosts = [];
      for (let i = 0; i < strings.length; i++) {
        let hostString = strings[i];
        if (hostString.indexOf("mongodb") !== -1) {
          if (hostString.indexOf("@") !== -1) {
            hosts.push(hostString.split("@").pop());
          } else {
            hosts.push(hostString.substr("mongodb://".length));
          }
        } else if (hostString.indexOf("/") !== -1) {
          hosts.push(hostString.split("/").shift());
        } else if (hostString.indexOf("/") === -1) {
          hosts.push(hostString.trim());
        }
      }
      for (let i = 0; i < hosts.length; i++) {
        let r = parser.parse(f("mongodb://%s", hosts[i].trim()));
        if (r.path && r.path.indexOf(".sock") !== -1)
          continue;
        if (r.path && r.path.indexOf(":") !== -1) {
          if (r.path.split("/").length > 1 && r.path.indexOf("::") === -1) {
            throw new Error("Slash in host identifier");
          } else {
            throw new Error("Double colon in host identifier");
          }
        }
      }
      if (url.indexOf("?") !== -1) {
        query_string_part = url.substr(url.indexOf("?") + 1);
        connection_part = url.substring("mongodb://".length, url.indexOf("?"));
      } else {
        connection_part = url.substring("mongodb://".length);
      }
      if (connection_part.indexOf("@") !== -1) {
        auth_part = connection_part.split("@")[0];
        connection_part = connection_part.split("@")[1];
      }
      if (connection_part.split("/").length > 2) {
        throw new Error("Unsupported host '" + connection_part.split("?")[0] + "', hosts must be URL encoded and contain at most one unencoded slash");
      }
      if (connection_part.indexOf(".sock") !== -1) {
        if (connection_part.indexOf(".sock/") !== -1) {
          dbName = connection_part.split(".sock/")[1];
          if (dbName.indexOf("/") !== -1) {
            if (dbName.split("/").length === 2 && dbName.split("/")[1].length === 0) {
              throw new Error("Illegal trailing backslash after database name");
            }
            throw new Error("More than 1 database name in URL");
          }
          connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
        }
      } else if (connection_part.indexOf("/") !== -1) {
        if (connection_part.split("/").length > 2) {
          if (connection_part.split("/")[2].length === 0) {
            throw new Error("Illegal trailing backslash after database name");
          }
          throw new Error("More than 1 database name in URL");
        }
        dbName = connection_part.split("/")[1];
        connection_part = connection_part.split("/")[0];
      }
      connection_part = decodeURIComponent(connection_part);
      let object = {};
      let authPart = auth_part || "";
      let auth = authPart.split(":", 2);
      let user = decodeURIComponent(auth[0]);
      if (auth[0] !== encodeURIComponent(user)) {
        throw new Error("Username contains an illegal unescaped character");
      }
      auth[0] = user;
      if (auth[1]) {
        let pass = decodeURIComponent(auth[1]);
        if (auth[1] !== encodeURIComponent(pass)) {
          throw new Error("Password contains an illegal unescaped character");
        }
        auth[1] = pass;
      }
      if (auth.length === 2)
        object.auth = { user: auth[0], password: auth[1] };
      if (options2 && options2.auth != null)
        object.auth = options2.auth;
      let hostPart;
      let urlOptions;
      let servers;
      let compression2;
      let serverOptions = { socketOptions: {} };
      let dbOptions = { read_preference_tags: [] };
      let replSetServersOptions = { socketOptions: {} };
      let mongosOptions = { socketOptions: {} };
      object.server_options = serverOptions;
      object.db_options = dbOptions;
      object.rs_options = replSetServersOptions;
      object.mongos_options = mongosOptions;
      if (url.match(/\.sock/)) {
        let domainSocket = url.substring(url.indexOf("mongodb://") + "mongodb://".length, url.lastIndexOf(".sock") + ".sock".length);
        if (domainSocket.indexOf("@") !== -1)
          domainSocket = domainSocket.split("@")[1];
        domainSocket = decodeURIComponent(domainSocket);
        servers = [{ domain_socket: domainSocket }];
      } else {
        hostPart = connection_part;
        let deduplicatedServers = {};
        servers = hostPart.split(",").map(function(h2) {
          let _host, _port, ipv6match;
          if (ipv6match = /\[([^\]]+)\](?::(.+))?/.exec(h2)) {
            _host = ipv6match[1];
            _port = parseInt(ipv6match[2], 10) || 27017;
          } else {
            let hostPort = h2.split(":", 2);
            _host = hostPort[0] || "localhost";
            _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
            if (_host.indexOf("?") !== -1)
              _host = _host.split(/\?/)[0];
          }
          if (deduplicatedServers[_host + "_" + _port])
            return null;
          deduplicatedServers[_host + "_" + _port] = 1;
          return { host: _host, port: _port };
        }).filter(function(x) {
          return x != null;
        });
      }
      object.dbName = dbName || "admin";
      urlOptions = (query_string_part || "").split(/[&;]/);
      urlOptions.forEach(function(opt) {
        if (!opt)
          return;
        var splitOpt = opt.split("="), name2 = splitOpt[0], value = splitOpt[1];
        switch (name2) {
          case "slaveOk":
          case "slave_ok":
            serverOptions.slave_ok = value === "true";
            dbOptions.slaveOk = value === "true";
            break;
          case "maxPoolSize":
          case "poolSize":
            serverOptions.poolSize = parseInt(value, 10);
            replSetServersOptions.poolSize = parseInt(value, 10);
            break;
          case "appname":
            object.appname = decodeURIComponent(value);
            break;
          case "autoReconnect":
          case "auto_reconnect":
            serverOptions.auto_reconnect = value === "true";
            break;
          case "ssl":
            if (value === "prefer") {
              serverOptions.ssl = value;
              replSetServersOptions.ssl = value;
              mongosOptions.ssl = value;
              break;
            }
            serverOptions.ssl = value === "true";
            replSetServersOptions.ssl = value === "true";
            mongosOptions.ssl = value === "true";
            break;
          case "sslValidate":
            serverOptions.sslValidate = value === "true";
            replSetServersOptions.sslValidate = value === "true";
            mongosOptions.sslValidate = value === "true";
            break;
          case "replicaSet":
          case "rs_name":
            replSetServersOptions.rs_name = value;
            break;
          case "reconnectWait":
            replSetServersOptions.reconnectWait = parseInt(value, 10);
            break;
          case "retries":
            replSetServersOptions.retries = parseInt(value, 10);
            break;
          case "readSecondary":
          case "read_secondary":
            replSetServersOptions.read_secondary = value === "true";
            break;
          case "fsync":
            dbOptions.fsync = value === "true";
            break;
          case "journal":
            dbOptions.j = value === "true";
            break;
          case "safe":
            dbOptions.safe = value === "true";
            break;
          case "nativeParser":
          case "native_parser":
            dbOptions.native_parser = value === "true";
            break;
          case "readConcernLevel":
            dbOptions.readConcern = new ReadConcern(value);
            break;
          case "connectTimeoutMS":
            serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
            break;
          case "socketTimeoutMS":
            serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
            break;
          case "w":
            dbOptions.w = parseInt(value, 10);
            if (isNaN(dbOptions.w))
              dbOptions.w = value;
            break;
          case "authSource":
            dbOptions.authSource = value;
            break;
          case "gssapiServiceName":
            dbOptions.gssapiServiceName = value;
            break;
          case "authMechanism":
            if (value === "GSSAPI") {
              if (object.auth == null) {
                let urlDecodeAuthPart = decodeURIComponent(authPart);
                if (urlDecodeAuthPart.indexOf("@") === -1)
                  throw new Error("GSSAPI requires a provided principal");
                object.auth = { user: urlDecodeAuthPart, password: null };
              } else {
                object.auth.user = decodeURIComponent(object.auth.user);
              }
            } else if (value === "MONGODB-X509") {
              object.auth = { user: decodeURIComponent(authPart) };
            }
            if (value !== "GSSAPI" && value !== "MONGODB-X509" && value !== "MONGODB-CR" && value !== "DEFAULT" && value !== "SCRAM-SHA-1" && value !== "SCRAM-SHA-256" && value !== "PLAIN")
              throw new Error("Only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, or SCRAM-SHA-1 is supported by authMechanism");
            dbOptions.authMechanism = value;
            break;
          case "authMechanismProperties":
            {
              let values = value.split(",");
              let o = {};
              values.forEach(function(x) {
                let v = x.split(":");
                o[v[0]] = v[1];
              });
              dbOptions.authMechanismProperties = o;
              if (typeof o.SERVICE_NAME === "string")
                dbOptions.gssapiServiceName = o.SERVICE_NAME;
              if (typeof o.SERVICE_REALM === "string")
                dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
              if (typeof o.CANONICALIZE_HOST_NAME === "string")
                dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME === "true" ? true : false;
            }
            break;
          case "wtimeoutMS":
            dbOptions.wtimeout = parseInt(value, 10);
            break;
          case "readPreference":
            if (!ReadPreference.isValid(value))
              throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
            dbOptions.readPreference = value;
            break;
          case "maxStalenessSeconds":
            dbOptions.maxStalenessSeconds = parseInt(value, 10);
            break;
          case "readPreferenceTags":
            {
              value = decodeURIComponent(value);
              let tagObject = {};
              if (value == null || value === "") {
                dbOptions.read_preference_tags.push(tagObject);
                break;
              }
              let tags = value.split(/,/);
              for (let i = 0; i < tags.length; i++) {
                let parts = tags[i].trim().split(/:/);
                tagObject[parts[0]] = parts[1];
              }
              dbOptions.read_preference_tags.push(tagObject);
            }
            break;
          case "compressors":
            {
              compression2 = serverOptions.compression || {};
              let compressors = value.split(",");
              if (!compressors.every(function(compressor) {
                return compressor === "snappy" || compressor === "zlib";
              })) {
                throw new Error("Compressors must be at least one of snappy or zlib");
              }
              compression2.compressors = compressors;
              serverOptions.compression = compression2;
            }
            break;
          case "zlibCompressionLevel":
            {
              compression2 = serverOptions.compression || {};
              let zlibCompressionLevel = parseInt(value, 10);
              if (zlibCompressionLevel < -1 || zlibCompressionLevel > 9) {
                throw new Error("zlibCompressionLevel must be an integer between -1 and 9");
              }
              compression2.zlibCompressionLevel = zlibCompressionLevel;
              serverOptions.compression = compression2;
            }
            break;
          case "retryWrites":
            dbOptions.retryWrites = value === "true";
            break;
          case "minSize":
            dbOptions.minSize = parseInt(value, 10);
            break;
          default:
            {
              let logger = Logger("URL Parser");
              logger.warn(`${name2} is not supported as a connection string option`);
            }
            break;
        }
      });
      if (dbOptions.read_preference_tags.length === 0) {
        dbOptions.read_preference_tags = null;
      }
      if ((dbOptions.w === -1 || dbOptions.w === 0) && (dbOptions.journal === true || dbOptions.fsync === true || dbOptions.safe === true))
        throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync");
      if (!dbOptions.readPreference) {
        dbOptions.readPreference = "primary";
      }
      dbOptions = Object.assign(dbOptions, options2);
      object.servers = servers;
      return object;
    }
  }
});

// node_modules/mongodb-client-encryption/lib/common.js
var require_common3 = __commonJS({
  "node_modules/mongodb-client-encryption/lib/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    function debug2(msg) {
      if (process.env.MONGODB_CRYPT_DEBUG) {
        console.log(msg);
      }
    }
    function databaseNamespace(ns) {
      return ns.split(".")[0];
    }
    function collectionNamespace(ns) {
      return ns.split(".").slice(1).join(".");
    }
    var MongoCryptError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MongoCryptError";
        Error.captureStackTrace(this, this.constructor);
      }
    };
    function promiseOrCallback(callback, fn) {
      if (typeof callback === "function") {
        fn(function(err) {
          if (err != null) {
            try {
              callback(err);
            } catch (error3) {
              return process.nextTick(() => {
                throw error3;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
        return;
      }
      return new Promise((resolve3, reject) => {
        fn(function(err, res) {
          if (err != null) {
            return reject(err);
          }
          if (arguments.length > 2) {
            return resolve3(Array.prototype.slice.call(arguments, 1));
          }
          resolve3(res);
        });
      });
    }
    module2.exports = {
      debug: debug2,
      databaseNamespace,
      collectionNamespace,
      MongoCryptError,
      promiseOrCallback
    };
  }
});

// node_modules/mongodb-client-encryption/lib/stateMachine.js
var require_stateMachine = __commonJS({
  "node_modules/mongodb-client-encryption/lib/stateMachine.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules2) {
      const tls = __require("tls");
      const MongoNetworkTimeoutError = modules2.mongodb.MongoNetworkTimeoutError || modules2.mongodb.MongoTimeoutError;
      const common = require_common3();
      const debug2 = common.debug;
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const MongoCryptError = common.MongoCryptError;
      const BufferList = require_bl();
      const MONGOCRYPT_CTX_ERROR = 0;
      const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
      const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
      const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
      const MONGOCRYPT_CTX_NEED_KMS = 4;
      const MONGOCRYPT_CTX_READY = 5;
      const MONGOCRYPT_CTX_DONE = 6;
      const HTTPS_PORT = 443;
      const stateToString = new Map([
        [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
        [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
        [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
        [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
        [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
        [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
        [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
      ]);
      class StateMachine {
        constructor(options2) {
          this.options = options2 || {};
          this.bson = options2.bson;
        }
        execute(autoEncrypter, context, callback) {
          const bson = this.bson;
          const keyVaultNamespace = autoEncrypter._keyVaultNamespace;
          const keyVaultClient = autoEncrypter._keyVaultClient;
          const metaDataClient = autoEncrypter._metaDataClient;
          const mongocryptdClient = autoEncrypter._mongocryptdClient;
          const mongocryptdManager = autoEncrypter._mongocryptdManager;
          debug2(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
          switch (context.state) {
            case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
              const filter2 = bson.deserialize(context.nextMongoOperation());
              this.fetchCollectionInfo(metaDataClient, context.ns, filter2, (err, collInfo) => {
                if (err) {
                  return callback(err, null);
                }
                if (collInfo) {
                  context.addMongoOperationResponse(collInfo);
                }
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
              const command = context.nextMongoOperation();
              this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {
                if (err) {
                  if (err instanceof MongoNetworkTimeoutError && mongocryptdManager && !mongocryptdManager.bypassSpawn) {
                    mongocryptdManager.spawn(() => {
                      this.markCommand(mongocryptdClient, context.ns, command, (err2, markedCommand2) => {
                        if (err2)
                          return callback(err2, null);
                        context.addMongoOperationResponse(markedCommand2);
                        context.finishMongoOperation();
                        this.execute(autoEncrypter, context, callback);
                      });
                    });
                    return;
                  }
                  return callback(err, null);
                }
                context.addMongoOperationResponse(markedCommand);
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
              const filter2 = context.nextMongoOperation();
              this.fetchKeys(keyVaultClient, keyVaultNamespace, filter2, (err, keys) => {
                if (err)
                  return callback(err, null);
                keys.forEach((key) => {
                  context.addMongoOperationResponse(bson.serialize(key));
                });
                context.finishMongoOperation();
                this.execute(autoEncrypter, context, callback);
              });
              return;
            }
            case MONGOCRYPT_CTX_NEED_KMS: {
              const promises = [];
              let request;
              while (request = context.nextKMSRequest()) {
                promises.push(this.kmsRequest(request));
              }
              Promise.all(promises).then(() => {
                context.finishKMSRequests();
                this.execute(autoEncrypter, context, callback);
              }).catch((err) => {
                callback(err, null);
              });
              return;
            }
            case MONGOCRYPT_CTX_READY: {
              const finalizedContext = context.finalize();
              if (context.state === MONGOCRYPT_CTX_ERROR) {
                const message = context.status.message || "Finalization error";
                callback(new MongoCryptError(message));
                return;
              }
              callback(null, bson.deserialize(finalizedContext, this.options));
              return;
            }
            case MONGOCRYPT_CTX_ERROR: {
              const message = context.status.message;
              callback(new MongoCryptError(message));
              return;
            }
            case MONGOCRYPT_CTX_DONE:
              return;
            default:
              callback(new MongoCryptError(`Unknown state: ${context.state}`));
              return;
          }
        }
        kmsRequest(request) {
          const parsedUrl = request.endpoint.split(":");
          const port2 = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
          const options2 = { host: parsedUrl[0], servername: parsedUrl[0], port: port2 };
          const message = request.message;
          return new Promise((resolve3, reject) => {
            const buffer2 = new BufferList();
            const socket = tls.connect(options2, () => {
              socket.write(message);
            });
            socket.once("timeout", () => {
              socket.removeAllListeners();
              socket.destroy();
              reject(new MongoCryptError("KMS request timed out"));
            });
            socket.once("error", (err) => {
              socket.removeAllListeners();
              socket.destroy();
              const mcError = new MongoCryptError("KMS request failed");
              mcError.originalError = err;
              reject(mcError);
            });
            socket.on("data", (data) => {
              buffer2.append(data);
              while (request.bytesNeeded > 0 && buffer2.length) {
                const bytesNeeded = Math.min(request.bytesNeeded, buffer2.length);
                request.addResponse(buffer2.slice(0, bytesNeeded));
                buffer2.consume(bytesNeeded);
              }
              if (request.bytesNeeded <= 0) {
                socket.end(resolve3);
              }
            });
          });
        }
        fetchCollectionInfo(client2, ns, filter2, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          client2.db(dbName).listCollections(filter2).toArray((err, collections) => {
            if (err) {
              callback(err, null);
              return;
            }
            const info = collections.length > 0 ? bson.serialize(collections[0]) : null;
            callback(null, info);
          });
        }
        markCommand(client2, ns, command, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(ns);
          const rawCommand = bson.deserialize(command, { promoteLongs: false, promoteValues: false });
          client2.db(dbName).command(rawCommand, (err, response) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(err, bson.serialize(response, this.options));
          });
        }
        fetchKeys(client2, keyVaultNamespace, filter2, callback) {
          const bson = this.bson;
          const dbName = databaseNamespace(keyVaultNamespace);
          const collectionName = collectionNamespace(keyVaultNamespace);
          filter2 = bson.deserialize(filter2);
          client2.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find(filter2).toArray((err, keys) => {
            if (err) {
              callback(err, null);
              return;
            }
            callback(null, keys);
          });
        }
      }
      return { StateMachine };
    };
  }
});

// node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "node_modules/file-uri-to-path/index.js"(exports2, module2) {
    init_shims();
    var sep = __require("path").sep || "/";
    module2.exports = fileUriToPath;
    function fileUriToPath(uri2) {
      if (typeof uri2 != "string" || uri2.length <= 7 || uri2.substring(0, 7) != "file://") {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri2.substring(7));
      var firstSlash = rest.indexOf("/");
      var host2 = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if (host2 == "localhost")
        host2 = "";
      if (host2) {
        host2 = sep + sep + host2;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host2 + path;
    }
  }
});

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports2, module2) {
    init_shims();
    var fs2 = __require("fs");
    var path = __require("path");
    var fileURLToPath2 = require_file_uri_to_path();
    var join2 = path.join;
    var dirname2 = path.dirname;
    var exists = fs2.accessSync && function(path2) {
      try {
        fs2.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs2.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports2.getRoot(exports2.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join2.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module2.exports = exports2 = bindings;
    exports2.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath2(fileName);
      }
      return fileName;
    };
    exports2.getRoot = function getRoot(file) {
      var dir = dirname2(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join2(dir, "package.json")) || exists(join2(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join2(dir, "..");
      }
    };
  }
});

// node_modules/mongodb-client-encryption/lib/mongocryptdManager.js
var require_mongocryptdManager = __commonJS({
  "node_modules/mongodb-client-encryption/lib/mongocryptdManager.js"(exports2, module2) {
    init_shims();
    "use strict";
    var spawn = __require("child_process").spawn;
    var MongocryptdManager = class {
      constructor(extraOptions) {
        extraOptions = extraOptions || {};
        if (extraOptions.mongocryptdURI) {
          this.uri = extraOptions.mongocryptdURI;
        } else {
          this.uri = "mongodb://localhost:27020/?serverSelectionTimeoutMS=1000";
        }
        this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
        this.spawnPath = extraOptions.mongocryptdSpawnPath || "";
        this.spawnArgs = [];
        if (Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
          this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
        }
        if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
          this.spawnArgs.push("--idleShutdownTimeoutSecs", 60);
        }
      }
      spawn(callback) {
        const cmdName = this.spawnPath || "mongocryptd";
        this._child = spawn(cmdName, this.spawnArgs, {
          stdio: "ignore",
          detached: true
        });
        this._child.on("error", () => {
        });
        this._child.unref();
        process.nextTick(callback);
      }
    };
    module2.exports = { MongocryptdManager };
  }
});

// node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js
var require_cryptoCallbacks = __commonJS({
  "node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js"(exports2, module2) {
    init_shims();
    "use strict";
    var crypto = __require("crypto");
    function aes256CbcEncryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function aes256CbcDecryptHook(key, iv, input, output) {
      let result;
      try {
        let cipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function randomHook(buffer2, count) {
      try {
        crypto.randomFillSync(buffer2, 0, count);
      } catch (e) {
        return e;
      }
      return count;
    }
    function randomHookNode4(buffer2, count) {
      let result;
      try {
        result = crypto.randomBytes(count);
      } catch (e) {
        return e;
      }
      result.copy(buffer2);
      return count;
    }
    function sha256Hook(input, output) {
      let result;
      try {
        result = crypto.createHash("sha256").update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    function makeHmacHook(algorithm) {
      return (key, input, output) => {
        let result;
        try {
          result = crypto.createHmac(algorithm, key).update(input).digest();
        } catch (e) {
          return e;
        }
        result.copy(output);
        return result.length;
      };
    }
    function signRsaSha256Hook(key, input, output) {
      let result;
      try {
        const signer = crypto.createSign("sha256WithRSAEncryption");
        const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
        result = signer.update(input).end().sign(privateKey);
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    }
    module2.exports = {
      aes256CbcEncryptHook,
      aes256CbcDecryptHook,
      randomHook: typeof crypto.randomFillSync === "function" ? randomHook : randomHookNode4,
      hmacSha512Hook: makeHmacHook("sha512"),
      hmacSha256Hook: makeHmacHook("sha256"),
      sha256Hook,
      signRsaSha256Hook
    };
  }
});

// node_modules/mongodb-client-encryption/lib/autoEncrypter.js
var require_autoEncrypter = __commonJS({
  "node_modules/mongodb-client-encryption/lib/autoEncrypter.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules2) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const StateMachine = modules2.stateMachine.StateMachine;
      const MongocryptdManager = require_mongocryptdManager().MongocryptdManager;
      const MongoClient2 = modules2.mongodb.MongoClient;
      const MongoError = modules2.mongodb.MongoError;
      const cryptoCallbacks = require_cryptoCallbacks();
      class AutoEncrypter {
        constructor(client2, options2) {
          this._client = client2;
          this._bson = options2.bson || client2.topology.bson;
          this._mongocryptdManager = new MongocryptdManager(options2.extraOptions);
          this._mongocryptdClient = new MongoClient2(this._mongocryptdManager.uri, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            serverSelectionTimeoutMS: 1e3
          });
          this._keyVaultNamespace = options2.keyVaultNamespace || "admin.datakeys";
          this._keyVaultClient = options2.keyVaultClient || client2;
          this._metaDataClient = options2.metadataClient || client2;
          this._bypassEncryption = typeof options2.bypassAutoEncryption === "boolean" ? options2.bypassAutoEncryption : false;
          const mongoCryptOptions = {};
          if (options2.schemaMap) {
            mongoCryptOptions.schemaMap = Buffer.isBuffer(options2.schemaMap) ? options2.schemaMap : this._bson.serialize(options2.schemaMap);
          }
          if (options2.kmsProviders) {
            mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options2.kmsProviders) ? this._bson.serialize(options2.kmsProviders) : options2.kmsProviders;
          }
          if (options2.logger) {
            mongoCryptOptions.logger = options2.logger;
          }
          Object.assign(mongoCryptOptions, { cryptoCallbacks });
          this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);
          this._contextCounter = 0;
        }
        init(callback) {
          const _callback = (err, res) => {
            if (err && err.message && (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))) {
              callback(new MongoError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn"));
              return;
            }
            callback(err, res);
          };
          if (this._mongocryptdManager.bypassSpawn) {
            return this._mongocryptdClient.connect(_callback);
          }
          this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));
        }
        teardown(force, callback) {
          this._mongocryptdClient.close(force, callback);
        }
        encrypt(ns, cmd, options2, callback) {
          if (typeof ns !== "string") {
            throw new TypeError("Parameter `ns` must be a string");
          }
          if (typeof cmd !== "object") {
            throw new TypeError("Parameter `cmd` must be an object");
          }
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          if (this._bypassEncryption) {
            callback(void 0, cmd);
            return;
          }
          const bson = this._bson;
          const commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson.serialize(cmd, options2);
          let context;
          try {
            context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          context.ns = ns;
          context.document = cmd;
          const stateMachine = new StateMachine(Object.assign({ bson }, options2));
          stateMachine.execute(this, context, callback);
        }
        decrypt(response, options2, callback) {
          if (typeof options2 === "function" && callback == null) {
            callback = options2;
            options2 = {};
          }
          const bson = this._bson;
          const buffer2 = Buffer.isBuffer(response) ? response : bson.serialize(response, options2);
          let context;
          try {
            context = this._mongocrypt.makeDecryptionContext(buffer2);
          } catch (err) {
            callback(err, null);
            return;
          }
          context.id = this._contextCounter++;
          const stateMachine = new StateMachine(Object.assign({ bson }, options2));
          stateMachine.execute(this, context, callback);
        }
      }
      return { AutoEncrypter };
    };
  }
});

// node_modules/mongodb-client-encryption/lib/clientEncryption.js
var require_clientEncryption = __commonJS({
  "node_modules/mongodb-client-encryption/lib/clientEncryption.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = function(modules2) {
      const mc = require_bindings()("mongocrypt");
      const common = require_common3();
      const databaseNamespace = common.databaseNamespace;
      const collectionNamespace = common.collectionNamespace;
      const promiseOrCallback = common.promiseOrCallback;
      const StateMachine = modules2.stateMachine.StateMachine;
      const cryptoCallbacks = require_cryptoCallbacks();
      class ClientEncryption {
        constructor(client2, options2) {
          this._client = client2;
          this._bson = options2.bson || client2.topology.bson;
          if (options2.keyVaultNamespace == null) {
            throw new TypeError("Missing required option `keyVaultNamespace`");
          }
          Object.assign(options2, { cryptoCallbacks });
          if (options2.kmsProviders && !Buffer.isBuffer(options2.kmsProviders)) {
            options2.kmsProviders = this._bson.serialize(options2.kmsProviders);
          }
          this._keyVaultNamespace = options2.keyVaultNamespace;
          this._keyVaultClient = options2.keyVaultClient || client2;
          this._mongoCrypt = new mc.MongoCrypt(options2);
        }
        createDataKey(provider, options2, callback) {
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          if (typeof options2 === "undefined") {
            options2 = {};
          }
          const bson = this._bson;
          const dataKey = Object.assign({ provider }, options2.masterKey);
          if (options2.keyAltNames && !Array.isArray(options2.keyAltNames)) {
            throw new TypeError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options2.keyAltNames}.`);
          }
          let keyAltNames = void 0;
          if (options2.keyAltNames && options2.keyAltNames.length > 0) {
            keyAltNames = options2.keyAltNames.map((keyAltName, i) => {
              if (typeof keyAltName !== "string") {
                throw new TypeError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
              }
              return bson.serialize({ keyAltName });
            });
          }
          const dataKeyBson = bson.serialize(dataKey);
          const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, { keyAltNames });
          const stateMachine = new StateMachine({ bson });
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, dataKey2) => {
              if (err) {
                cb(err, null);
                return;
              }
              const dbName = databaseNamespace(this._keyVaultNamespace);
              const collectionName = collectionNamespace(this._keyVaultNamespace);
              this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey2, { writeConcern: { w: "majority" } }, (err2, result) => {
                if (err2) {
                  cb(err2, null);
                  return;
                }
                cb(null, result.insertedId);
              });
            });
          });
        }
        encrypt(value, options2, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({ v: value });
          const contextOptions = Object.assign({}, options2);
          if (options2.keyId) {
            contextOptions.keyId = options2.keyId.buffer;
          }
          if (options2.keyAltName) {
            const keyAltName = options2.keyAltName;
            if (options2.keyId) {
              throw new TypeError(`"options" cannot contain both "keyId" and "keyAltName"`);
            }
            const keyAltNameType = typeof keyAltName;
            if (keyAltNameType !== "string") {
              throw new TypeError(`"options.keyAltName" must be of type string, but was of type ${keyAltNameType}`);
            }
            contextOptions.keyAltName = bson.serialize({ keyAltName });
          }
          const stateMachine = new StateMachine({ bson });
          const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
        decrypt(value, callback) {
          const bson = this._bson;
          const valueBuffer = bson.serialize({ v: value });
          const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
          const stateMachine = new StateMachine({ bson });
          return promiseOrCallback(callback, (cb) => {
            stateMachine.execute(this, context, (err, result) => {
              if (err) {
                cb(err, null);
                return;
              }
              cb(null, result.v);
            });
          });
        }
      }
      return { ClientEncryption };
    };
  }
});

// node_modules/mongodb-client-encryption/index.js
var require_mongodb_client_encryption = __commonJS({
  "node_modules/mongodb-client-encryption/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var defaultModule;
    function loadDefaultModule() {
      if (!defaultModule) {
        defaultModule = extension(require_mongodb());
      }
      return defaultModule;
    }
    var MongoCryptError = require_common3().MongoCryptError;
    function extension(mongodb2) {
      const modules2 = { mongodb: mongodb2 };
      modules2.stateMachine = require_stateMachine()(modules2);
      modules2.autoEncrypter = require_autoEncrypter()(modules2);
      modules2.clientEncryption = require_clientEncryption()(modules2);
      return {
        AutoEncrypter: modules2.autoEncrypter.AutoEncrypter,
        ClientEncryption: modules2.clientEncryption.ClientEncryption,
        MongoCryptError
      };
    }
    module2.exports = {
      extension,
      MongoCryptError,
      get AutoEncrypter() {
        const m2 = loadDefaultModule();
        delete module2.exports.AutoEncrypter;
        module2.exports.AutoEncrypter = m2.AutoEncrypter;
        return m2.AutoEncrypter;
      },
      get ClientEncryption() {
        const m2 = loadDefaultModule();
        delete module2.exports.ClientEncryption;
        module2.exports.ClientEncryption = m2.ClientEncryption;
        return m2.ClientEncryption;
      }
    };
  }
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS({
  "node_modules/mongodb/lib/encrypter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var MongoClient2 = require_mongo_client();
    var BSON2 = require_utils3().retrieveBSON();
    var MongoError = require_error().MongoError;
    try {
      __require.resolve("mongodb-client-encryption");
    } catch (err) {
      throw new MongoError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
    }
    var mongodbClientEncryption = require_mongodb_client_encryption();
    if (typeof mongodbClientEncryption.extension !== "function") {
      throw new MongoError("loaded version of `mongodb-client-encryption` does not have property `extension`. Please make sure you are loading the correct version of `mongodb-client-encryption`");
    }
    var AutoEncrypter = mongodbClientEncryption.extension(require_mongodb()).AutoEncrypter;
    var kInternalClient = Symbol("internalClient");
    var Encrypter = class {
      constructor(client2, options2) {
        this.bypassAutoEncryption = !!options2.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options2.maxPoolSize === 0 && options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = client2;
        } else if (options2.autoEncryption.keyVaultClient == null) {
          options2.autoEncryption.keyVaultClient = this.getInternalClient(client2);
        }
        if (this.bypassAutoEncryption) {
          options2.autoEncryption.metadataClient = void 0;
        } else if (options2.maxPoolSize === 0) {
          options2.autoEncryption.metadataClient = client2;
        } else {
          options2.autoEncryption.metadataClient = this.getInternalClient(client2);
        }
        options2.autoEncryption.bson = Encrypter.makeBSON(options2);
        this.autoEncrypter = new AutoEncrypter(client2, options2.autoEncryption);
      }
      getInternalClient(client2) {
        if (!this[kInternalClient]) {
          const clonedOptions = {};
          for (const key of Object.keys(client2.s.options)) {
            if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].indexOf(key) !== -1)
              continue;
            clonedOptions[key] = client2.s.options[key];
          }
          clonedOptions.minPoolSize = 0;
          const allEvents = [
            "commandStarted",
            "commandSucceeded",
            "commandFailed",
            "serverOpening",
            "serverClosed",
            "serverDescriptionChanged",
            "serverHeartbeatStarted",
            "serverHeartbeatSucceeded",
            "serverHeartbeatFailed",
            "topologyOpening",
            "topologyClosed",
            "topologyDescriptionChanged",
            "joined",
            "left",
            "ping",
            "ha",
            "connectionPoolCreated",
            "connectionPoolClosed",
            "connectionCreated",
            "connectionReady",
            "connectionClosed",
            "connectionCheckOutStarted",
            "connectionCheckOutFailed",
            "connectionCheckedOut",
            "connectionCheckedIn",
            "connectionPoolCleared"
          ];
          this[kInternalClient] = new MongoClient2(client2.s.url, clonedOptions);
          for (const eventName of allEvents) {
            for (const listener of client2.listeners(eventName)) {
              this[kInternalClient].on(eventName, listener);
            }
          }
          client2.on("newListener", (eventName, listener) => {
            this[kInternalClient].on(eventName, listener);
          });
          this.needsConnecting = true;
        }
        return this[kInternalClient];
      }
      connectInternalClient(callback) {
        if (this.needsConnecting) {
          this.needsConnecting = false;
          return this[kInternalClient].connect(callback);
        }
        return callback();
      }
      close(client2, force, callback) {
        this.autoEncrypter.teardown((e) => {
          if (this[kInternalClient] && client2 !== this[kInternalClient]) {
            return this[kInternalClient].close(force, callback);
          }
          callback(e);
        });
      }
      static makeBSON(options2) {
        return (options2 || {}).bson || new BSON2([
          BSON2.Binary,
          BSON2.Code,
          BSON2.DBRef,
          BSON2.Decimal128,
          BSON2.Double,
          BSON2.Int32,
          BSON2.Long,
          BSON2.Map,
          BSON2.MaxKey,
          BSON2.MinKey,
          BSON2.ObjectId,
          BSON2.BSONRegExp,
          BSON2.Symbol,
          BSON2.Timestamp
        ]);
      }
    };
    module2.exports = { Encrypter };
  }
});

// node_modules/mongodb/lib/operations/connect.js
var require_connect2 = __commonJS({
  "node_modules/mongodb/lib/operations/connect.js"(exports2, module2) {
    init_shims();
    "use strict";
    var deprecate = __require("util").deprecate;
    var Logger = require_core().Logger;
    var MongoCredentials = require_core().MongoCredentials;
    var MongoError = require_core().MongoError;
    var Mongos = require_mongos2();
    var NativeTopology = require_native_topology();
    var parse3 = require_core().parseConnectionString;
    var ReadConcern = require_read_concern();
    var ReadPreference = require_core().ReadPreference;
    var ReplSet = require_replset2();
    var Server = require_server3();
    var ServerSessionPool = require_core().Sessions.ServerSessionPool;
    var emitDeprecationWarning = require_utils4().emitDeprecationWarning;
    var emitWarningOnce = require_utils4().emitWarningOnce;
    var fs2 = __require("fs");
    var WriteConcern = require_write_concern();
    var CMAP_EVENT_NAMES = require_events2().CMAP_EVENT_NAMES;
    var client2;
    function loadClient() {
      if (!client2) {
        client2 = require_mongo_client();
      }
      return client2;
    }
    var legacyParse = deprecate(require_url_parser(), "current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.");
    var AUTH_MECHANISM_INTERNAL_MAP = {
      DEFAULT: "default",
      PLAIN: "plain",
      GSSAPI: "gssapi",
      "MONGODB-CR": "mongocr",
      "MONGODB-X509": "x509",
      "MONGODB-AWS": "mongodb-aws",
      "SCRAM-SHA-1": "scram-sha-1",
      "SCRAM-SHA-256": "scram-sha-256"
    };
    var monitoringEvents = [
      "timeout",
      "close",
      "serverOpening",
      "serverDescriptionChanged",
      "serverHeartbeatStarted",
      "serverHeartbeatSucceeded",
      "serverHeartbeatFailed",
      "serverClosed",
      "topologyOpening",
      "topologyClosed",
      "topologyDescriptionChanged",
      "commandStarted",
      "commandSucceeded",
      "commandFailed",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ];
    var VALID_AUTH_MECHANISMS = new Set([
      "DEFAULT",
      "PLAIN",
      "GSSAPI",
      "MONGODB-CR",
      "MONGODB-X509",
      "MONGODB-AWS",
      "SCRAM-SHA-1",
      "SCRAM-SHA-256"
    ]);
    var validOptionNames = [
      "poolSize",
      "ssl",
      "sslValidate",
      "sslCA",
      "sslCert",
      "sslKey",
      "sslPass",
      "sslCRL",
      "autoReconnect",
      "noDelay",
      "keepAlive",
      "keepAliveInitialDelay",
      "connectTimeoutMS",
      "family",
      "socketTimeoutMS",
      "reconnectTries",
      "reconnectInterval",
      "ha",
      "haInterval",
      "replicaSet",
      "secondaryAcceptableLatencyMS",
      "acceptableLatencyMS",
      "connectWithNoPrimary",
      "authSource",
      "w",
      "wtimeout",
      "j",
      "writeConcern",
      "forceServerObjectId",
      "serializeFunctions",
      "ignoreUndefined",
      "raw",
      "bufferMaxEntries",
      "readPreference",
      "pkFactory",
      "promiseLibrary",
      "readConcern",
      "maxStalenessSeconds",
      "loggerLevel",
      "logger",
      "promoteValues",
      "promoteBuffers",
      "promoteLongs",
      "domainsEnabled",
      "checkServerIdentity",
      "validateOptions",
      "appname",
      "auth",
      "user",
      "password",
      "authMechanism",
      "compression",
      "fsync",
      "readPreferenceTags",
      "numberOfRetries",
      "auto_reconnect",
      "minSize",
      "monitorCommands",
      "retryWrites",
      "retryReads",
      "useNewUrlParser",
      "useUnifiedTopology",
      "serverSelectionTimeoutMS",
      "useRecoveryToken",
      "autoEncryption",
      "driverInfo",
      "tls",
      "tlsInsecure",
      "tlsinsecure",
      "tlsAllowInvalidCertificates",
      "tlsAllowInvalidHostnames",
      "tlsCAFile",
      "tlsCertificateFile",
      "tlsCertificateKeyFile",
      "tlsCertificateKeyFilePassword",
      "minHeartbeatFrequencyMS",
      "heartbeatFrequencyMS",
      "directConnection",
      "appName",
      "maxPoolSize",
      "minPoolSize",
      "maxIdleTimeMS",
      "waitQueueTimeoutMS"
    ];
    var ignoreOptionNames = ["native_parser"];
    var legacyOptionNames = ["server", "replset", "replSet", "mongos", "db"];
    function validOptions(options2) {
      const _validOptions = validOptionNames.concat(legacyOptionNames);
      for (const name2 in options2) {
        if (ignoreOptionNames.indexOf(name2) !== -1) {
          continue;
        }
        if (_validOptions.indexOf(name2) === -1) {
          if (options2.validateOptions) {
            return new MongoError(`option ${name2} is not supported`);
          } else {
            emitWarningOnce(`the options [${name2}] is not supported`);
          }
        }
        if (legacyOptionNames.indexOf(name2) !== -1) {
          emitWarningOnce(`the server/replset/mongos/db options are deprecated, all their options are supported at the top level of the options object [${validOptionNames}]`);
        }
      }
    }
    var LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name2) => {
      obj[name2.toLowerCase()] = name2;
      return obj;
    }, {});
    function addListeners2(mongoClient, topology) {
      topology.on("authenticated", createListener(mongoClient, "authenticated"));
      topology.on("error", createListener(mongoClient, "error"));
      topology.on("timeout", createListener(mongoClient, "timeout"));
      topology.on("close", createListener(mongoClient, "close"));
      topology.on("parseError", createListener(mongoClient, "parseError"));
      topology.once("open", createListener(mongoClient, "open"));
      topology.once("fullsetup", createListener(mongoClient, "fullsetup"));
      topology.once("all", createListener(mongoClient, "all"));
      topology.on("reconnect", createListener(mongoClient, "reconnect"));
    }
    function assignTopology(client3, topology) {
      client3.topology = topology;
      if (!(topology instanceof NativeTopology)) {
        topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);
      }
    }
    function clearAllEvents(topology) {
      monitoringEvents.forEach((event) => topology.removeAllListeners(event));
    }
    function collectEvents(mongoClient, topology) {
      let MongoClient2 = loadClient();
      const collectedEvents = [];
      if (mongoClient instanceof MongoClient2) {
        monitoringEvents.forEach((event) => {
          topology.on(event, (object1, object2) => {
            if (event === "open") {
              collectedEvents.push({ event, object1: mongoClient });
            } else {
              collectedEvents.push({ event, object1, object2 });
            }
          });
        });
      }
      return collectedEvents;
    }
    function resolveTLSOptions(options2) {
      if (options2.tls == null) {
        return;
      }
      ["sslCA", "sslKey", "sslCert"].forEach((optionName) => {
        if (options2[optionName]) {
          options2[optionName] = fs2.readFileSync(options2[optionName]);
        }
      });
    }
    function connect2(mongoClient, url, options2, callback) {
      options2 = Object.assign({}, options2);
      if (callback == null) {
        throw new Error("no callback function provided");
      }
      let didRequestAuthentication = false;
      const logger = Logger("MongoClient", options2);
      if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {
        return connectWithUrl(mongoClient, url, options2, connectCallback);
      }
      const useNewUrlParser = options2.useNewUrlParser !== false;
      const parseFn = useNewUrlParser ? parse3 : legacyParse;
      const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;
      parseFn(url, options2, (err, _object) => {
        if (err)
          return callback(err);
        const object = transform(_object);
        const _finalOptions = createUnifiedOptions(object, options2);
        if (_finalOptions.socketTimeoutMS == null)
          _finalOptions.socketTimeoutMS = 0;
        if (_finalOptions.connectTimeoutMS == null)
          _finalOptions.connectTimeoutMS = 1e4;
        if (_finalOptions.retryWrites == null)
          _finalOptions.retryWrites = true;
        if (_finalOptions.useRecoveryToken == null)
          _finalOptions.useRecoveryToken = true;
        if (_finalOptions.readPreference == null)
          _finalOptions.readPreference = "primary";
        if (_finalOptions.db_options && _finalOptions.db_options.auth) {
          delete _finalOptions.db_options.auth;
        }
        resolveTLSOptions(_finalOptions);
        mongoClient.s.options = _finalOptions;
        mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);
        mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);
        if (object.servers.length === 0) {
          return callback(new Error("connection string must contain at least one seed host"));
        }
        if (_finalOptions.auth && !_finalOptions.credentials) {
          try {
            didRequestAuthentication = true;
            _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);
          } catch (err2) {
            return callback(err2);
          }
        }
        if (_finalOptions.useUnifiedTopology) {
          return createTopology(mongoClient, "unified", _finalOptions, connectCallback);
        }
        emitWarningOnce("Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.");
        if (_finalOptions.replicaSet || _finalOptions.rs_name) {
          return createTopology(mongoClient, "replicaset", _finalOptions, connectCallback);
        } else if (object.servers.length > 1) {
          return createTopology(mongoClient, "mongos", _finalOptions, connectCallback);
        } else {
          return createServer2(mongoClient, _finalOptions, connectCallback);
        }
      });
      function connectCallback(err, topology) {
        const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;
        if (err && err.message === "no mongos proxies found in seed list") {
          if (logger.isWarn()) {
            logger.warn(warningMessage);
          }
          return callback(new MongoError(warningMessage));
        }
        if (didRequestAuthentication) {
          mongoClient.emit("authenticated", null, true);
        }
        callback(err, topology);
      }
    }
    function connectWithUrl(mongoClient, url, options2, connectCallback) {
      assignTopology(mongoClient, url);
      addListeners2(mongoClient, url);
      relayEvents(mongoClient, url);
      let finalOptions = Object.assign({}, options2);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        finalOptions.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;
      if (isDoingAuth && !finalOptions.credentials) {
        try {
          finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);
        } catch (err) {
          return connectCallback(err, url);
        }
      }
      return url.connect(finalOptions, connectCallback);
    }
    function createListener(mongoClient, event) {
      const eventSet = new Set(["all", "fullsetup", "open", "reconnect"]);
      return (v1, v2) => {
        if (eventSet.has(event)) {
          return mongoClient.emit(event, mongoClient);
        }
        mongoClient.emit(event, v1, v2);
      };
    }
    function createServer2(mongoClient, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const servers = translateOptions(options2);
      const server = servers[0];
      const collectedEvents = collectEvents(mongoClient, server);
      server.connect(options2, (err, topology) => {
        if (err) {
          server.close(true);
          return callback(err);
        }
        clearAllEvents(server);
        relayEvents(mongoClient, server);
        addListeners2(mongoClient, server);
        const ismaster = topology.lastIsMaster();
        assignTopology(mongoClient, topology);
        if (ismaster && ismaster.msg === "isdbgrid") {
          topology.close();
          return createTopology(mongoClient, "mongos", options2, callback);
        }
        replayEvents(mongoClient, collectedEvents);
        callback(err, topology);
      });
    }
    var DEPRECATED_UNIFIED_EVENTS = new Set([
      "reconnect",
      "reconnectFailed",
      "attemptReconnect",
      "joined",
      "left",
      "ping",
      "ha",
      "all",
      "fullsetup",
      "open"
    ]);
    function registerDeprecatedEventNotifiers(client3) {
      client3.on("newListener", (eventName) => {
        if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {
          emitDeprecationWarning(`The \`${eventName}\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, "DeprecationWarning");
        }
      });
    }
    function createTopology(mongoClient, topologyType, options2, callback) {
      options2.promiseLibrary = mongoClient.s.promiseLibrary;
      const translationOptions = {};
      if (topologyType === "unified")
        translationOptions.createServers = false;
      const servers = translateOptions(options2, translationOptions);
      if (options2.autoEncryption != null) {
        const Encrypter = require_encrypter().Encrypter;
        options2.encrypter = new Encrypter(mongoClient, options2);
        options2.autoEncrypter = options2.encrypter.autoEncrypter;
      }
      let topology;
      if (topologyType === "mongos") {
        topology = new Mongos(servers, options2);
      } else if (topologyType === "replicaset") {
        topology = new ReplSet(servers, options2);
      } else if (topologyType === "unified") {
        topology = new NativeTopology(options2.servers, options2);
        registerDeprecatedEventNotifiers(mongoClient);
      }
      addListeners2(mongoClient, topology);
      relayEvents(mongoClient, topology);
      assignTopology(mongoClient, topology);
      if (options2.autoEncrypter) {
        options2.autoEncrypter.init((err) => {
          if (err) {
            callback(err);
            return;
          }
          topology.connect(options2, (err2) => {
            if (err2) {
              topology.close(true);
              callback(err2);
              return;
            }
            options2.encrypter.connectInternalClient((error3) => {
              if (error3)
                return callback(error3);
              callback(void 0, topology);
            });
          });
        });
        return;
      }
      topology.connect(options2, (err) => {
        if (err) {
          topology.close(true);
          return callback(err);
        }
        callback(void 0, topology);
        return;
      });
    }
    function createUnifiedOptions(finalOptions, options2) {
      const childOptions = [
        "mongos",
        "server",
        "db",
        "replset",
        "db_options",
        "server_options",
        "rs_options",
        "mongos_options"
      ];
      const noMerge = ["readconcern", "compression", "autoencryption"];
      const skip = ["w", "wtimeout", "j", "journal", "fsync", "writeconcern"];
      for (const name2 in options2) {
        if (skip.indexOf(name2.toLowerCase()) !== -1) {
          continue;
        } else if (noMerge.indexOf(name2.toLowerCase()) !== -1) {
          finalOptions[name2] = options2[name2];
        } else if (childOptions.indexOf(name2.toLowerCase()) !== -1) {
          finalOptions = mergeOptions(finalOptions, options2[name2], false);
        } else {
          if (options2[name2] && typeof options2[name2] === "object" && !Buffer.isBuffer(options2[name2]) && !Array.isArray(options2[name2])) {
            finalOptions = mergeOptions(finalOptions, options2[name2], true);
          } else {
            finalOptions[name2] = options2[name2];
          }
        }
      }
      const optionsWriteConcern = WriteConcern.fromOptions(options2);
      if (optionsWriteConcern) {
        finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);
      }
      return finalOptions;
    }
    function generateCredentials(client3, username, password, options2) {
      options2 = Object.assign({}, options2);
      const source = options2.authSource || options2.authdb || options2.dbName;
      const authMechanismRaw = options2.authMechanism || "DEFAULT";
      const authMechanism = authMechanismRaw.toUpperCase();
      const mechanismProperties = options2.authMechanismProperties;
      if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {
        throw MongoError.create({
          message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,
          driver: true
        });
      }
      return new MongoCredentials({
        mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],
        mechanismProperties,
        source,
        username,
        password
      });
    }
    function legacyTransformUrlOptions(object) {
      return mergeOptions(createUnifiedOptions({}, object), object, false);
    }
    function mergeOptions(target, source, flatten) {
      for (const name2 in source) {
        if (source[name2] && typeof source[name2] === "object" && flatten) {
          target = mergeOptions(target, source[name2], flatten);
        } else {
          target[name2] = source[name2];
        }
      }
      return target;
    }
    function relayEvents(mongoClient, topology) {
      const serverOrCommandEvents = [
        "commandStarted",
        "commandSucceeded",
        "commandFailed",
        "serverOpening",
        "serverClosed",
        "serverDescriptionChanged",
        "serverHeartbeatStarted",
        "serverHeartbeatSucceeded",
        "serverHeartbeatFailed",
        "topologyOpening",
        "topologyClosed",
        "topologyDescriptionChanged",
        "joined",
        "left",
        "ping",
        "ha"
      ].concat(CMAP_EVENT_NAMES);
      serverOrCommandEvents.forEach((event) => {
        topology.on(event, (object1, object2) => {
          mongoClient.emit(event, object1, object2);
        });
      });
    }
    function replayEvents(mongoClient, events) {
      for (let i = 0; i < events.length; i++) {
        mongoClient.emit(events[i].event, events[i].object1, events[i].object2);
      }
    }
    function transformUrlOptions(_object) {
      let object = Object.assign({ servers: _object.hosts }, _object.options);
      for (let name2 in object) {
        const camelCaseName = LEGACY_OPTIONS_MAP[name2];
        if (camelCaseName) {
          object[camelCaseName] = object[name2];
        }
      }
      const hasUsername = _object.auth && _object.auth.username;
      const hasAuthMechanism = _object.options && _object.options.authMechanism;
      if (hasUsername || hasAuthMechanism) {
        object.auth = Object.assign({}, _object.auth);
        if (object.auth.db) {
          object.authSource = object.authSource || object.auth.db;
        }
        if (object.auth.username) {
          object.auth.user = object.auth.username;
        }
      }
      if (_object.defaultDatabase) {
        object.dbName = _object.defaultDatabase;
      }
      if (object.maxPoolSize) {
        object.poolSize = object.maxPoolSize;
      }
      if (object.readConcernLevel) {
        object.readConcern = new ReadConcern(object.readConcernLevel);
      }
      if (object.wTimeoutMS) {
        object.wtimeout = object.wTimeoutMS;
        object.wTimeoutMS = void 0;
      }
      if (_object.srvHost) {
        object.srvHost = _object.srvHost;
      }
      const wcKeys = ["w", "wtimeout", "j", "journal", "fsync"];
      for (const key of wcKeys) {
        if (object[key] !== void 0) {
          if (object.writeConcern === void 0)
            object.writeConcern = {};
          object.writeConcern[key] = object[key];
          object[key] = void 0;
        }
      }
      return object;
    }
    function translateOptions(options2, translationOptions) {
      translationOptions = Object.assign({}, { createServers: true }, translationOptions);
      if (typeof options2.readPreference === "string" || typeof options2.read_preference === "string") {
        options2.readPreference = new ReadPreference(options2.readPreference || options2.read_preference);
      }
      if (options2.readPreference && (options2.readPreferenceTags || options2.read_preference_tags)) {
        options2.readPreference.tags = options2.readPreferenceTags || options2.read_preference_tags;
      }
      if (options2.maxStalenessSeconds) {
        options2.readPreference.maxStalenessSeconds = options2.maxStalenessSeconds;
      }
      if (options2.socketTimeoutMS == null)
        options2.socketTimeoutMS = 0;
      if (options2.connectTimeoutMS == null)
        options2.connectTimeoutMS = 1e4;
      if (!translationOptions.createServers) {
        return;
      }
      return options2.servers.map((serverObj) => {
        return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options2) : new Server(serverObj.host, serverObj.port, options2);
      });
    }
    module2.exports = { validOptions, connect: connect2 };
  }
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS({
  "node_modules/mongodb/lib/mongo_client.js"(exports2, module2) {
    init_shims();
    "use strict";
    var ChangeStream = require_change_stream();
    var Db = require_db();
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var MongoError = require_core().MongoError;
    var deprecate = __require("util").deprecate;
    var WriteConcern = require_write_concern();
    var MongoDBNamespace = require_utils4().MongoDBNamespace;
    var ReadPreference = require_read_preference();
    var maybePromise = require_utils4().maybePromise;
    var NativeTopology = require_native_topology();
    var connect2 = require_connect2().connect;
    var validOptions = require_connect2().validOptions;
    function MongoClient2(url, options2) {
      if (!(this instanceof MongoClient2))
        return new MongoClient2(url, options2);
      EventEmitter.call(this);
      if (options2 && options2.autoEncryption)
        require_encrypter();
      this.s = {
        url,
        options: options2 || {},
        promiseLibrary: options2 && options2.promiseLibrary || Promise,
        dbCache: new Map(),
        sessions: new Set(),
        writeConcern: WriteConcern.fromOptions(options2),
        readPreference: ReadPreference.fromOptions(options2) || ReadPreference.primary,
        namespace: new MongoDBNamespace("admin")
      };
    }
    inherits(MongoClient2, EventEmitter);
    Object.defineProperty(MongoClient2.prototype, "writeConcern", {
      enumerable: true,
      get: function() {
        return this.s.writeConcern;
      }
    });
    Object.defineProperty(MongoClient2.prototype, "readPreference", {
      enumerable: true,
      get: function() {
        return this.s.readPreference;
      }
    });
    MongoClient2.prototype.connect = function(callback) {
      if (typeof callback === "string") {
        throw new TypeError("`connect` only accepts a callback");
      }
      const client2 = this;
      return maybePromise(this, callback, (cb) => {
        const err = validOptions(client2.s.options);
        if (err)
          return cb(err);
        connect2(client2, client2.s.url, client2.s.options, (err2) => {
          if (err2)
            return cb(err2);
          cb(null, client2);
        });
      });
    };
    MongoClient2.prototype.logout = deprecate(function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      if (typeof callback === "function")
        callback(null, true);
    }, "Multiple authentication is prohibited on a connected client, please only authenticate once per MongoClient");
    MongoClient2.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      const client2 = this;
      return maybePromise(this, callback, (cb) => {
        const completeClose = (err) => {
          client2.emit("close", client2);
          if (!(client2.topology instanceof NativeTopology)) {
            for (const item of client2.s.dbCache) {
              item[1].emit("close", client2);
            }
          }
          client2.removeAllListeners("close");
          cb(err);
        };
        if (client2.topology == null) {
          completeClose();
          return;
        }
        client2.topology.close(force, (err) => {
          const encrypter = client2.topology.s.options.encrypter;
          if (encrypter) {
            return encrypter.close(client2, force, (err2) => {
              completeClose(err || err2);
            });
          }
          completeClose(err);
        });
      });
    };
    MongoClient2.prototype.db = function(dbName, options2) {
      options2 = options2 || {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.s.options, options2);
      if (this.s.dbCache.has(dbName) && finalOptions.returnNonCachedInstance !== true) {
        return this.s.dbCache.get(dbName);
      }
      finalOptions.promiseLibrary = this.s.promiseLibrary;
      if (!this.topology) {
        throw new MongoError("MongoClient must be connected before calling MongoClient.prototype.db");
      }
      const db = new Db(dbName, this.topology, finalOptions);
      this.s.dbCache.set(dbName, db);
      return db;
    };
    MongoClient2.prototype.isConnected = function(options2) {
      options2 = options2 || {};
      if (!this.topology)
        return false;
      return this.topology.isConnected(options2);
    };
    MongoClient2.connect = function(url, options2, callback) {
      const args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      const mongoClient = new MongoClient2(url, options2);
      return mongoClient.connect(callback);
    };
    MongoClient2.prototype.startSession = function(options2) {
      options2 = Object.assign({ explicit: true }, options2);
      if (!this.topology) {
        throw new MongoError("Must connect to a server before calling this method");
      }
      return this.topology.startSession(options2, this.s.options);
    };
    MongoClient2.prototype.withSession = function(options2, operation) {
      if (typeof options2 === "function")
        operation = options2, options2 = void 0;
      const session = this.startSession(options2);
      let cleanupHandler = (err, result, opts) => {
        cleanupHandler = () => {
          throw new ReferenceError("cleanupHandler was called too many times");
        };
        opts = Object.assign({ throw: true }, opts);
        session.endSession();
        if (err) {
          if (opts.throw)
            throw err;
          return Promise.reject(err);
        }
      };
      try {
        const result = operation(session);
        return Promise.resolve(result).then((result2) => cleanupHandler(null, result2)).catch((err) => cleanupHandler(err, null, { throw: true }));
      } catch (err) {
        return cleanupHandler(err, null, { throw: false });
      }
    };
    MongoClient2.prototype.watch = function(pipeline2, options2) {
      pipeline2 = pipeline2 || [];
      options2 = options2 || {};
      if (!Array.isArray(pipeline2)) {
        options2 = pipeline2;
        pipeline2 = [];
      }
      return new ChangeStream(this, pipeline2, options2);
    };
    MongoClient2.prototype.getLogger = function() {
      return this.s.options.logger;
    };
    module2.exports = MongoClient2;
  }
});

// node_modules/mongodb/lib/gridfs/chunk.js
var require_chunk = __commonJS({
  "node_modules/mongodb/lib/gridfs/chunk.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Binary2 = require_core().BSON.Binary;
    var ObjectID2 = require_core().BSON.ObjectID;
    var Buffer2 = require_safe_buffer().Buffer;
    var Chunk = function(file, mongoObject, writeConcern) {
      if (!(this instanceof Chunk))
        return new Chunk(file, mongoObject);
      this.file = file;
      var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
      this.writeConcern = writeConcern || { w: 1 };
      this.objectId = mongoObjectFinal._id == null ? new ObjectID2() : mongoObjectFinal._id;
      this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
      this.data = new Binary2();
      if (typeof mongoObjectFinal.data === "string") {
        var buffer2 = Buffer2.alloc(mongoObjectFinal.data.length);
        buffer2.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, "binary");
        this.data = new Binary2(buffer2);
      } else if (Array.isArray(mongoObjectFinal.data)) {
        buffer2 = Buffer2.alloc(mongoObjectFinal.data.length);
        var data = mongoObjectFinal.data.join("");
        buffer2.write(data, 0, data.length, "binary");
        this.data = new Binary2(buffer2);
      } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === "Binary") {
        this.data = mongoObjectFinal.data;
      } else if (!Buffer2.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {
        throw Error("Illegal chunk format");
      }
      this.internalPosition = 0;
    };
    Chunk.prototype.write = function(data, callback) {
      this.data.write(data, this.internalPosition, data.length, "binary");
      this.internalPosition = this.data.length();
      if (callback != null)
        return callback(null, this);
      return this;
    };
    Chunk.prototype.read = function(length) {
      length = length == null || length === 0 ? this.length() : length;
      if (this.length() - this.internalPosition + 1 >= length) {
        var data = this.data.read(this.internalPosition, length);
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return "";
      }
    };
    Chunk.prototype.readSlice = function(length) {
      if (this.length() - this.internalPosition >= length) {
        var data = null;
        if (this.data.buffer != null) {
          data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
        } else {
          data = Buffer2.alloc(length);
          length = this.data.readInto(data, this.internalPosition);
        }
        this.internalPosition = this.internalPosition + length;
        return data;
      } else {
        return null;
      }
    };
    Chunk.prototype.eof = function() {
      return this.internalPosition === this.length() ? true : false;
    };
    Chunk.prototype.getc = function() {
      return this.read(1);
    };
    Chunk.prototype.rewind = function() {
      this.internalPosition = 0;
      this.data = new Binary2();
    };
    Chunk.prototype.save = function(options2, callback) {
      var self2 = this;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      self2.file.chunkCollection(function(err, collection) {
        if (err)
          return callback(err);
        var writeOptions = { upsert: true };
        for (var name2 in options2)
          writeOptions[name2] = options2[name2];
        for (name2 in self2.writeConcern)
          writeOptions[name2] = self2.writeConcern[name2];
        if (self2.data.length() > 0) {
          self2.buildMongoObject(function(mongoObject) {
            var options3 = { forceServerObjectId: true };
            for (var name3 in self2.writeConcern) {
              options3[name3] = self2.writeConcern[name3];
            }
            collection.replaceOne({ _id: self2.objectId }, mongoObject, writeOptions, function(err2) {
              callback(err2, self2);
            });
          });
        } else {
          callback(null, self2);
        }
      });
    };
    Chunk.prototype.buildMongoObject = function(callback) {
      var mongoObject = {
        files_id: this.file.fileId,
        n: this.chunkNumber,
        data: this.data
      };
      if (this.objectId != null)
        mongoObject._id = this.objectId;
      callback(mongoObject);
    };
    Chunk.prototype.length = function() {
      return this.data.length();
    };
    Object.defineProperty(Chunk.prototype, "position", {
      enumerable: true,
      get: function() {
        return this.internalPosition;
      },
      set: function(value) {
        this.internalPosition = value;
      }
    });
    Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
    module2.exports = Chunk;
  }
});

// node_modules/mongodb/lib/gridfs/grid_store.js
var require_grid_store = __commonJS({
  "node_modules/mongodb/lib/gridfs/grid_store.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Chunk = require_chunk();
    var ObjectID2 = require_core().BSON.ObjectID;
    var ReadPreference = require_core().ReadPreference;
    var Buffer2 = require_safe_buffer().Buffer;
    var fs2 = __require("fs");
    var f = __require("util").format;
    var util2 = __require("util");
    var MongoError = require_core().MongoError;
    var inherits = util2.inherits;
    var Duplex = __require("stream").Duplex;
    var shallowClone = require_utils4().shallowClone;
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var deprecate = __require("util").deprecate;
    var REFERENCE_BY_FILENAME = 0;
    var REFERENCE_BY_ID = 1;
    var deprecationFn = deprecate(() => {
    }, "GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead");
    var GridStore = function GridStore2(db, id, filename, mode, options2) {
      deprecationFn();
      if (!(this instanceof GridStore2))
        return new GridStore2(db, id, filename, mode, options2);
      this.db = db;
      if (typeof options2 === "undefined")
        options2 = {};
      if (typeof mode === "undefined") {
        mode = filename;
        filename = void 0;
      } else if (typeof mode === "object") {
        options2 = mode;
        mode = filename;
        filename = void 0;
      }
      if (id && id._bsontype === "ObjectID") {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      } else if (typeof filename === "undefined") {
        this.referenceBy = REFERENCE_BY_FILENAME;
        this.filename = id;
        if (mode.indexOf("w") != null) {
          this.fileId = new ObjectID2();
        }
      } else {
        this.referenceBy = REFERENCE_BY_ID;
        this.fileId = id;
        this.filename = filename;
      }
      this.mode = mode == null ? "r" : mode;
      this.options = options2 || {};
      this.isOpen = false;
      this.root = this.options["root"] == null ? GridStore2.DEFAULT_ROOT_COLLECTION : this.options["root"];
      this.position = 0;
      this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;
      this.writeConcern = _getWriteConcern(db, this.options);
      this.internalChunkSize = this.options["chunkSize"] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options["chunkSize"];
      var promiseLibrary = this.options.promiseLibrary || Promise;
      this.promiseLibrary = promiseLibrary;
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        get: function() {
          return this.internalChunkSize;
        },
        set: function(value) {
          if (!(this.mode[0] === "w" && this.position === 0 && this.uploadDate == null)) {
            this.internalChunkSize = this.internalChunkSize;
          } else {
            this.internalChunkSize = value;
          }
        }
      });
      Object.defineProperty(this, "md5", {
        enumerable: true,
        get: function() {
          return this.internalMd5;
        }
      });
      Object.defineProperty(this, "chunkNumber", {
        enumerable: true,
        get: function() {
          return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
        }
      });
    };
    GridStore.prototype.open = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      if (this.mode !== "w" && this.mode !== "w+" && this.mode !== "r") {
        throw MongoError.create({ message: "Illegal mode " + this.mode, driver: true });
      }
      return executeLegacyOperation(this.db.s.topology, open, [this, options2, callback], {
        skipSessions: true
      });
    };
    var open = function(self2, options2, callback) {
      var writeConcern = _getWriteConcern(self2.db, self2.options);
      if (self2.mode === "w" || self2.mode === "w+") {
        var collection = self2.collection();
        collection.ensureIndex([["filename", 1]], writeConcern, function() {
          var chunkCollection = self2.chunkCollection();
          var chunkIndexOptions = shallowClone(writeConcern);
          chunkIndexOptions.unique = true;
          chunkCollection.ensureIndex([
            ["files_id", 1],
            ["n", 1]
          ], chunkIndexOptions, function() {
            _open(self2, writeConcern, function(err, r) {
              if (err)
                return callback(err);
              self2.isOpen = true;
              callback(err, r);
            });
          });
        });
      } else {
        _open(self2, writeConcern, function(err, r) {
          if (err)
            return callback(err);
          self2.isOpen = true;
          callback(err, r);
        });
      }
    };
    GridStore.prototype.eof = function() {
      return this.position === this.length ? true : false;
    };
    GridStore.prototype.getc = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, getc, [this, options2, callback], {
        skipSessions: true
      });
    };
    var getc = function(self2, options2, callback) {
      if (self2.eof()) {
        callback(null, null);
      } else if (self2.currentChunk.eof()) {
        nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
          self2.currentChunk = chunk;
          self2.position = self2.position + 1;
          callback(err, self2.currentChunk.getc());
        });
      } else {
        self2.position = self2.position + 1;
        callback(null, self2.currentChunk.getc());
      }
    };
    GridStore.prototype.puts = function(string, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      var finalString = string.match(/\n$/) == null ? string + "\n" : string;
      return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options2, callback], { skipSessions: true });
    };
    GridStore.prototype.stream = function() {
      return new GridStoreStream(this);
    };
    GridStore.prototype.write = function write(data, close2, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close2, options2, callback], { skipSessions: true });
    };
    GridStore.prototype.destroy = function destroy() {
      if (!this.writable)
        return;
      this.readable = false;
      if (this.writable) {
        this.writable = false;
        this._q.length = 0;
        this.emit("close");
      }
    };
    GridStore.prototype.writeFile = function(file, options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options2, callback], {
        skipSessions: true
      });
    };
    var writeFile = function(self2, file, options2, callback) {
      if (typeof file === "string") {
        fs2.open(file, "r", function(err, fd) {
          if (err)
            return callback(err);
          self2.writeFile(fd, callback);
        });
        return;
      }
      self2.open(function(err, self3) {
        if (err)
          return callback(err, self3);
        fs2.fstat(file, function(err2, stats) {
          if (err2)
            return callback(err2, self3);
          var offset = 0;
          var index2 = 0;
          var writeChunk = function() {
            var _buffer = Buffer2.alloc(self3.chunkSize);
            fs2.read(file, _buffer, 0, _buffer.length, offset, function(err3, bytesRead, data) {
              if (err3)
                return callback(err3, self3);
              offset = offset + bytesRead;
              var chunk = new Chunk(self3, { n: index2++ }, self3.writeConcern);
              chunk.write(data.slice(0, bytesRead), function(err4, chunk2) {
                if (err4)
                  return callback(err4, self3);
                chunk2.save({}, function(err5) {
                  if (err5)
                    return callback(err5, self3);
                  self3.position = self3.position + bytesRead;
                  self3.currentChunk = chunk2;
                  if (offset >= stats.size) {
                    fs2.close(file, function(err6) {
                      if (err6)
                        return callback(err6);
                      self3.close(function(err7) {
                        if (err7)
                          return callback(err7, self3);
                        return callback(null, self3);
                      });
                    });
                  } else {
                    return process.nextTick(writeChunk);
                  }
                });
              });
            });
          };
          process.nextTick(writeChunk);
        });
      });
    };
    GridStore.prototype.close = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, close, [this, options2, callback], {
        skipSessions: true
      });
    };
    var close = function(self2, options2, callback) {
      if (self2.mode[0] === "w") {
        options2 = Object.assign({}, self2.writeConcern, options2);
        if (self2.currentChunk != null && self2.currentChunk.position > 0) {
          self2.currentChunk.save({}, function(err) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.collection(function(err2, files) {
              if (err2 && typeof callback === "function")
                return callback(err2);
              if (self2.uploadDate != null) {
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              } else {
                self2.uploadDate = new Date();
                buildMongoObject(self2, function(err3, mongoObject) {
                  if (err3) {
                    if (typeof callback === "function")
                      return callback(err3);
                    else
                      throw err3;
                  }
                  files.save(mongoObject, options2, function(err4) {
                    if (typeof callback === "function")
                      callback(err4, mongoObject);
                  });
                });
              }
            });
          });
        } else {
          self2.collection(function(err, files) {
            if (err && typeof callback === "function")
              return callback(err);
            self2.uploadDate = new Date();
            buildMongoObject(self2, function(err2, mongoObject) {
              if (err2) {
                if (typeof callback === "function")
                  return callback(err2);
                else
                  throw err2;
              }
              files.save(mongoObject, options2, function(err3) {
                if (typeof callback === "function")
                  callback(err3, mongoObject);
              });
            });
          });
        }
      } else if (self2.mode[0] === "r") {
        if (typeof callback === "function")
          callback(null, null);
      } else {
        if (typeof callback === "function")
          callback(MongoError.create({ message: f("Illegal mode %s", self2.mode), driver: true }));
      }
    };
    GridStore.prototype.chunkCollection = function(callback) {
      if (typeof callback === "function")
        return this.db.collection(this.root + ".chunks", callback);
      return this.db.collection(this.root + ".chunks");
    };
    GridStore.prototype.unlink = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, unlink, [this, options2, callback], {
        skipSessions: true
      });
    };
    var unlink = function(self2, options2, callback) {
      deleteChunks(self2, function(err) {
        if (err !== null) {
          err.message = "at deleteChunks: " + err.message;
          return callback(err);
        }
        self2.collection(function(err2, collection) {
          if (err2 !== null) {
            err2.message = "at collection: " + err2.message;
            return callback(err2);
          }
          collection.remove({ _id: self2.fileId }, self2.writeConcern, function(err3) {
            callback(err3, self2);
          });
        });
      });
    };
    GridStore.prototype.collection = function(callback) {
      if (typeof callback === "function")
        this.db.collection(this.root + ".files", callback);
      return this.db.collection(this.root + ".files");
    };
    GridStore.prototype.readlines = function(separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : "\n";
      separator = separator || "\n";
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options2, callback], { skipSessions: true });
    };
    var readlines = function(self2, separator, options2, callback) {
      self2.read(function(err, data) {
        if (err)
          return callback(err);
        var items = data.toString().split(separator);
        items = items.length > 0 ? items.splice(0, items.length - 1) : [];
        for (var i = 0; i < items.length; i++) {
          items[i] = items[i] + separator;
        }
        callback(null, items);
      });
    };
    GridStore.prototype.rewind = function(options2, callback) {
      if (typeof options2 === "function")
        callback = options2, options2 = {};
      options2 = options2 || {};
      return executeLegacyOperation(this.db.s.topology, rewind, [this, options2, callback], {
        skipSessions: true
      });
    };
    var rewind = function(self2, options2, callback) {
      if (self2.currentChunk.chunkNumber !== 0) {
        if (self2.mode[0] === "w") {
          deleteChunks(self2, function(err) {
            if (err)
              return callback(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.position = 0;
            callback(null, self2);
          });
        } else {
          self2.currentChunk(0, function(err, chunk) {
            if (err)
              return callback(err);
            self2.currentChunk = chunk;
            self2.currentChunk.rewind();
            self2.position = 0;
            callback(null, self2);
          });
        }
      } else {
        self2.currentChunk.rewind();
        self2.position = 0;
        callback(null, self2);
      }
    };
    GridStore.prototype.read = function(length, buffer2, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      buffer2 = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, read2, [this, length, buffer2, options2, callback], { skipSessions: true });
    };
    var read2 = function(self2, length, buffer2, options2, callback) {
      var finalLength = length == null ? self2.length - self2.position : length;
      var finalBuffer = buffer2 == null ? Buffer2.alloc(finalLength) : buffer2;
      finalBuffer._index = buffer2 != null && buffer2._index != null ? buffer2._index : 0;
      if (self2.currentChunk.length() - self2.currentChunk.position + finalBuffer._index >= finalLength) {
        var slice = self2.currentChunk.readSlice(finalLength - finalBuffer._index);
        slice.copy(finalBuffer, finalBuffer._index);
        self2.position = self2.position + finalBuffer.length;
        if (finalLength === 0 && finalBuffer.length === 0)
          return callback(MongoError.create({ message: "File does not exist", driver: true }), null);
        return callback(null, finalBuffer);
      }
      slice = self2.currentChunk.readSlice(self2.currentChunk.length() - self2.currentChunk.position);
      slice.copy(finalBuffer, finalBuffer._index);
      finalBuffer._index += slice.length;
      nthChunk(self2, self2.currentChunk.chunkNumber + 1, function(err, chunk) {
        if (err)
          return callback(err);
        if (chunk.length() > 0) {
          self2.currentChunk = chunk;
          self2.read(length, finalBuffer, callback);
        } else {
          if (finalBuffer._index > 0) {
            callback(null, finalBuffer);
          } else {
            callback(MongoError.create({
              message: "no chunks found for file, possibly corrupt",
              driver: true
            }), null);
          }
        }
      });
    };
    GridStore.prototype.tell = function(callback) {
      var self2 = this;
      if (typeof callback === "function")
        return callback(null, this.position);
      return new self2.promiseLibrary(function(resolve3) {
        resolve3(self2.position);
      });
    };
    GridStore.prototype.seek = function(position2, seekLocation, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      seekLocation = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      return executeLegacyOperation(this.db.s.topology, seek, [this, position2, seekLocation, options2, callback], { skipSessions: true });
    };
    var seek = function(self2, position2, seekLocation, options2, callback) {
      if (self2.mode !== "r") {
        return callback(MongoError.create({ message: "seek is only supported for mode r", driver: true }));
      }
      var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
      var finalPosition = position2;
      var targetPosition = 0;
      if (seekLocationFinal === GridStore.IO_SEEK_CUR) {
        targetPosition = self2.position + finalPosition;
      } else if (seekLocationFinal === GridStore.IO_SEEK_END) {
        targetPosition = self2.length + finalPosition;
      } else {
        targetPosition = finalPosition;
      }
      var newChunkNumber = Math.floor(targetPosition / self2.chunkSize);
      var seekChunk = function() {
        nthChunk(self2, newChunkNumber, function(err, chunk) {
          if (err)
            return callback(err, null);
          if (chunk == null)
            return callback(new Error("no chunk found"));
          self2.currentChunk = chunk;
          self2.position = targetPosition;
          self2.currentChunk.position = self2.position % self2.chunkSize;
          callback(err, self2);
        });
      };
      seekChunk();
    };
    var _open = function(self2, options2, callback) {
      var collection = self2.collection();
      var query = self2.referenceBy === REFERENCE_BY_ID ? { _id: self2.fileId } : { filename: self2.filename };
      query = self2.fileId == null && self2.filename == null ? null : query;
      options2.readPreference = self2.readPreference;
      if (query != null) {
        collection.findOne(query, options2, function(err, doc) {
          if (err) {
            return error3(err);
          }
          if (doc != null) {
            self2.fileId = doc._id;
            self2.filename = self2.mode === "r" || self2.filename === void 0 ? doc.filename : self2.filename;
            self2.contentType = doc.contentType;
            self2.internalChunkSize = doc.chunkSize;
            self2.uploadDate = doc.uploadDate;
            self2.aliases = doc.aliases;
            self2.length = doc.length;
            self2.metadata = doc.metadata;
            self2.internalMd5 = doc.md5;
          } else if (self2.mode !== "r") {
            self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
            self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
            self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
            self2.length = 0;
          } else {
            self2.length = 0;
            var txtId = self2.fileId._bsontype === "ObjectID" ? self2.fileId.toHexString() : self2.fileId;
            return error3(MongoError.create({
              message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? txtId : self2.filename),
              driver: true
            }), self2);
          }
          if (self2.mode === "r") {
            nthChunk(self2, 0, options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self2.currentChunk = chunk;
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w" && doc) {
            deleteChunks(self2, options2, function(err2) {
              if (err2)
                return error3(err2);
              self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
              self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
              self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = 0;
              callback(null, self2);
            });
          } else if (self2.mode === "w") {
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          } else if (self2.mode === "w+") {
            nthChunk(self2, lastChunkNumber(self2), options2, function(err2, chunk) {
              if (err2)
                return error3(err2);
              self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
              self2.currentChunk.position = self2.currentChunk.data.length();
              self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
              self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
              self2.position = self2.length;
              callback(null, self2);
            });
          }
        });
      } else {
        self2.fileId = self2.fileId == null ? new ObjectID2() : self2.fileId;
        self2.contentType = GridStore.DEFAULT_CONTENT_TYPE;
        self2.internalChunkSize = self2.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self2.internalChunkSize;
        self2.length = 0;
        if (self2.mode === "w") {
          deleteChunks(self2, options2, function(err) {
            if (err)
              return error3(err);
            self2.currentChunk = new Chunk(self2, { n: 0 }, self2.writeConcern);
            self2.contentType = self2.options["content_type"] == null ? self2.contentType : self2.options["content_type"];
            self2.internalChunkSize = self2.options["chunk_size"] == null ? self2.internalChunkSize : self2.options["chunk_size"];
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = 0;
            callback(null, self2);
          });
        } else if (self2.mode === "w+") {
          nthChunk(self2, lastChunkNumber(self2), options2, function(err, chunk) {
            if (err)
              return error3(err);
            self2.currentChunk = chunk == null ? new Chunk(self2, { n: 0 }, self2.writeConcern) : chunk;
            self2.currentChunk.position = self2.currentChunk.data.length();
            self2.metadata = self2.options["metadata"] == null ? self2.metadata : self2.options["metadata"];
            self2.aliases = self2.options["aliases"] == null ? self2.aliases : self2.options["aliases"];
            self2.position = self2.length;
            callback(null, self2);
          });
        }
      }
      function error3(err) {
        if (error3.err)
          return;
        callback(error3.err = err);
      }
    };
    var writeBuffer = function(self2, buffer2, close2, callback) {
      if (typeof close2 === "function") {
        callback = close2;
        close2 = null;
      }
      var finalClose = typeof close2 === "boolean" ? close2 : false;
      if (self2.mode !== "w") {
        callback(MongoError.create({
          message: f("file with id %s not opened for writing", self2.referenceBy === REFERENCE_BY_ID ? self2.referenceBy : self2.filename),
          driver: true
        }), null);
      } else {
        if (self2.currentChunk.position + buffer2.length >= self2.chunkSize) {
          var previousChunkNumber = self2.currentChunk.chunkNumber;
          var leftOverDataSize = self2.chunkSize - self2.currentChunk.position;
          var firstChunkData = buffer2.slice(0, leftOverDataSize);
          var leftOverData = buffer2.slice(leftOverDataSize);
          var chunksToWrite = [self2.currentChunk.write(firstChunkData)];
          while (leftOverData.length >= self2.chunkSize) {
            var newChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
            firstChunkData = leftOverData.slice(0, self2.chunkSize);
            leftOverData = leftOverData.slice(self2.chunkSize);
            previousChunkNumber = previousChunkNumber + 1;
            newChunk.write(firstChunkData);
            chunksToWrite.push(newChunk);
          }
          self2.currentChunk = new Chunk(self2, { n: previousChunkNumber + 1 }, self2.writeConcern);
          if (leftOverData.length > 0)
            self2.currentChunk.write(leftOverData);
          self2.position = self2.position + buffer2.length;
          var numberOfChunksToWrite = chunksToWrite.length;
          for (var i = 0; i < chunksToWrite.length; i++) {
            chunksToWrite[i].save({}, function(err) {
              if (err)
                return callback(err);
              numberOfChunksToWrite = numberOfChunksToWrite - 1;
              if (numberOfChunksToWrite <= 0) {
                if (finalClose) {
                  return self2.close(function(err2) {
                    callback(err2, self2);
                  });
                }
                return callback(null, self2);
              }
            });
          }
        } else {
          self2.position = self2.position + buffer2.length;
          self2.currentChunk.write(buffer2);
          if (finalClose) {
            return self2.close(function(err) {
              callback(err, self2);
            });
          }
          return callback(null, self2);
        }
      }
    };
    var buildMongoObject = function(self2, callback) {
      var mongoObject = {
        _id: self2.fileId,
        filename: self2.filename,
        contentType: self2.contentType,
        length: self2.position ? self2.position : 0,
        chunkSize: self2.chunkSize,
        uploadDate: self2.uploadDate,
        aliases: self2.aliases,
        metadata: self2.metadata
      };
      var md5Command = { filemd5: self2.fileId, root: self2.root };
      self2.db.command(md5Command, function(err, results) {
        if (err)
          return callback(err);
        mongoObject.md5 = results.md5;
        callback(null, mongoObject);
      });
    };
    var nthChunk = function(self2, chunkNumber, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      options2.readPreference = self2.readPreference;
      self2.chunkCollection().findOne({ files_id: self2.fileId, n: chunkNumber }, options2, function(err, chunk) {
        if (err)
          return callback(err);
        var finalChunk = chunk == null ? {} : chunk;
        callback(null, new Chunk(self2, finalChunk, self2.writeConcern));
      });
    };
    var lastChunkNumber = function(self2) {
      return Math.floor((self2.length ? self2.length - 1 : 0) / self2.chunkSize);
    };
    var deleteChunks = function(self2, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      options2 = options2 || self2.writeConcern;
      if (self2.fileId != null) {
        self2.chunkCollection().remove({ files_id: self2.fileId }, options2, function(err) {
          if (err)
            return callback(err, false);
          callback(null, true);
        });
      } else {
        callback(null, true);
      }
    };
    GridStore.DEFAULT_ROOT_COLLECTION = "fs";
    GridStore.DEFAULT_CONTENT_TYPE = "binary/octet-stream";
    GridStore.IO_SEEK_SET = 0;
    GridStore.IO_SEEK_CUR = 1;
    GridStore.IO_SEEK_END = 2;
    GridStore.exist = function(db, fileIdObject, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options2, callback], { skipSessions: true });
    };
    var exists = function(db, fileIdObject, rootCollection, options2, callback) {
      var readPreference = options2.readPreference || ReadPreference.PRIMARY;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        var query = typeof fileIdObject === "string" || Object.prototype.toString.call(fileIdObject) === "[object RegExp]" ? { filename: fileIdObject } : { _id: fileIdObject };
        if (fileIdObject != null && typeof fileIdObject === "object" && Object.prototype.toString.call(fileIdObject) !== "[object RegExp]") {
          query = fileIdObject;
        }
        collection.findOne(query, { readPreference }, function(err2, item) {
          if (err2)
            return callback(err2);
          callback(null, item == null ? false : true);
        });
      });
    };
    GridStore.list = function(db, rootCollection, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 1);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      rootCollection = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, list2, [db, rootCollection, options2, callback], {
        skipSessions: true
      });
    };
    var list2 = function(db, rootCollection, options2, callback) {
      if (rootCollection != null && typeof rootCollection === "object") {
        options2 = rootCollection;
        rootCollection = null;
      }
      var readPreference = options2.readPreference || ReadPreference.primary;
      var byId = options2["id"] != null ? options2["id"] : false;
      var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
      var items = [];
      db.collection(rootCollectionFinal + ".files", function(err, collection) {
        if (err)
          return callback(err);
        collection.find({}, { readPreference }, function(err2, cursor) {
          if (err2)
            return callback(err2);
          cursor.each(function(err3, item) {
            if (item != null) {
              items.push(byId ? item._id : item.filename);
            } else {
              callback(err3, items);
            }
          });
        });
      });
    };
    GridStore.read = function(db, name2, length, offset, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      length = args.length ? args.shift() : null;
      offset = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readStatic, [db, name2, length, offset, options2, callback], { skipSessions: true });
    };
    var readStatic = function(db, name2, length, offset, options2, callback) {
      new GridStore(db, name2, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        if (offset && offset >= gridStore.length)
          return callback("offset larger than size of file", null);
        if (length && length > gridStore.length)
          return callback("length is larger than the size of the file", null);
        if (offset && length && offset + length > gridStore.length)
          return callback("offset and length is larger than the size of the file", null);
        if (offset != null) {
          gridStore.seek(offset, function(err2, gridStore2) {
            if (err2)
              return callback(err2);
            gridStore2.read(length, callback);
          });
        } else {
          gridStore.read(length, callback);
        }
      });
    };
    GridStore.readlines = function(db, name2, separator, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      separator = args.length ? args.shift() : null;
      options2 = args.length ? args.shift() : null;
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name2, separator, options2, callback], { skipSessions: true });
    };
    var readlinesStatic = function(db, name2, separator, options2, callback) {
      var finalSeperator = separator == null ? "\n" : separator;
      new GridStore(db, name2, "r", options2).open(function(err, gridStore) {
        if (err)
          return callback(err);
        gridStore.readlines(finalSeperator, callback);
      });
    };
    GridStore.unlink = function(db, names, options2, callback) {
      var args = Array.prototype.slice.call(arguments, 2);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      options2 = args.length ? args.shift() : {};
      options2 = options2 || {};
      return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options2, callback], {
        skipSessions: true
      });
    };
    var unlinkStatic = function(self2, db, names, options2, callback) {
      var writeConcern = _getWriteConcern(db, options2);
      if (names.constructor === Array) {
        var tc = 0;
        for (var i = 0; i < names.length; i++) {
          ++tc;
          GridStore.unlink(db, names[i], options2, function() {
            if (--tc === 0) {
              callback(null, self2);
            }
          });
        }
      } else {
        new GridStore(db, names, "w", options2).open(function(err, gridStore) {
          if (err)
            return callback(err);
          deleteChunks(gridStore, function(err2) {
            if (err2)
              return callback(err2);
            gridStore.collection(function(err3, collection) {
              if (err3)
                return callback(err3);
              collection.remove({ _id: gridStore.fileId }, writeConcern, function(err4) {
                callback(err4, self2);
              });
            });
          });
        });
      }
    };
    var _writeNormal = function(self2, data, close2, options2, callback) {
      if (Buffer2.isBuffer(data)) {
        return writeBuffer(self2, data, close2, callback);
      } else {
        return writeBuffer(self2, Buffer2.from(data, "binary"), close2, callback);
      }
    };
    var _setWriteConcernHash = function(options2) {
      const baseOptions = Object.assign(options2, options2.writeConcern);
      var finalOptions = {};
      if (baseOptions.w != null)
        finalOptions.w = baseOptions.w;
      if (baseOptions.journal === true)
        finalOptions.j = baseOptions.journal;
      if (baseOptions.j === true)
        finalOptions.j = baseOptions.j;
      if (baseOptions.fsync === true)
        finalOptions.fsync = baseOptions.fsync;
      if (baseOptions.wtimeout != null)
        finalOptions.wtimeout = baseOptions.wtimeout;
      return finalOptions;
    };
    var _getWriteConcern = function(self2, options2) {
      var finalOptions = { w: 1 };
      options2 = options2 || {};
      if (options2.writeConcern != null || options2.w != null || typeof options2.j === "boolean" || typeof options2.journal === "boolean" || typeof options2.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(options2);
      } else if (options2.safe != null && typeof options2.safe === "object") {
        finalOptions = _setWriteConcernHash(options2.safe);
      } else if (typeof options2.safe === "boolean") {
        finalOptions = { w: options2.safe ? 1 : 0 };
      } else if (self2.options.writeConcern != null || self2.options.w != null || typeof self2.options.j === "boolean" || typeof self2.options.journal === "boolean" || typeof self2.options.fsync === "boolean") {
        finalOptions = _setWriteConcernHash(self2.options);
      } else if (self2.safe && (self2.safe.w != null || typeof self2.safe.j === "boolean" || typeof self2.safe.journal === "boolean" || typeof self2.safe.fsync === "boolean")) {
        finalOptions = _setWriteConcernHash(self2.safe);
      } else if (typeof self2.safe === "boolean") {
        finalOptions = { w: self2.safe ? 1 : 0 };
      }
      if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true))
        throw MongoError.create({
          message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true",
          driver: true
        });
      return finalOptions;
    };
    var GridStoreStream = function(gs) {
      Duplex.call(this);
      this.gs = gs;
      this.endCalled = false;
      this.totalBytesToRead = this.gs.length - this.gs.position;
      this.seekPosition = this.gs.position;
    };
    inherits(GridStoreStream, Duplex);
    GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
    GridStoreStream.prototype.pipe = function(destination) {
      var self2 = this;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          if (err)
            return self2.emit("error", err);
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          self2._pipe.apply(self2, [destination]);
        });
      } else {
        self2.totalBytesToRead = self2.gs.length - self2.gs.position;
        self2._pipe.apply(self2, [destination]);
      }
      return destination;
    };
    GridStoreStream.prototype._read = function() {
      var self2 = this;
      var read3 = function() {
        self2.gs.read(length, function(err, buffer2) {
          if (err && !self2.endCalled)
            return self2.emit("error", err);
          if (self2.endCalled || buffer2 == null)
            return self2.push(null);
          if (buffer2.length <= self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer2.length;
            self2.push(buffer2);
          } else if (buffer2.length > self2.totalBytesToRead) {
            self2.totalBytesToRead = self2.totalBytesToRead - buffer2._index;
            self2.push(buffer2.slice(0, buffer2._index));
          }
          if (self2.totalBytesToRead <= 0) {
            self2.endCalled = true;
          }
        });
      };
      var length = self2.gs.length < self2.gs.chunkSize ? self2.gs.length - self2.seekPosition : self2.gs.chunkSize;
      if (!self2.gs.isOpen) {
        self2.gs.open(function(err) {
          self2.totalBytesToRead = self2.gs.length - self2.gs.position;
          if (err)
            return self2.emit("error", err);
          read3();
        });
      } else {
        read3();
      }
    };
    GridStoreStream.prototype.destroy = function() {
      this.pause();
      this.endCalled = true;
      this.gs.close();
      this.emit("end");
    };
    GridStoreStream.prototype.write = function(chunk) {
      var self2 = this;
      if (self2.endCalled)
        return self2.emit("error", MongoError.create({ message: "attempting to write to stream after end called", driver: true }));
      if (!self2.gs.isOpen) {
        self2.gs.open(function() {
          self2.gs.isOpen = true;
          self2.gs.write(chunk, function() {
            process.nextTick(function() {
              self2.emit("drain");
            });
          });
        });
        return false;
      } else {
        self2.gs.write(chunk, function() {
          self2.emit("drain");
        });
        return true;
      }
    };
    GridStoreStream.prototype.end = function(chunk, encoding3, callback) {
      var self2 = this;
      var args = Array.prototype.slice.call(arguments, 0);
      callback = typeof args[args.length - 1] === "function" ? args.pop() : void 0;
      chunk = args.length ? args.shift() : null;
      encoding3 = args.length ? args.shift() : null;
      self2.endCalled = true;
      if (chunk) {
        self2.gs.write(chunk, function() {
          self2.gs.close(function() {
            if (typeof callback === "function")
              callback();
            self2.emit("end");
          });
        });
      }
      self2.gs.close(function() {
        if (typeof callback === "function")
          callback();
        self2.emit("end");
      });
    };
    module2.exports = GridStore;
  }
});

// node_modules/mongodb/lib/gridfs-stream/download.js
var require_download = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/download.js"(exports2, module2) {
    init_shims();
    "use strict";
    var stream = __require("stream");
    var util2 = __require("util");
    module2.exports = GridFSBucketReadStream;
    function GridFSBucketReadStream(chunks, files, readPreference, filter2, options2) {
      this.s = {
        bytesRead: 0,
        chunks,
        cursor: null,
        expected: 0,
        files,
        filter: filter2,
        init: false,
        expectedEnd: 0,
        file: null,
        options: options2,
        readPreference
      };
      stream.Readable.call(this);
    }
    util2.inherits(GridFSBucketReadStream, stream.Readable);
    GridFSBucketReadStream.prototype._read = function() {
      var _this = this;
      if (this.destroyed) {
        return;
      }
      waitForFile(_this, function() {
        doRead(_this);
      });
    };
    GridFSBucketReadStream.prototype.start = function(start) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    };
    GridFSBucketReadStream.prototype.end = function(end) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    };
    GridFSBucketReadStream.prototype.abort = function(callback) {
      var _this = this;
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        this.s.cursor.close(function(error3) {
          _this.emit("close");
          callback && callback(error3);
        });
      } else {
        if (!this.s.init) {
          _this.emit("close");
        }
        callback && callback();
      }
    };
    function throwIfInitialized(self2) {
      if (self2.s.init) {
        throw new Error("You cannot change options after the stream has enteredflowing mode!");
      }
    }
    function doRead(_this) {
      if (_this.destroyed) {
        return;
      }
      _this.s.cursor.next(function(error3, doc) {
        if (_this.destroyed) {
          return;
        }
        if (error3) {
          return __handleError(_this, error3);
        }
        if (!doc) {
          _this.push(null);
          process.nextTick(() => {
            _this.s.cursor.close(function(error4) {
              if (error4) {
                __handleError(_this, error4);
                return;
              }
              _this.emit("close");
            });
          });
          return;
        }
        var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
        var expectedN = _this.s.expected++;
        var expectedLength = Math.min(_this.s.file.chunkSize, bytesRemaining);
        if (doc.n > expectedN) {
          var errmsg = "ChunkIsMissing: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        if (doc.n < expectedN) {
          errmsg = "ExtraChunk: Got unexpected n: " + doc.n + ", expected: " + expectedN;
          return __handleError(_this, new Error(errmsg));
        }
        var buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
        if (buf.length !== expectedLength) {
          if (bytesRemaining <= 0) {
            errmsg = "ExtraChunk: Got unexpected n: " + doc.n;
            return __handleError(_this, new Error(errmsg));
          }
          errmsg = "ChunkIsWrongSize: Got unexpected length: " + buf.length + ", expected: " + expectedLength;
          return __handleError(_this, new Error(errmsg));
        }
        _this.s.bytesRead += buf.length;
        if (buf.length === 0) {
          return _this.push(null);
        }
        var sliceStart = null;
        var sliceEnd = null;
        if (_this.s.bytesToSkip != null) {
          sliceStart = _this.s.bytesToSkip;
          _this.s.bytesToSkip = 0;
        }
        const atEndOfStream = expectedN === _this.s.expectedEnd - 1;
        const bytesLeftToRead = _this.s.options.end - _this.s.bytesToSkip;
        if (atEndOfStream && _this.s.bytesToTrim != null) {
          sliceEnd = _this.s.file.chunkSize - _this.s.bytesToTrim;
        } else if (_this.s.options.end && bytesLeftToRead < doc.data.length()) {
          sliceEnd = bytesLeftToRead;
        }
        if (sliceStart != null || sliceEnd != null) {
          buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
        }
        _this.push(buf);
      });
    }
    function init2(self2) {
      var findOneOptions = {};
      if (self2.s.readPreference) {
        findOneOptions.readPreference = self2.s.readPreference;
      }
      if (self2.s.options && self2.s.options.sort) {
        findOneOptions.sort = self2.s.options.sort;
      }
      if (self2.s.options && self2.s.options.skip) {
        findOneOptions.skip = self2.s.options.skip;
      }
      self2.s.files.findOne(self2.s.filter, findOneOptions, function(error3, doc) {
        if (error3) {
          return __handleError(self2, error3);
        }
        if (!doc) {
          var identifier = self2.s.filter._id ? self2.s.filter._id.toString() : self2.s.filter.filename;
          var errmsg = "FileNotFound: file " + identifier + " was not found";
          var err = new Error(errmsg);
          err.code = "ENOENT";
          return __handleError(self2, err);
        }
        if (doc.length <= 0) {
          self2.push(null);
          return;
        }
        if (self2.destroyed) {
          self2.emit("close");
          return;
        }
        try {
          self2.s.bytesToSkip = handleStartOption(self2, doc, self2.s.options);
        } catch (error4) {
          return __handleError(self2, error4);
        }
        var filter2 = { files_id: doc._id };
        if (self2.s.options && self2.s.options.start != null) {
          var skip = Math.floor(self2.s.options.start / doc.chunkSize);
          if (skip > 0) {
            filter2["n"] = { $gte: skip };
          }
        }
        self2.s.cursor = self2.s.chunks.find(filter2).sort({ n: 1 });
        if (self2.s.readPreference) {
          self2.s.cursor.setReadPreference(self2.s.readPreference);
        }
        self2.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
        self2.s.file = doc;
        try {
          self2.s.bytesToTrim = handleEndOption(self2, doc, self2.s.cursor, self2.s.options);
        } catch (error4) {
          return __handleError(self2, error4);
        }
        self2.emit("file", doc);
      });
    }
    function waitForFile(_this, callback) {
      if (_this.s.file) {
        return callback();
      }
      if (!_this.s.init) {
        init2(_this);
        _this.s.init = true;
      }
      _this.once("file", function() {
        callback();
      });
    }
    function handleStartOption(stream2, doc, options2) {
      if (options2 && options2.start != null) {
        if (options2.start > doc.length) {
          throw new Error("Stream start (" + options2.start + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream start (" + options2.start + ") must not be negative");
        }
        if (options2.end != null && options2.end < options2.start) {
          throw new Error("Stream start (" + options2.start + ") must not be greater than stream end (" + options2.end + ")");
        }
        stream2.s.bytesRead = Math.floor(options2.start / doc.chunkSize) * doc.chunkSize;
        stream2.s.expected = Math.floor(options2.start / doc.chunkSize);
        return options2.start - stream2.s.bytesRead;
      }
    }
    function handleEndOption(stream2, doc, cursor, options2) {
      if (options2 && options2.end != null) {
        if (options2.end > doc.length) {
          throw new Error("Stream end (" + options2.end + ") must not be more than the length of the file (" + doc.length + ")");
        }
        if (options2.start < 0) {
          throw new Error("Stream end (" + options2.end + ") must not be negative");
        }
        var start = options2.start != null ? Math.floor(options2.start / doc.chunkSize) : 0;
        cursor.limit(Math.ceil(options2.end / doc.chunkSize) - start);
        stream2.s.expectedEnd = Math.ceil(options2.end / doc.chunkSize);
        return Math.ceil(options2.end / doc.chunkSize) * doc.chunkSize - options2.end;
      }
    }
    function __handleError(_this, error3) {
      _this.emit("error", error3);
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/upload.js
var require_upload = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/upload.js"(exports2, module2) {
    init_shims();
    "use strict";
    var core = require_core();
    var crypto = __require("crypto");
    var stream = __require("stream");
    var util2 = __require("util");
    var Buffer2 = require_safe_buffer().Buffer;
    var ERROR_NAMESPACE_NOT_FOUND = 26;
    module2.exports = GridFSBucketWriteStream;
    function GridFSBucketWriteStream(bucket, filename, options2) {
      options2 = options2 || {};
      stream.Writable.call(this, options2);
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options2;
      this.done = false;
      this.id = options2.id ? options2.id : core.BSON.ObjectId();
      this.chunkSizeBytes = this.options.chunkSizeBytes;
      this.bufToStore = Buffer2.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.md5 = !options2.disableMD5 && crypto.createHash("md5");
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false,
        promiseLibrary: this.bucket.s.promiseLibrary
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        var _this = this;
        checkIndexes(this, function() {
          _this.bucket.s.checkedIndexes = true;
          _this.bucket.emit("index");
        });
      }
    }
    util2.inherits(GridFSBucketWriteStream, stream.Writable);
    GridFSBucketWriteStream.prototype.write = function(chunk, encoding3, callback) {
      var _this = this;
      return waitForIndexes(this, function() {
        return doWrite(_this, chunk, encoding3, callback);
      });
    };
    GridFSBucketWriteStream.prototype.abort = function(callback) {
      if (this.state.streamEnd) {
        var error3 = new Error("Cannot abort a stream that has already completed");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      if (this.state.aborted) {
        error3 = new Error("Cannot call abort() on a stream twice");
        if (typeof callback === "function") {
          return callback(error3);
        }
        return this.state.promiseLibrary.reject(error3);
      }
      this.state.aborted = true;
      this.chunks.deleteMany({ files_id: this.id }, function(error4) {
        if (typeof callback === "function")
          callback(error4);
      });
    };
    GridFSBucketWriteStream.prototype.end = function(chunk, encoding3, callback) {
      var _this = this;
      if (typeof chunk === "function") {
        callback = chunk, chunk = null, encoding3 = null;
      } else if (typeof encoding3 === "function") {
        callback = encoding3, encoding3 = null;
      }
      if (checkAborted(this, callback)) {
        return;
      }
      this.state.streamEnd = true;
      if (callback) {
        this.once("finish", function(result) {
          callback(null, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, function() {
          writeRemnant(_this);
        });
        return;
      }
      this.write(chunk, encoding3, function() {
        writeRemnant(_this);
      });
    };
    function __handleError(_this, error3, callback) {
      if (_this.state.errored) {
        return;
      }
      _this.state.errored = true;
      if (callback) {
        return callback(error3);
      }
      _this.emit("error", error3);
    }
    function createChunkDoc(filesId, n, data) {
      return {
        _id: core.BSON.ObjectId(),
        files_id: filesId,
        n,
        data
      };
    }
    function checkChunksIndex(_this, callback) {
      _this.chunks.listIndexes().toArray(function(error3, indexes) {
        if (error3) {
          if (error3.code === ERROR_NAMESPACE_NOT_FOUND) {
            var index2 = { files_id: 1, n: 1 };
            _this.chunks.createIndex(index2, { background: false, unique: true }, function(error4) {
              if (error4) {
                return callback(error4);
              }
              callback();
            });
            return;
          }
          return callback(error3);
        }
        var hasChunksIndex = false;
        indexes.forEach(function(index3) {
          if (index3.key) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.files_id === 1 && index3.key.n === 1) {
              hasChunksIndex = true;
            }
          }
        });
        if (hasChunksIndex) {
          callback();
        } else {
          index2 = { files_id: 1, n: 1 };
          var indexOptions = getWriteOptions(_this);
          indexOptions.background = false;
          indexOptions.unique = true;
          _this.chunks.createIndex(index2, indexOptions, function(error4) {
            if (error4) {
              return callback(error4);
            }
            callback();
          });
        }
      });
    }
    function checkDone(_this, callback) {
      if (_this.done)
        return true;
      if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {
        _this.done = true;
        var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest("hex"), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);
        if (checkAborted(_this, callback)) {
          return false;
        }
        _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error3) {
          if (error3) {
            return __handleError(_this, error3, callback);
          }
          _this.emit("finish", filesDoc);
          _this.emit("close");
        });
        return true;
      }
      return false;
    }
    function checkIndexes(_this, callback) {
      _this.files.findOne({}, { _id: 1 }, function(error3, doc) {
        if (error3) {
          return callback(error3);
        }
        if (doc) {
          return callback();
        }
        _this.files.listIndexes().toArray(function(error4, indexes) {
          if (error4) {
            if (error4.code === ERROR_NAMESPACE_NOT_FOUND) {
              var index2 = { filename: 1, uploadDate: 1 };
              _this.files.createIndex(index2, { background: false }, function(error5) {
                if (error5) {
                  return callback(error5);
                }
                checkChunksIndex(_this, callback);
              });
              return;
            }
            return callback(error4);
          }
          var hasFileIndex = false;
          indexes.forEach(function(index3) {
            var keys = Object.keys(index3.key);
            if (keys.length === 2 && index3.key.filename === 1 && index3.key.uploadDate === 1) {
              hasFileIndex = true;
            }
          });
          if (hasFileIndex) {
            checkChunksIndex(_this, callback);
          } else {
            index2 = { filename: 1, uploadDate: 1 };
            var indexOptions = getWriteOptions(_this);
            indexOptions.background = false;
            _this.files.createIndex(index2, indexOptions, function(error5) {
              if (error5) {
                return callback(error5);
              }
              checkChunksIndex(_this, callback);
            });
          }
        });
      });
    }
    function createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {
      var ret = {
        _id,
        length,
        chunkSize,
        uploadDate: new Date(),
        filename
      };
      if (md5) {
        ret.md5 = md5;
      }
      if (contentType) {
        ret.contentType = contentType;
      }
      if (aliases) {
        ret.aliases = aliases;
      }
      if (metadata) {
        ret.metadata = metadata;
      }
      return ret;
    }
    function doWrite(_this, chunk, encoding3, callback) {
      if (checkAborted(_this, callback)) {
        return false;
      }
      var inputBuf = Buffer2.isBuffer(chunk) ? chunk : Buffer2.from(chunk, encoding3);
      _this.length += inputBuf.length;
      if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
        inputBuf.copy(_this.bufToStore, _this.pos);
        _this.pos += inputBuf.length;
        callback && callback();
        return true;
      }
      var inputBufRemaining = inputBuf.length;
      var spaceRemaining = _this.chunkSizeBytes - _this.pos;
      var numToCopy = Math.min(spaceRemaining, inputBuf.length);
      var outstandingRequests = 0;
      while (inputBufRemaining > 0) {
        var inputBufPos = inputBuf.length - inputBufRemaining;
        inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);
        _this.pos += numToCopy;
        spaceRemaining -= numToCopy;
        if (spaceRemaining === 0) {
          if (_this.md5) {
            _this.md5.update(_this.bufToStore);
          }
          var doc = createChunkDoc(_this.id, _this.n, Buffer2.from(_this.bufToStore));
          ++_this.state.outstandingRequests;
          ++outstandingRequests;
          if (checkAborted(_this, callback)) {
            return false;
          }
          _this.chunks.insertOne(doc, getWriteOptions(_this), function(error3) {
            if (error3) {
              return __handleError(_this, error3);
            }
            --_this.state.outstandingRequests;
            --outstandingRequests;
            if (!outstandingRequests) {
              _this.emit("drain", doc);
              callback && callback();
              checkDone(_this);
            }
          });
          spaceRemaining = _this.chunkSizeBytes;
          _this.pos = 0;
          ++_this.n;
        }
        inputBufRemaining -= numToCopy;
        numToCopy = Math.min(spaceRemaining, inputBufRemaining);
      }
      return false;
    }
    function getWriteOptions(_this) {
      var obj = {};
      if (_this.options.writeConcern) {
        obj.w = _this.options.writeConcern.w;
        obj.wtimeout = _this.options.writeConcern.wtimeout;
        obj.j = _this.options.writeConcern.j;
      }
      return obj;
    }
    function waitForIndexes(_this, callback) {
      if (_this.bucket.s.checkedIndexes) {
        return callback(false);
      }
      _this.bucket.once("index", function() {
        callback(true);
      });
      return true;
    }
    function writeRemnant(_this, callback) {
      if (_this.pos === 0) {
        return checkDone(_this, callback);
      }
      ++_this.state.outstandingRequests;
      var remnant = Buffer2.alloc(_this.pos);
      _this.bufToStore.copy(remnant, 0, 0, _this.pos);
      if (_this.md5) {
        _this.md5.update(remnant);
      }
      var doc = createChunkDoc(_this.id, _this.n, remnant);
      if (checkAborted(_this, callback)) {
        return false;
      }
      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error3) {
        if (error3) {
          return __handleError(_this, error3);
        }
        --_this.state.outstandingRequests;
        checkDone(_this);
      });
    }
    function checkAborted(_this, callback) {
      if (_this.state.aborted) {
        if (typeof callback === "function") {
          callback(new Error("this stream has been aborted"));
        }
        return true;
      }
      return false;
    }
  }
});

// node_modules/mongodb/lib/gridfs-stream/index.js
var require_gridfs_stream = __commonJS({
  "node_modules/mongodb/lib/gridfs-stream/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Emitter = __require("events").EventEmitter;
    var GridFSBucketReadStream = require_download();
    var GridFSBucketWriteStream = require_upload();
    var shallowClone = require_utils4().shallowClone;
    var toError = require_utils4().toError;
    var util2 = __require("util");
    var executeLegacyOperation = require_utils4().executeLegacyOperation;
    var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
      bucketName: "fs",
      chunkSizeBytes: 255 * 1024
    };
    module2.exports = GridFSBucket;
    function GridFSBucket(db, options2) {
      Emitter.apply(this);
      this.setMaxListeners(0);
      if (options2 && typeof options2 === "object") {
        options2 = shallowClone(options2);
        var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
        for (var i = 0; i < keys.length; ++i) {
          if (!options2[keys[i]]) {
            options2[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
          }
        }
      } else {
        options2 = DEFAULT_GRIDFS_BUCKET_OPTIONS;
      }
      this.s = {
        db,
        options: options2,
        _chunksCollection: db.collection(options2.bucketName + ".chunks"),
        _filesCollection: db.collection(options2.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false,
        promiseLibrary: db.s.promiseLibrary || Promise
      };
    }
    util2.inherits(GridFSBucket, Emitter);
    GridFSBucket.prototype.openUploadStream = function(filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options2) {
      if (options2) {
        options2 = shallowClone(options2);
      } else {
        options2 = {};
      }
      if (!options2.chunkSizeBytes) {
        options2.chunkSizeBytes = this.s.options.chunkSizeBytes;
      }
      options2.id = id;
      return new GridFSBucketWriteStream(this, filename, options2);
    };
    GridFSBucket.prototype.openDownloadStream = function(id, options2) {
      var filter2 = { _id: id };
      options2 = {
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter2, options2);
    };
    GridFSBucket.prototype.delete = function(id, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {
        skipSessions: true
      });
    };
    function _delete(_this, id, callback) {
      _this.s._filesCollection.deleteOne({ _id: id }, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.deleteMany({ files_id: id }, function(error4) {
          if (error4) {
            return callback(error4);
          }
          if (!res.result.n) {
            var errmsg = "FileNotFound: no file with id " + id + " found";
            return callback(new Error(errmsg));
          }
          callback();
        });
      });
    }
    GridFSBucket.prototype.find = function(filter2, options2) {
      filter2 = filter2 || {};
      options2 = options2 || {};
      var cursor = this.s._filesCollection.find(filter2);
      if (options2.batchSize != null) {
        cursor.batchSize(options2.batchSize);
      }
      if (options2.limit != null) {
        cursor.limit(options2.limit);
      }
      if (options2.maxTimeMS != null) {
        cursor.maxTimeMS(options2.maxTimeMS);
      }
      if (options2.noCursorTimeout != null) {
        cursor.addCursorFlag("noCursorTimeout", options2.noCursorTimeout);
      }
      if (options2.skip != null) {
        cursor.skip(options2.skip);
      }
      if (options2.sort != null) {
        cursor.sort(options2.sort);
      }
      return cursor;
    };
    GridFSBucket.prototype.openDownloadStreamByName = function(filename, options2) {
      var sort = { uploadDate: -1 };
      var skip = null;
      if (options2 && options2.revision != null) {
        if (options2.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options2.revision;
        } else {
          skip = -options2.revision - 1;
        }
      }
      var filter2 = { filename };
      options2 = {
        sort,
        skip,
        start: options2 && options2.start,
        end: options2 && options2.end
      };
      return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter2, options2);
    };
    GridFSBucket.prototype.rename = function(id, filename, callback) {
      return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {
        skipSessions: true
      });
    };
    function _rename(_this, id, filename, callback) {
      var filter2 = { _id: id };
      var update2 = { $set: { filename } };
      _this.s._filesCollection.updateOne(filter2, update2, function(error3, res) {
        if (error3) {
          return callback(error3);
        }
        if (!res.result.n) {
          return callback(toError("File with id " + id + " not found"));
        }
        callback();
      });
    }
    GridFSBucket.prototype.drop = function(callback) {
      return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {
        skipSessions: true
      });
    };
    GridFSBucket.prototype.getLogger = function() {
      return this.s.db.s.logger;
    };
    function _drop(_this, callback) {
      _this.s._filesCollection.drop(function(error3) {
        if (error3) {
          return callback(error3);
        }
        _this.s._chunksCollection.drop(function(error4) {
          if (error4) {
            return callback(error4);
          }
          return callback();
        });
      });
    }
  }
});

// node_modules/mongodb/index.js
var require_mongodb = __commonJS({
  "node_modules/mongodb/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var core = require_core();
    var Instrumentation = require_apm2();
    var connect2 = require_mongo_client().connect;
    connect2.MongoError = core.MongoError;
    connect2.MongoNetworkError = core.MongoNetworkError;
    connect2.MongoTimeoutError = core.MongoTimeoutError;
    connect2.MongoServerSelectionError = core.MongoServerSelectionError;
    connect2.MongoParseError = core.MongoParseError;
    connect2.MongoWriteConcernError = core.MongoWriteConcernError;
    connect2.MongoBulkWriteError = require_common2().BulkWriteError;
    connect2.BulkWriteError = connect2.MongoBulkWriteError;
    connect2.Admin = require_admin();
    connect2.MongoClient = require_mongo_client();
    connect2.Db = require_db();
    connect2.Collection = require_collection();
    connect2.Server = require_server3();
    connect2.ReplSet = require_replset2();
    connect2.Mongos = require_mongos2();
    connect2.ReadPreference = core.ReadPreference;
    connect2.GridStore = require_grid_store();
    connect2.Chunk = require_chunk();
    connect2.Logger = core.Logger;
    connect2.AggregationCursor = require_aggregation_cursor();
    connect2.CommandCursor = require_command_cursor();
    connect2.Cursor = require_cursor2();
    connect2.GridFSBucket = require_gridfs_stream();
    connect2.CoreServer = core.Server;
    connect2.CoreConnection = core.Connection;
    connect2.Binary = core.BSON.Binary;
    connect2.Code = core.BSON.Code;
    connect2.Map = core.BSON.Map;
    connect2.DBRef = core.BSON.DBRef;
    connect2.Double = core.BSON.Double;
    connect2.Int32 = core.BSON.Int32;
    connect2.Long = core.BSON.Long;
    connect2.MinKey = core.BSON.MinKey;
    connect2.MaxKey = core.BSON.MaxKey;
    connect2.ObjectID = core.BSON.ObjectID;
    connect2.ObjectId = core.BSON.ObjectID;
    connect2.Symbol = core.BSON.Symbol;
    connect2.Timestamp = core.BSON.Timestamp;
    connect2.BSONRegExp = core.BSON.BSONRegExp;
    connect2.Decimal128 = core.BSON.Decimal128;
    connect2.connect = connect2;
    connect2.instrument = function(options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      const instrumentation = new Instrumentation();
      instrumentation.instrument(connect2.MongoClient, callback);
      return instrumentation;
    };
    module2.exports = connect2;
  }
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS({
  "node_modules/bcryptjs/dist/bcrypt.js"(exports2, module2) {
    init_shims();
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2["exports"])
        module2["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
    })(exports2, function() {
      "use strict";
      var bcrypt2 = {};
      var randomFallback = null;
      function random(len) {
        if (typeof module2 !== "undefined" && module2 && module2["exports"])
          try {
            return __require("crypto")["randomBytes"](len);
          } catch (e) {
          }
        try {
          var a;
          (self["crypto"] || self["msCrypto"])["getRandomValues"](a = new Uint32Array(len));
          return Array.prototype.slice.call(a);
        } catch (e) {
        }
        if (!randomFallback)
          throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
        return randomFallback(len);
      }
      var randomAvailable = false;
      try {
        random(1);
        randomAvailable = true;
      } catch (e) {
      }
      randomFallback = null;
      bcrypt2.setRandomFallback = function(random2) {
        randomFallback = random2;
      };
      bcrypt2.genSaltSync = function(rounds, seed_length) {
        rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof rounds !== "number")
          throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
        if (rounds < 4)
          rounds = 4;
        else if (rounds > 31)
          rounds = 31;
        var salt = [];
        salt.push("$2a$");
        if (rounds < 10)
          salt.push("0");
        salt.push(rounds.toString());
        salt.push("$");
        salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
        return salt.join("");
      };
      bcrypt2.genSalt = function(rounds, seed_length, callback) {
        if (typeof seed_length === "function")
          callback = seed_length, seed_length = void 0;
        if (typeof rounds === "function")
          callback = rounds, rounds = void 0;
        if (typeof rounds === "undefined")
          rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
        else if (typeof rounds !== "number")
          throw Error("illegal arguments: " + typeof rounds);
        function _async(callback2) {
          nextTick(function() {
            try {
              callback2(null, bcrypt2.genSaltSync(rounds));
            } catch (err) {
              callback2(err);
            }
          });
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve3, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve3(res);
            });
          });
      };
      bcrypt2.hashSync = function(s3, salt) {
        if (typeof salt === "undefined")
          salt = GENSALT_DEFAULT_LOG2_ROUNDS;
        if (typeof salt === "number")
          salt = bcrypt2.genSaltSync(salt);
        if (typeof s3 !== "string" || typeof salt !== "string")
          throw Error("Illegal arguments: " + typeof s3 + ", " + typeof salt);
        return _hash(s3, salt);
      };
      bcrypt2.hash = function(s3, salt, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s3 === "string" && typeof salt === "number")
            bcrypt2.genSalt(salt, function(err, salt2) {
              _hash(s3, salt2, callback2, progressCallback);
            });
          else if (typeof s3 === "string" && typeof salt === "string")
            _hash(s3, salt, callback2, progressCallback);
          else
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s3 + ", " + typeof salt)));
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve3, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve3(res);
            });
          });
      };
      function safeStringCompare(known, unknown) {
        var right = 0, wrong = 0;
        for (var i = 0, k = known.length; i < k; ++i) {
          if (known.charCodeAt(i) === unknown.charCodeAt(i))
            ++right;
          else
            ++wrong;
        }
        if (right < 0)
          return false;
        return wrong === 0;
      }
      bcrypt2.compareSync = function(s3, hash2) {
        if (typeof s3 !== "string" || typeof hash2 !== "string")
          throw Error("Illegal arguments: " + typeof s3 + ", " + typeof hash2);
        if (hash2.length !== 60)
          return false;
        return safeStringCompare(bcrypt2.hashSync(s3, hash2.substr(0, hash2.length - 31)), hash2);
      };
      bcrypt2.compare = function(s3, hash2, callback, progressCallback) {
        function _async(callback2) {
          if (typeof s3 !== "string" || typeof hash2 !== "string") {
            nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s3 + ", " + typeof hash2)));
            return;
          }
          if (hash2.length !== 60) {
            nextTick(callback2.bind(this, null, false));
            return;
          }
          bcrypt2.hash(s3, hash2.substr(0, 29), function(err, comp) {
            if (err)
              callback2(err);
            else
              callback2(null, safeStringCompare(comp, hash2));
          }, progressCallback);
        }
        if (callback) {
          if (typeof callback !== "function")
            throw Error("Illegal callback: " + typeof callback);
          _async(callback);
        } else
          return new Promise(function(resolve3, reject) {
            _async(function(err, res) {
              if (err) {
                reject(err);
                return;
              }
              resolve3(res);
            });
          });
      };
      bcrypt2.getRounds = function(hash2) {
        if (typeof hash2 !== "string")
          throw Error("Illegal arguments: " + typeof hash2);
        return parseInt(hash2.split("$")[2], 10);
      };
      bcrypt2.getSalt = function(hash2) {
        if (typeof hash2 !== "string")
          throw Error("Illegal arguments: " + typeof hash2);
        if (hash2.length !== 60)
          throw Error("Illegal hash length: " + hash2.length + " != 60");
        return hash2.substring(0, 29);
      };
      var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
      function stringToBytes(str) {
        var out = [], i = 0;
        utfx.encodeUTF16toUTF8(function() {
          if (i >= str.length)
            return null;
          return str.charCodeAt(i++);
        }, function(b) {
          out.push(b);
        });
        return out;
      }
      var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
      var BASE64_INDEX = [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        -1,
        -1,
        -1,
        -1,
        -1
      ];
      var stringFromCharCode = String.fromCharCode;
      function base64_encode(b, len) {
        var off = 0, rs = [], c1, c2;
        if (len <= 0 || len > b.length)
          throw Error("Illegal len: " + len);
        while (off < len) {
          c1 = b[off++] & 255;
          rs.push(BASE64_CODE[c1 >> 2 & 63]);
          c1 = (c1 & 3) << 4;
          if (off >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 4 & 15;
          rs.push(BASE64_CODE[c1 & 63]);
          c1 = (c2 & 15) << 2;
          if (off >= len) {
            rs.push(BASE64_CODE[c1 & 63]);
            break;
          }
          c2 = b[off++] & 255;
          c1 |= c2 >> 6 & 3;
          rs.push(BASE64_CODE[c1 & 63]);
          rs.push(BASE64_CODE[c2 & 63]);
        }
        return rs.join("");
      }
      function base64_decode(s3, len) {
        var off = 0, slen = s3.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
        if (len <= 0)
          throw Error("Illegal len: " + len);
        while (off < slen - 1 && olen < len) {
          code = s3.charCodeAt(off++);
          c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          code = s3.charCodeAt(off++);
          c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c1 == -1 || c2 == -1)
            break;
          o = c1 << 2 >>> 0;
          o |= (c2 & 48) >> 4;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s3.charCodeAt(off++);
          c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          if (c3 == -1)
            break;
          o = (c2 & 15) << 4 >>> 0;
          o |= (c3 & 60) >> 2;
          rs.push(stringFromCharCode(o));
          if (++olen >= len || off >= slen)
            break;
          code = s3.charCodeAt(off++);
          c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
          o = (c3 & 3) << 6 >>> 0;
          o |= c4;
          rs.push(stringFromCharCode(o));
          ++olen;
        }
        var res = [];
        for (off = 0; off < olen; off++)
          res.push(rs[off].charCodeAt(0));
        return res;
      }
      var utfx = function() {
        "use strict";
        var utfx2 = {};
        utfx2.MAX_CODEPOINT = 1114111;
        utfx2.encodeUTF8 = function(src3, dst) {
          var cp = null;
          if (typeof src3 === "number")
            cp = src3, src3 = function() {
              return null;
            };
          while (cp !== null || (cp = src3()) !== null) {
            if (cp < 128)
              dst(cp & 127);
            else if (cp < 2048)
              dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
            else if (cp < 65536)
              dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            else
              dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
            cp = null;
          }
        };
        utfx2.decodeUTF8 = function(src3, dst) {
          var a, b, c, d3, fail = function(b2) {
            b2 = b2.slice(0, b2.indexOf(null));
            var err = Error(b2.toString());
            err.name = "TruncatedError";
            err["bytes"] = b2;
            throw err;
          };
          while ((a = src3()) !== null) {
            if ((a & 128) === 0)
              dst(a);
            else if ((a & 224) === 192)
              (b = src3()) === null && fail([a, b]), dst((a & 31) << 6 | b & 63);
            else if ((a & 240) === 224)
              ((b = src3()) === null || (c = src3()) === null) && fail([a, b, c]), dst((a & 15) << 12 | (b & 63) << 6 | c & 63);
            else if ((a & 248) === 240)
              ((b = src3()) === null || (c = src3()) === null || (d3 = src3()) === null) && fail([a, b, c, d3]), dst((a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d3 & 63);
            else
              throw RangeError("Illegal starting byte: " + a);
          }
        };
        utfx2.UTF16toUTF8 = function(src3, dst) {
          var c1, c2 = null;
          while (true) {
            if ((c1 = c2 !== null ? c2 : src3()) === null)
              break;
            if (c1 >= 55296 && c1 <= 57343) {
              if ((c2 = src3()) !== null) {
                if (c2 >= 56320 && c2 <= 57343) {
                  dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                  c2 = null;
                  continue;
                }
              }
            }
            dst(c1);
          }
          if (c2 !== null)
            dst(c2);
        };
        utfx2.UTF8toUTF16 = function(src3, dst) {
          var cp = null;
          if (typeof src3 === "number")
            cp = src3, src3 = function() {
              return null;
            };
          while (cp !== null || (cp = src3()) !== null) {
            if (cp <= 65535)
              dst(cp);
            else
              cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
            cp = null;
          }
        };
        utfx2.encodeUTF16toUTF8 = function(src3, dst) {
          utfx2.UTF16toUTF8(src3, function(cp) {
            utfx2.encodeUTF8(cp, dst);
          });
        };
        utfx2.decodeUTF8toUTF16 = function(src3, dst) {
          utfx2.decodeUTF8(src3, function(cp) {
            utfx2.UTF8toUTF16(cp, dst);
          });
        };
        utfx2.calculateCodePoint = function(cp) {
          return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
        };
        utfx2.calculateUTF8 = function(src3) {
          var cp, l = 0;
          while ((cp = src3()) !== null)
            l += utfx2.calculateCodePoint(cp);
          return l;
        };
        utfx2.calculateUTF16asUTF8 = function(src3) {
          var n = 0, l = 0;
          utfx2.UTF16toUTF8(src3, function(cp) {
            ++n;
            l += utfx2.calculateCodePoint(cp);
          });
          return [n, l];
        };
        return utfx2;
      }();
      Date.now = Date.now || function() {
        return +new Date();
      };
      var BCRYPT_SALT_LEN = 16;
      var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
      var BLOWFISH_NUM_ROUNDS = 16;
      var MAX_EXECUTION_TIME = 100;
      var P_ORIG = [
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ];
      var S_ORIG = [
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ];
      var C_ORIG = [
        1332899944,
        1700884034,
        1701343084,
        1684370003,
        1668446532,
        1869963892
      ];
      function _encipher(lr, off, P, S) {
        var n, l = lr[off], r = lr[off + 1];
        l ^= P[0];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[1];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[2];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[3];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[4];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[5];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[6];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[7];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[8];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[9];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[10];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[11];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[12];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[13];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[14];
        n = S[l >>> 24];
        n += S[256 | l >> 16 & 255];
        n ^= S[512 | l >> 8 & 255];
        n += S[768 | l & 255];
        r ^= n ^ P[15];
        n = S[r >>> 24];
        n += S[256 | r >> 16 & 255];
        n ^= S[512 | r >> 8 & 255];
        n += S[768 | r & 255];
        l ^= n ^ P[16];
        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
        return lr;
      }
      function _streamtoword(data, offp) {
        for (var i = 0, word = 0; i < 4; ++i)
          word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
        return { key: word, offp };
      }
      function _key(key, P, S) {
        var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
        for (i = 0; i < plen; i += 2)
          lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _ekskey(data, key, P, S) {
        var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
        for (var i = 0; i < plen; i++)
          sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
        offp = 0;
        for (i = 0; i < plen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
        for (i = 0; i < slen; i += 2)
          sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
      }
      function _crypt(b, salt, rounds, callback, progressCallback) {
        var cdata = C_ORIG.slice(), clen = cdata.length, err;
        if (rounds < 4 || rounds > 31) {
          err = Error("Illegal number of rounds (4-31): " + rounds);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.length !== BCRYPT_SALT_LEN) {
          err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        rounds = 1 << rounds >>> 0;
        var P, S, i = 0, j;
        if (Int32Array) {
          P = new Int32Array(P_ORIG);
          S = new Int32Array(S_ORIG);
        } else {
          P = P_ORIG.slice();
          S = S_ORIG.slice();
        }
        _ekskey(salt, b, P, S);
        function next() {
          if (progressCallback)
            progressCallback(i / rounds);
          if (i < rounds) {
            var start = Date.now();
            for (; i < rounds; ) {
              i = i + 1;
              _key(b, P, S);
              _key(salt, P, S);
              if (Date.now() - start > MAX_EXECUTION_TIME)
                break;
            }
          } else {
            for (i = 0; i < 64; i++)
              for (j = 0; j < clen >> 1; j++)
                _encipher(cdata, j << 1, P, S);
            var ret = [];
            for (i = 0; i < clen; i++)
              ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
            if (callback) {
              callback(null, ret);
              return;
            } else
              return ret;
          }
          if (callback)
            nextTick(next);
        }
        if (typeof callback !== "undefined") {
          next();
        } else {
          var res;
          while (true)
            if (typeof (res = next()) !== "undefined")
              return res || [];
        }
      }
      function _hash(s3, salt, callback, progressCallback) {
        var err;
        if (typeof s3 !== "string" || typeof salt !== "string") {
          err = Error("Invalid string / salt: Not a string");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var minor, offset;
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
          err = Error("Invalid salt version: " + salt.substring(0, 2));
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        if (salt.charAt(2) === "$")
          minor = String.fromCharCode(0), offset = 3;
        else {
          minor = salt.charAt(2);
          if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
            err = Error("Invalid salt revision: " + salt.substring(2, 4));
            if (callback) {
              nextTick(callback.bind(this, err));
              return;
            } else
              throw err;
          }
          offset = 4;
        }
        if (salt.charAt(offset + 2) > "$") {
          err = Error("Missing salt rounds");
          if (callback) {
            nextTick(callback.bind(this, err));
            return;
          } else
            throw err;
        }
        var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
        s3 += minor >= "a" ? "\0" : "";
        var passwordb = stringToBytes(s3), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
        function finish(bytes2) {
          var res = [];
          res.push("$2");
          if (minor >= "a")
            res.push(minor);
          res.push("$");
          if (rounds < 10)
            res.push("0");
          res.push(rounds.toString());
          res.push("$");
          res.push(base64_encode(saltb, saltb.length));
          res.push(base64_encode(bytes2, C_ORIG.length * 4 - 1));
          return res.join("");
        }
        if (typeof callback == "undefined")
          return finish(_crypt(passwordb, saltb, rounds));
        else {
          _crypt(passwordb, saltb, rounds, function(err2, bytes2) {
            if (err2)
              callback(err2, null);
            else
              callback(null, finish(bytes2));
          }, progressCallback);
        }
      }
      bcrypt2.encodeBase64 = base64_encode;
      bcrypt2.decodeBase64 = base64_decode;
      return bcrypt2;
    });
  }
});

// node_modules/bcryptjs/index.js
var require_bcryptjs = __commonJS({
  "node_modules/bcryptjs/index.js"(exports2, module2) {
    init_shims();
    module2.exports = require_bcrypt();
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports2, module2) {
    init_shims();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream2 = __require("stream");
    var util2 = __require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util2.inherits(DataStream, Stream2);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = __require("buffer").Buffer;
    var SlowBuffer = __require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    init_shims();
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    init_shims();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if (typeof signature === "string") {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/jwa/index.js"(exports2, module2) {
    init_shims();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = __require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util2 = __require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template2) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util2.format.bind(util2, template2).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports2, module2) {
    init_shims();
    var Buffer2 = __require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    init_shims();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = __require("stream");
    var toString = require_tostring();
    var util2 = __require("util");
    function base64url(string, encoding3) {
      return Buffer2.from(string, encoding3).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding3) {
      encoding3 = encoding3 || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding3);
      return util2.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding3 = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding3);
      var signature = algo.sign(securedInput, secretOrKey);
      return util2.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util2.inherits(SignStream, Stream2);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    init_shims();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream2 = __require("stream");
    var toString = require_tostring();
    var util2 = __require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding3) {
      encoding3 = encoding3 || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding3);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util2.inherits(VerifyStream, Stream2);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/jws/index.js"(exports2) {
    init_shims();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    init_shims();
    var jws = require_jws();
    module2.exports = function(jwt2, options2) {
      options2 = options2 || {};
      var decoded = jws.decode(jwt2, options2);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options2.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    init_shims();
    var JsonWebTokenError = function(message, error3) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error3)
        this.inner = error3;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    init_shims();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    init_shims();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_shims();
    var s3 = 1e3;
    var m2 = s3 * 60;
    var h2 = m2 * 60;
    var d3 = h2 * 24;
    var w = d3 * 7;
    var y2 = d3 * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return Math.round(ms2 / d3) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms2 / s3) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d3) {
        return plural2(ms2, msAbs, d3, "day");
      }
      if (msAbs >= h2) {
        return plural2(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural2(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s3) {
        return plural2(ms2, msAbs, s3, "second");
      }
      return ms2 + " ms";
    }
    function plural2(ms2, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    init_shims();
    var ms2 = require_ms();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms2(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// node_modules/jsonwebtoken/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/jsonwebtoken/node_modules/semver/semver.js"(exports2, module2) {
    init_shims();
    exports2 = module2.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src3 = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src3[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src3[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src3[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src3[MAINVERSION] = "(" + src3[NUMERICIDENTIFIER] + ")\\.(" + src3[NUMERICIDENTIFIER] + ")\\.(" + src3[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src3[MAINVERSIONLOOSE] = "(" + src3[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src3[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src3[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src3[PRERELEASEIDENTIFIER] = "(?:" + src3[NUMERICIDENTIFIER] + "|" + src3[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src3[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src3[NUMERICIDENTIFIERLOOSE] + "|" + src3[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src3[PRERELEASE] = "(?:-(" + src3[PRERELEASEIDENTIFIER] + "(?:\\." + src3[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src3[PRERELEASELOOSE] = "(?:-?(" + src3[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src3[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src3[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src3[BUILD] = "(?:\\+(" + src3[BUILDIDENTIFIER] + "(?:\\." + src3[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src3[MAINVERSION] + src3[PRERELEASE] + "?" + src3[BUILD] + "?";
    src3[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src3[MAINVERSIONLOOSE] + src3[PRERELEASELOOSE] + "?" + src3[BUILD] + "?";
    var LOOSE = R++;
    src3[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src3[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src3[XRANGEIDENTIFIERLOOSE] = src3[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src3[XRANGEIDENTIFIER] = src3[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src3[XRANGEPLAIN] = "[v=\\s]*(" + src3[XRANGEIDENTIFIER] + ")(?:\\.(" + src3[XRANGEIDENTIFIER] + ")(?:\\.(" + src3[XRANGEIDENTIFIER] + ")(?:" + src3[PRERELEASE] + ")?" + src3[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src3[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src3[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src3[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src3[XRANGEIDENTIFIERLOOSE] + ")(?:" + src3[PRERELEASELOOSE] + ")?" + src3[BUILD] + "?)?)?";
    var XRANGE = R++;
    src3[XRANGE] = "^" + src3[GTLT] + "\\s*" + src3[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src3[XRANGELOOSE] = "^" + src3[GTLT] + "\\s*" + src3[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src3[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src3[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src3[TILDETRIM] = "(\\s*)" + src3[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src3[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src3[TILDE] = "^" + src3[LONETILDE] + src3[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src3[TILDELOOSE] = "^" + src3[LONETILDE] + src3[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src3[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src3[CARETTRIM] = "(\\s*)" + src3[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src3[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src3[CARET] = "^" + src3[LONECARET] + src3[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src3[CARETLOOSE] = "^" + src3[LONECARET] + src3[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src3[COMPARATORLOOSE] = "^" + src3[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src3[COMPARATOR] = "^" + src3[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src3[COMPARATORTRIM] = "(\\s*)" + src3[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src3[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src3[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src3[HYPHENRANGE] = "^\\s*(" + src3[XRANGEPLAIN] + ")\\s+-\\s+(" + src3[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src3[HYPHENRANGELOOSE] = "^\\s*(" + src3[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src3[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src3[STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < R; i++) {
      debug2(i, src3[i]);
      if (!re[i]) {
        re[i] = new RegExp(src3[i]);
      }
    }
    exports2.parse = parse3;
    function parse3(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options2) {
      var v = parse3(version, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options2) {
      var s3 = parse3(version.trim().replace(/^[=v]+/, ""), options2);
      return s3 ? s3.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options2.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options2);
      }
      debug2("SemVer", version, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m2 = version.trim().match(options2.loose ? re[LOOSE] : re[FULL]);
      if (!m2) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse3(version1);
        var v2 = parse3(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch2;
    function patch2(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list2, loose) {
      return list2.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list2, loose) {
      return list2.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m2 = comp.match(r);
      if (!m2) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m2[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set2 = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set2 = set2.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set2 = set2.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set2;
    };
    Range.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug2("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug2("caret", comp);
      comp = replaceTildes(comp, options2);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug2("xrange", comp);
      comp = replaceStars(comp, options2);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m2, p, pr) {
        debug2("tilde", comp, _, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug2("caret", comp, options2);
      var r = options2.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m2, p, pr) {
        debug2("caret", comp, _, M, m2, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m2 + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + m2 + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m2 + "." + p + " <" + M + "." + (+m2 + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m2 + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug2("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m2, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m2, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m2);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p = 0;
            } else {
              m2 = +m2 + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          ret = gtlt + M + "." + m2 + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m2 + ".0 <" + M + "." + (+m2 + 1) + ".0";
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug2("replaceStars", comp, options2);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set2, version, options2) {
      for (var i2 = 0; i2 < set2.length; i2++) {
        if (!set2[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set2.length; i2++) {
          debug2(set2[i2].semver);
          if (set2[i2].semver === ANY) {
            continue;
          }
          if (set2[i2].semver.prerelease.length > 0) {
            var allowed = set2[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options2) {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options2) {
      return outside(version, range, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options2) {
      return outside(version, range, ">", options2);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options2) {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options2) {
      var parsed = parse3(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse3(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    init_shims();
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    init_shims();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options2, callback) {
      if (typeof options2 === "function" && !callback) {
        callback = options2;
        options2 = {};
      }
      if (!options2) {
        options2 = {};
      }
      options2 = Object.assign({}, options2);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options2.clockTimestamp && typeof options2.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options2.nonce !== void 0 && (typeof options2.nonce !== "string" || options2.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options2.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options2.algorithms) {
          options2.algorithms = ["none"];
        }
        if (!options2.algorithms) {
          options2.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options2.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options2.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options2.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options2.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options2.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options2.audience) {
          var audiences = Array.isArray(options2.audience) ? options2.audience : [options2.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options2.issuer) {
          var invalid_issuer = typeof options2.issuer === "string" && payload.iss !== options2.issuer || Array.isArray(options2.issuer) && options2.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options2.issuer));
          }
        }
        if (options2.subject) {
          if (payload.sub !== options2.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options2.subject));
          }
        }
        if (options2.jwtid) {
          if (payload.jti !== options2.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options2.jwtid));
          }
        }
        if (options2.nonce) {
          if (payload.nonce !== options2.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options2.nonce));
          }
        }
        if (options2.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options2.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options2.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options2.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports2, module2) {
    init_shims();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array ? array.length : 0, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard2) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard2 ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports2, module2) {
    init_shims();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports2, module2) {
    init_shims();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports2, module2) {
    init_shims();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    init_shims();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports2, module2) {
    init_shims();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports2, module2) {
    init_shims();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    init_shims();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash();
    var isBoolean = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString = require_lodash6();
    var once = require_lodash7();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options2) {
      return validate(sign_options_schema, false, options2, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      } else {
        options2 = options2 || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options2.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options2.keyid
      }, options2.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options2.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error3) {
          return failure(error3);
        }
        if (!options2.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options2[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options2.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options2.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options2);
      } catch (error3) {
        return failure(error3);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options2.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options2.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options2.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options2.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options2.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options2[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options2[key];
        }
      });
      var encoding3 = options2.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding: encoding3
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding: encoding3 });
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports2, module2) {
    init_shims();
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// .svelte-kit/node/index.js
init_shims();

// .svelte-kit/output/server/app.js
init_shims();

// node_modules/@sveltejs/kit/dist/ssr.js
init_shims();
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name2, thing) {
      params_1.push(name2);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name2 + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name2 + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name2 + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name2 + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name2 = "";
  do {
    name2 = chars[num % chars.length] + name2;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name2) ? name2 + "_" : name2;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s3 = subscribers[i];
          s3[1]();
          subscriber_queue.push(s3, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe3(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set2) || noop;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe3 };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var s$1 = JSON.stringify;
async function render_response({
  options: options2,
  $session,
  page_config,
  status: status2,
  error: error3,
  branch,
  page: page2
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error3) {
    error3.stack = options2.get_stack(error3);
  }
  if (branch) {
    branch.forEach(({ node: node2, loaded, fetched, uses_credentials }) => {
      if (node2.css)
        node2.css.forEach((url) => css2.add(url));
      if (node2.js)
        node2.js.forEach((url) => js.add(url));
      if (node2.styles)
        node2.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session
      },
      page: page2,
      components: branch.map(({ node: node2 }) => node2.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error4) => {
      throw new Error(`Failed to serialize session data: ${error4.message}`);
    })},
				host: ${page2 && page2.host ? s$1(page2.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status2},
					error: ${serialize_error(error3)},
					nodes: [
						${branch.map(({ node: node2 }) => `import(${s$1(node2.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page2.host ? s$1(page2.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page2.path)},
						query: new URLSearchParams(${s$1(page2.query.toString())}),
						params: ${s$1(page2.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    return body2 ? `<script type="svelte-data" url="${url}" body="${hash(body2)}">${json}<\/script>` : `<script type="svelte-data" url="${url}">${json}<\/script>`;
  }).join("\n\n			")}
		`.replace(/^\t{2}/gm, "");
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status: status2,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(err);
    return null;
  }
}
function serialize_error(error3) {
  if (!error3)
    return null;
  let serialized = try_serialize(error3);
  if (!serialized) {
    const { name: name2, message, stack } = error3;
    serialized = try_serialize({ name: name2, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  if (loaded.error) {
    const error3 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    const status2 = loaded.status;
    if (!(error3 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error3}"`)
      };
    }
    if (!status2 || status2 < 400 || status2 > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error3 };
    }
    return { status: status2, error: error3 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  return loaded;
}
function resolve(base, path) {
  const baseparts = path[0] === "/" ? [] : base.slice(1).split("/");
  const pathparts = path[0] === "/" ? path.slice(1).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  return `/${baseparts.join("/")}`;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page: page2,
  node: node2,
  $session,
  context,
  is_leaf,
  is_error,
  status: status2,
  error: error3
}) {
  const { module: module2 } = node2;
  let uses_credentials = false;
  const fetched = [];
  let loaded;
  if (module2.load) {
    const load_input = {
      page: page2,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        if (options2.read && url.startsWith(options2.paths.assets)) {
          url = url.replace(options2.paths.assets, "");
        }
        if (url.startsWith("//")) {
          throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
        }
        let response;
        if (/^[a-zA-Z]+:/.test(url)) {
          response = await (void 0)(url, opts);
        } else {
          const [path, search] = url.split("?");
          const resolved = resolve(request.path, path);
          const filename = resolved.slice(1);
          const filename_html = `${filename}/index.html`;
          const asset = options2.manifest.assets.find((d3) => d3.file === filename || d3.file === filename_html);
          if (asset) {
            if (options2.read) {
              response = new (void 0)(options2.read(asset.file), {
                headers: {
                  "content-type": asset.type
                }
              });
            } else {
              response = await (void 0)(`http://${page2.host}/${asset.file}`, opts);
            }
          }
          if (!response) {
            const headers = __spreadValues({}, opts.headers);
            if (opts.credentials !== "omit") {
              uses_credentials = true;
              headers.cookie = request.headers.cookie;
              if (!headers.authorization) {
                headers.authorization = request.headers.authorization;
              }
            }
            if (opts.body && typeof opts.body !== "string") {
              throw new Error("Request body must be a string");
            }
            const rendered = await respond({
              host: request.host,
              method: opts.method || "GET",
              headers,
              path: resolved,
              rawBody: opts.body,
              query: new URLSearchParams(search)
            }, options2, {
              fetched: url,
              initiator: route
            });
            if (rendered) {
              if (state.prerender) {
                state.prerender.dependencies.set(resolved, rendered);
              }
              response = new (void 0)(rendered.body, {
                status: rendered.status,
                headers: rendered.headers
              });
            }
          }
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 !== "etag" && key2 !== "set-cookie")
                    headers[key2] = value;
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":${escape(body)}}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new (void 0)("Not found", {
          status: 404
        });
      },
      context: __spreadValues({}, context)
    };
    if (is_error) {
      load_input.status = status2;
      load_input.error = error3;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  return {
    node: node2,
    loaded: normalize(loaded),
    context: loaded.context || context,
    fetched,
    uses_credentials
  };
}
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
async function respond_with_error({ request, options: options2, state, $session, status: status2, error: error3 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page: page2,
    node: default_layout,
    $session,
    context: {},
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page: page2,
      node: default_error,
      $session,
      context: loaded.context,
      is_leaf: false,
      is_error: true,
      status: status2,
      error: error3
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status: status2,
      error: error3,
      branch,
      page: page2
    });
  } catch (error4) {
    options2.handle_error(error4);
    return {
      status: 500,
      headers: {},
      body: error4.stack
    };
  }
}
async function respond$1({ request, options: options2, state, $session, route }) {
  const match = route.pattern.exec(request.path);
  const params = route.params(match);
  const page2 = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id && options2.load_component(id)));
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  const page_config = {
    ssr: "ssr" in leaf ? leaf.ssr : options2.ssr,
    router: "router" in leaf ? leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? leaf.hydrate : options2.hydrate
  };
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: null
    };
  }
  let branch;
  let status2 = 200;
  let error3;
  ssr:
    if (page_config.ssr) {
      let context = {};
      branch = [];
      for (let i = 0; i < nodes.length; i += 1) {
        const node2 = nodes[i];
        let loaded;
        if (node2) {
          try {
            loaded = await load_node({
              request,
              options: options2,
              state,
              route,
              page: page2,
              node: node2,
              $session,
              context,
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            if (loaded.loaded.redirect) {
              return {
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              };
            }
            if (loaded.loaded.error) {
              ({ status: status2, error: error3 } = loaded.loaded);
            }
          } catch (e) {
            options2.handle_error(e);
            status2 = 500;
            error3 = e;
          }
          if (error3) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let error_loaded;
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  error_loaded = await load_node({
                    request,
                    options: options2,
                    state,
                    route,
                    page: page2,
                    node: error_node,
                    $session,
                    context: node_loaded.context,
                    is_leaf: false,
                    is_error: true,
                    status: status2,
                    error: error3
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (e) {
                  options2.handle_error(e);
                  continue;
                }
              }
            }
            return await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status: status2,
              error: error3
            });
          }
        }
        branch.push(loaded);
        if (loaded && loaded.loaded.context) {
          context = __spreadValues(__spreadValues({}, context), loaded.loaded.context);
        }
      }
    }
  try {
    return await render_response({
      options: options2,
      $session,
      page_config,
      status: status2,
      error: error3,
      branch: branch && branch.filter(Boolean),
      page: page2
    });
  } catch (error4) {
    options2.handle_error(error4);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error4
    });
  }
}
async function render_page(request, route, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const $session = await options2.hooks.getSession(request);
  if (route) {
    const response = await respond$1({
      request,
      options: options2,
      state,
      $session,
      route
    });
    if (response) {
      return response;
    }
    if (state.fetched) {
      return {
        status: 500,
        headers: {},
        body: `Bad request in load function: failed to fetch ${state.fetched}`
      };
    }
  } else {
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 404,
      error: new Error(`Not found: ${request.path}`)
    });
  }
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
async function render_route(request, route) {
  const mod = await route.load();
  const handler = mod[request.method.toLowerCase().replace("delete", "del")];
  if (handler) {
    const match = route.pattern.exec(request.path);
    const params = route.params(match);
    const response = await handler(__spreadProps(__spreadValues({}, request), { params }));
    if (response) {
      if (typeof response !== "object") {
        return error(`Invalid response from route ${request.path}: expected an object, got ${typeof response}`);
      }
      let { status: status2 = 200, body, headers = {} } = response;
      headers = lowercase_keys(headers);
      const type = headers["content-type"];
      if (type === "application/octet-stream" && !(body instanceof Uint8Array)) {
        return error(`Invalid response from route ${request.path}: body must be an instance of Uint8Array if content type is application/octet-stream`);
      }
      if (body instanceof Uint8Array && type !== "application/octet-stream") {
        return error(`Invalid response from route ${request.path}: Uint8Array body must be accompanied by content-type: application/octet-stream header`);
      }
      let normalized_body;
      if (typeof body === "object" && (!type || type === "application/json")) {
        headers = __spreadProps(__spreadValues({}, headers), { "content-type": "application/json" });
        normalized_body = JSON.stringify(body);
      } else {
        normalized_body = body;
      }
      return { status: status2, body: normalized_body, headers };
    }
  }
}
function read_only_form_data() {
  const map2 = new Map();
  return {
    append(key, value) {
      if (map2.has(key)) {
        map2.get(key).push(value);
      } else {
        map2.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map2)
  };
}
var _map;
var ReadOnlyFormData = class {
  constructor(map2) {
    __privateAdd(this, _map, void 0);
    __privateSet(this, _map, map2);
  }
  get(key) {
    const value = __privateGet(this, _map).get(key);
    return value && value[0];
  }
  getAll(key) {
    return __privateGet(this, _map).get(key);
  }
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield key;
      }
    }
  }
  *values() {
    for (const [, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield value;
      }
    }
  }
};
_map = new WeakMap();
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const [type, ...directives] = headers["content-type"].split(/;\s*/);
  if (typeof raw === "string") {
    switch (type) {
      case "text/plain":
        return raw;
      case "application/json":
        return JSON.parse(raw);
      case "application/x-www-form-urlencoded":
        return get_urlencoded(raw);
      case "multipart/form-data": {
        const boundary = directives.find((directive) => directive.startsWith("boundary="));
        if (!boundary)
          throw new Error("Missing boundary");
        return get_multipart(raw, boundary.slice("boundary=".length));
      }
      default:
        throw new Error(`Invalid Content-Type ${type}`);
    }
  }
  return raw;
}
function get_urlencoded(text) {
  const { data, append: append2 } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append2(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  const nope = () => {
    throw new Error("Malformed form data");
  };
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    nope();
  }
  const { data, append: append2 } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name2, value] = raw_header.split(": ");
      name2 = name2.toLowerCase();
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name3, value2] = raw_directive.split("=");
        directives[name3] = JSON.parse(value2);
      });
      if (name2 === "content-disposition") {
        if (value !== "form-data")
          nope();
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      nope();
    append2(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !incoming.path.split("/").pop().includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: encodeURI(path + (q ? `?${q}` : ""))
        }
      };
    }
  }
  try {
    const headers = lowercase_keys(incoming.headers);
    return await options2.hooks.handle({
      request: __spreadProps(__spreadValues({}, incoming), {
        headers,
        body: parse_body(incoming.rawBody, headers),
        params: null,
        locals: {}
      }),
      resolve: async (request) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            error: null,
            branch: [],
            page: null
          });
        }
        for (const route of options2.manifest.routes) {
          if (!route.pattern.test(request.path))
            continue;
          const response = route.type === "endpoint" ? await render_route(request, route) : await render_page(request, route, options2, state);
          if (response) {
            if (response.status === 200) {
              if (!/(no-store|immutable)/.test(response.headers["cache-control"])) {
                const etag = `"${hash(response.body)}"`;
                if (request.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: null
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        return await render_page(request, null, options2, state);
      }
    });
  } catch (e) {
    options2.handle_error(e);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}

// node_modules/svelte/internal/index.mjs
init_shims();
function noop2() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal2(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop2;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var tasks = new Set();
function custom_event(type, detail) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, false, false, detail);
  return e;
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
var resolved_promise = Promise.resolve();
var seen_callbacks = new Set();
var outroing = new Set();
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);
  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += " " + classes_to_add;
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name2) => {
    if (invalid_attribute_name_character.test(name2))
      return;
    const value = attributes[name2];
    if (value === true)
      str += " " + name2;
    else if (boolean_attributes.has(name2.toLowerCase())) {
      if (value)
        str += " " + name2;
    } else if (value != null) {
      str += ` ${name2}="${value}"`;
    }
  });
  return str;
}
var escaped2 = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape2(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped2[match]);
}
function escape_attribute_value(value) {
  return typeof value === "string" ? escape2(value) : value;
}
function escape_object(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = escape_attribute_value(obj[key]);
  }
  return result;
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name2) {
  if (!component || !component.$$render) {
    if (name2 === "svelte:component")
      name2 += " this={...}";
    throw new Error(`<${name2}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : context || []),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name2, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name2}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape2(value)) : `"${value}"`}`}`;
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop2;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// node_modules/svelte/index.mjs
init_shims();

// .svelte-kit/output/server/app.js
var import_mongodb = __toModule(require_mongodb());
var import_bcryptjs = __toModule(require_bcryptjs());
var import_jsonwebtoken = __toModule(require_jsonwebtoken());

// node_modules/svelte/easing/index.mjs
init_shims();

// node_modules/svelte/store/index.mjs
init_shims();
var subscriber_queue2 = [];
function writable2(value, start = noop2) {
  let stop;
  const subscribers = [];
  function set2(new_value) {
    if (safe_not_equal2(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue2.length;
        for (let i = 0; i < subscribers.length; i += 1) {
          const s3 = subscribers[i];
          s3[1]();
          subscriber_queue2.push(s3, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue2.length; i += 2) {
            subscriber_queue2[i][0](subscriber_queue2[i + 1]);
          }
          subscriber_queue2.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe3(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set2) || noop2;
    }
    run2(value);
    return () => {
      const index2 = subscribers.indexOf(subscriber);
      if (index2 !== -1) {
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe3 };
}

// node_modules/svelte/transition/index.mjs
init_shims();

// .svelte-kit/output/server/app.js
var css$1 = {
  code: "#svelte-announcer.svelte-1pdgbjn{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>#svelte-announcer{clip:rect(0 0 0 0);-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;left:0;overflow:hidden;position:absolute;top:0;white-space:nowrap;width:1px}</style>"],"names":[],"mappings":"AAqDO,gCAAiB,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,kBAAkB,MAAM,GAAG,CAAC,CAAC,UAAU,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,CAAC,KAAK,CAAC,CAAC,SAAS,MAAM,CAAC,SAAS,QAAQ,CAAC,IAAI,CAAC,CAAC,YAAY,MAAM,CAAC,MAAM,GAAG,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page: page2 } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
    $$bindings.page(page2);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$1);
  {
    stores.page.set(page2);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1pdgbjn"}">${navigated ? `${escape2(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths2) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
    <link rel="alternate icon" href="/icon-16x16.png" />
    <link rel="apple-touch-icon" href="/icon-apple-touch.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').then(function () {
          console.log('Service Worker Registered');
        });
      }
    <\/script> -->
    ` + head + '\n  </head>\n  <body>\n    <div id="svelte">' + body + "</div>\n  </body>\n</html>\n";
var options$1 = null;
function init(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options$1 = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-31db9315.js",
      css: ["/./_app/assets/start-0826e215.css", "/./_app/assets/vendor-774ad079.css"],
      js: ["/./_app/start-31db9315.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/singletons-bb9012b7.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error22) => String(error22),
    handle_error: (error22) => {
      console.error(error22.stack);
      error22.stack = options$1.get_stack(error22);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = decodeURIComponent;
var empty = () => ({});
var manifest = {
  assets: [{ "file": "icon-120x120.png", "size": 12781, "type": "image/png" }, { "file": "icon-128x128.png", "size": 14243, "type": "image/png" }, { "file": "icon-144x144.png", "size": 17229, "type": "image/png" }, { "file": "icon-152x152.png", "size": 18932, "type": "image/png" }, { "file": "icon-16x16.png", "size": 751, "type": "image/png" }, { "file": "icon-180x180.png", "size": 25432, "type": "image/png" }, { "file": "icon-192x192.png", "size": 28508, "type": "image/png" }, { "file": "icon-24x24.png", "size": 1227, "type": "image/png" }, { "file": "icon-384x384.png", "size": 99123, "type": "image/png" }, { "file": "icon-512x512.png", "size": 162472, "type": "image/png" }, { "file": "icon-72x72.png", "size": 5616, "type": "image/png" }, { "file": "icon-96x96.png", "size": 8860, "type": "image/png" }, { "file": "icon-apple-touch.png", "size": 28261, "type": "image/png" }, { "file": "icon.svg", "size": 2028, "type": "image/svg+xml" }, { "file": "manifest.json", "size": 906, "type": "application/json" }, { "file": "sw.js", "size": 1910, "type": "application/javascript" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/my-account\/change-password\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/my-account/change-password/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/dashboard\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/dashboard/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/safety\/training-checklist\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/safety/training-checklist/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/safety\/role-requirements\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/safety/role-requirements/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/safety\/types\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/safety/types/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/safety\/types\/edit\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/safety/types/edit.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/safety\/types\/add\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/safety/types/add.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/signin\/?$/,
      params: empty,
      a: ["src/routes/signin/__layout.reset.svelte", "src/routes/signin/index.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/admin\/routes\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/admin\/routes\/edit\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin/routes/edit.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/admin\/routes\/add\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin/routes/add.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/admin\/roles\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin/roles/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/admin\/roles\/add\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/admin/roles/add.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/users\/management\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/users/management/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/users\/management\/edit\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/users/management/edit.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/users\/management\/add\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/users/management/add.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/users\/directory\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/users/directory/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/users\/verify\/?$/,
      params: empty,
      a: ["src/routes/users/verify/__layout.reset.svelte", "src/routes/users/verify/index.svelte"],
      b: []
    },
    {
      type: "endpoint",
      pattern: /^\/api\/datatable\/([^/]+?)\/?$/,
      params: (m2) => ({ slug: d(m2[1]) }),
      load: () => Promise.resolve().then(function() {
        return _slug_;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/datatable\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return datatable;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/auth\/changepassword\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return changepassword;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/auth\/signin\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return signin;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/auth\/signup\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return signup;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/auth\/get\/signinroute\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return signinroute;
      })
    },
    {
      type: "endpoint",
      pattern: /^\/api\/auth\/get\/userroutes\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return userroutes;
      })
    },
    {
      type: "page",
      pattern: /^\/hr\/safety\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/hr/safety/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve3 }) => resolve3(request))
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error2;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$c;
  }),
  "src/routes/my-account/change-password/index.svelte": () => Promise.resolve().then(function() {
    return index$b;
  }),
  "src/routes/dashboard/index.svelte": () => Promise.resolve().then(function() {
    return index$a;
  }),
  "src/routes/safety/training-checklist/index.svelte": () => Promise.resolve().then(function() {
    return index$9;
  }),
  "src/routes/safety/role-requirements/index.svelte": () => Promise.resolve().then(function() {
    return index$8;
  }),
  "src/routes/safety/types/index.svelte": () => Promise.resolve().then(function() {
    return index$7;
  }),
  "src/routes/safety/types/edit.svelte": () => Promise.resolve().then(function() {
    return edit$2;
  }),
  "src/routes/safety/types/add.svelte": () => Promise.resolve().then(function() {
    return add$3;
  }),
  "src/routes/signin/__layout.reset.svelte": () => Promise.resolve().then(function() {
    return __layout_reset$1;
  }),
  "src/routes/signin/index.svelte": () => Promise.resolve().then(function() {
    return index$6;
  }),
  "src/routes/admin/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$5;
  }),
  "src/routes/admin/routes/edit.svelte": () => Promise.resolve().then(function() {
    return edit$1;
  }),
  "src/routes/admin/routes/add.svelte": () => Promise.resolve().then(function() {
    return add$2;
  }),
  "src/routes/admin/roles/index.svelte": () => Promise.resolve().then(function() {
    return index$4;
  }),
  "src/routes/admin/roles/add.svelte": () => Promise.resolve().then(function() {
    return add$1;
  }),
  "src/routes/users/management/index.svelte": () => Promise.resolve().then(function() {
    return index$3;
  }),
  "src/routes/users/management/edit.svelte": () => Promise.resolve().then(function() {
    return edit;
  }),
  "src/routes/users/management/add.svelte": () => Promise.resolve().then(function() {
    return add;
  }),
  "src/routes/users/directory/index.svelte": () => Promise.resolve().then(function() {
    return index$2;
  }),
  "src/routes/users/verify/__layout.reset.svelte": () => Promise.resolve().then(function() {
    return __layout_reset;
  }),
  "src/routes/users/verify/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/hr/safety/index.svelte": () => Promise.resolve().then(function() {
    return index;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "/./_app/pages/__layout.svelte-7bba9e6a.js", "css": ["/./_app/assets/vendor-774ad079.css", "/./_app/assets/style-2a414724.css"], "js": ["/./_app/pages/__layout.svelte-7bba9e6a.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/stores-91ba20f1.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Modal-49e93e6d.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Container-cc8e1a1a.js", "/./_app/chunks/style-9bbc3b5c.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/store-b327666d.js"], "styles": null }, ".svelte-kit/build/components/error.svelte": { "entry": "/./_app/error.svelte-b633e1a8.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/error.svelte-b633e1a8.js", "/./_app/chunks/vendor-483ca6b6.js"], "styles": null }, "src/routes/index.svelte": { "entry": "/./_app/pages/index.svelte-ca1f17e0.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/index.svelte-ca1f17e0.js", "/./_app/chunks/vendor-483ca6b6.js"], "styles": null }, "src/routes/my-account/change-password/index.svelte": { "entry": "/./_app/pages/my-account/change-password/index.svelte-ba6b6853.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/my-account/change-password/index.svelte-ba6b6853.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/dashboard/index.svelte": { "entry": "/./_app/pages/dashboard/index.svelte-479885c3.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/dashboard/index.svelte-479885c3.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/Section-69710e66.js", "/./_app/chunks/auth-c13ad024.js"], "styles": null }, "src/routes/safety/training-checklist/index.svelte": { "entry": "/./_app/pages/safety/training-checklist/index.svelte-bd30f503.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/safety/training-checklist/index.svelte-bd30f503.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/safety/role-requirements/index.svelte": { "entry": "/./_app/pages/safety/role-requirements/index.svelte-cac58a09.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/safety/role-requirements/index.svelte-cac58a09.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/safety/types/index.svelte": { "entry": "/./_app/pages/safety/types/index.svelte-b3d95d51.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/safety/types/index.svelte-b3d95d51.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/_columns-aa0cd4b4.js", "/./_app/chunks/Datatable-bec85cba.js", "/./_app/chunks/stores-91ba20f1.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/safety/types/edit.svelte": { "entry": "/./_app/pages/safety/types/edit.svelte-b64d17be.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/safety/types/edit.svelte-b64d17be.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_columns-aa0cd4b4.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/safety/types/add.svelte": { "entry": "/./_app/pages/safety/types/add.svelte-e7f923b5.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/safety/types/add.svelte-e7f923b5.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_columns-aa0cd4b4.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/signin/__layout.reset.svelte": { "entry": "/./_app/pages/signin/__layout.reset.svelte-1a200ed9.js", "css": ["/./_app/assets/vendor-774ad079.css", "/./_app/assets/style-2a414724.css"], "js": ["/./_app/pages/signin/__layout.reset.svelte-1a200ed9.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/style-9bbc3b5c.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Container-cc8e1a1a.js", "/./_app/chunks/auth-c13ad024.js"], "styles": null }, "src/routes/signin/index.svelte": { "entry": "/./_app/pages/signin/index.svelte-dd7d5fbd.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/signin/index.svelte-dd7d5fbd.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Container-cc8e1a1a.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/admin/routes/index.svelte": { "entry": "/./_app/pages/admin/routes/index.svelte-88408115.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/admin/routes/index.svelte-88408115.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/Datatable-bec85cba.js", "/./_app/chunks/stores-91ba20f1.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/admin/routes/edit.svelte": { "entry": "/./_app/pages/admin/routes/edit.svelte-8cef8fc3.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/admin/routes/edit.svelte-8cef8fc3.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/admin/routes/add.svelte": { "entry": "/./_app/pages/admin/routes/add.svelte-1b20a5f9.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/admin/routes/add.svelte-1b20a5f9.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/admin/roles/index.svelte": { "entry": "/./_app/pages/admin/roles/index.svelte-fda801ab.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/admin/roles/index.svelte-fda801ab.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/admin/roles/add.svelte": { "entry": "/./_app/pages/admin/roles/add.svelte-6a0494f9.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/admin/roles/add.svelte-6a0494f9.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/users/management/index.svelte": { "entry": "/./_app/pages/users/management/index.svelte-b3ef321e.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/users/management/index.svelte-b3ef321e.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/_columns-4962c75d.js", "/./_app/chunks/Datatable-bec85cba.js", "/./_app/chunks/stores-91ba20f1.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/users/management/edit.svelte": { "entry": "/./_app/pages/users/management/edit.svelte-5066ad30.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/users/management/edit.svelte-5066ad30.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_columns-4962c75d.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/users/management/add.svelte": { "entry": "/./_app/pages/users/management/add.svelte-a624828a.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/users/management/add.svelte-a624828a.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_columns-4962c75d.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Back-7e1bfb8e.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Select-2b3a6ae9.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/users/directory/index.svelte": { "entry": "/./_app/pages/users/directory/index.svelte-84087300.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/users/directory/index.svelte-84087300.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/_columns-4962c75d.js", "/./_app/chunks/Datatable-bec85cba.js", "/./_app/chunks/stores-91ba20f1.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/_transitions-34f54501.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Checkbox-6f8586bf.js", "/./_app/chunks/Table-c26e4894.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/users/verify/__layout.reset.svelte": { "entry": "/./_app/pages/users/verify/__layout.reset.svelte-19c63fa9.js", "css": ["/./_app/assets/vendor-774ad079.css", "/./_app/assets/style-2a414724.css"], "js": ["/./_app/pages/users/verify/__layout.reset.svelte-19c63fa9.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/Modal-49e93e6d.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/Spinner-460fa24f.js", "/./_app/chunks/Container-cc8e1a1a.js", "/./_app/chunks/style-9bbc3b5c.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/auth-c13ad024.js"], "styles": null }, "src/routes/users/verify/index.svelte": { "entry": "/./_app/pages/users/verify/index.svelte-3e7bf152.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/users/verify/index.svelte-3e7bf152.js", "/./_app/chunks/vendor-483ca6b6.js", "/./_app/chunks/navigation-20968cc5.js", "/./_app/chunks/singletons-bb9012b7.js", "/./_app/chunks/auth-c13ad024.js", "/./_app/chunks/store-97111950.js", "/./_app/chunks/store-b327666d.js", "/./_app/chunks/store-a8f0f898.js", "/./_app/chunks/Input-ac9b94d3.js", "/./_app/chunks/Section-69710e66.js"], "styles": null }, "src/routes/hr/safety/index.svelte": { "entry": "/./_app/pages/hr/safety/index.svelte-afc4b8ac.js", "css": ["/./_app/assets/vendor-774ad079.css"], "js": ["/./_app/pages/hr/safety/index.svelte-afc4b8ac.js", "/./_app/chunks/vendor-483ca6b6.js"], "styles": null } };
async function load_component(file) {
  return __spreadValues({
    module: await module_lookup[file]()
  }, metadata_lookup[file]);
}
init({ paths: { "base": "", "assets": "/." } });
function render(request, {
  prerender
} = {}) {
  const host2 = request.headers["host"];
  return respond(__spreadProps(__spreadValues({}, request), { host: host2 }), options$1, { prerender });
}
var { MongoClient } = import_mongodb.default;
var uri = "mongodb+srv://bobmcaleavey:Superma3+@cluster0.0f8ym.mongodb.net/development?retryWrites=true&w=majority";
var options = { useUnifiedTopology: true };
var client = new MongoClient(uri, options);
var connection;
var connect = async () => {
  if (connection === void 0)
    connection = await client.connect();
  return client;
};
var { ObjectId: ObjectId$4 } = import_mongodb.default;
async function del$1({ params, query }) {
  const client2 = await connect();
  const { slug: collection } = params;
  query = Object.fromEntries(query);
  if ("_id" in query)
    query._id = ObjectId$4(query._id);
  console.log(query);
  await client2.db().collection(collection).findOneAndDelete(query);
  return {
    status: 200,
    body: {}
  };
}
async function get$1({ params, query }) {
  const client2 = await connect();
  const { slug: collection } = params;
  let sort = {};
  query = Object.fromEntries(query);
  if ("_id" in query)
    query._id = ObjectId$4(query._id);
  if ("sort" in query) {
    sort = JSON.parse(query.sort);
    delete query.sort;
  }
  let rows = await client2.db().collection(collection).find(query).collation({ locale: "en" }).sort(sort).toArray();
  if (collection === "users")
    rows = rows.map((row) => {
      delete row.password;
      return row;
    });
  return {
    status: 200,
    body: {
      rows
    }
  };
}
async function patch({ body, params, query }) {
  const client2 = await connect();
  const { slug: collection } = params;
  query = Object.fromEntries(query);
  if ("_id" in query)
    query._id = ObjectId$4(query._id);
  const doc = await client2.db().collection(collection).findOneAndUpdate(query, { $set: body }, { returnOriginal: false });
  return {
    status: 200,
    body: {
      doc: doc.value
    }
  };
}
async function post$5({ body, params }) {
  const client2 = await connect();
  const { slug: collection } = params;
  console.log(body);
  const doc = await client2.db().collection(collection).insertOne(body);
  return {
    status: 200,
    body: {
      doc
    }
  };
}
var _slug_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  del: del$1,
  get: get$1,
  patch,
  post: post$5
});
var { ObjectId: ObjectId$3 } = import_mongodb.default;
async function del({ body }) {
  const client2 = await connect();
  await Promise.all(body.map(async (_id) => {
    await client2.db().collection("routes").findOneAndDelete({ _id: ObjectId$3(_id) });
  }));
  return {
    status: 200,
    body: {}
  };
}
async function get() {
  const client2 = await connect();
  const routes = await client2.db().collection("routes").find().collation({ locale: "en" }).sort({ name: 1 }).toArray();
  return {
    status: 200,
    body: {
      routes
    }
  };
}
var datatable = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  del,
  get
});
var { ObjectId: ObjectId$2 } = import_mongodb.default;
async function post$4({ body }) {
  const client2 = await connect();
  let { accessToken: accessToken2, currentPassword, password } = body;
  const decoded = import_jsonwebtoken.default.verify(accessToken2, "Ennis01+");
  let { _id } = decoded;
  _id = ObjectId$2(_id);
  const user = await client2.db().collection("users").findOne({ _id });
  const compare = await import_bcryptjs.default.compare(currentPassword, user.password);
  if (!compare) {
    return {
      status: 403,
      body: {
        error: "Creditials could not be verified.  Please try again"
      }
    };
  } else {
    password = await import_bcryptjs.default.hash(password, 10);
    status = "Active";
    const doc = await client2.db().collection("users").findOneAndUpdate({ _id }, { $set: { password, status } });
    const { value: user2 } = doc;
    delete user2.password;
    return {
      status: 200,
      body: { user: user2 }
    };
  }
}
var changepassword = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$4
});
async function post$3({ body }) {
  const client2 = await connect();
  let { email, password } = body;
  const user = await client2.db().collection("users").findOne({ email });
  const compare = await import_bcryptjs.default.compare(password, user.password);
  if (!compare) {
    return {
      status: 403,
      body: {
        error: "Creditials could not be verified.  Please try again"
      }
    };
  } else {
    const { _id } = user;
    const accessToken2 = import_jsonwebtoken.default.sign({ _id }, "Ennis01+");
    return {
      status: 200,
      body: { accessToken: accessToken2 }
    };
  }
}
var signin = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$3
});
async function post$2({ body }) {
  const client2 = await connect();
  const defaults = {
    extension: "",
    on: {
      signin: "/dashboard"
    },
    roles: [],
    status: "Unverified"
  };
  body = Object.assign(defaults, body);
  let { email, extension, password, firstName, lastName, on, roles, status: status2 } = body;
  password = await import_bcryptjs.default.hash(password, 10);
  const insert = await client2.db().collection("users").insertOne({ email, extension, password, firstName, lastName, on, roles, status: status2 });
  const user = insert.ops[0];
  const { _id } = user;
  const accessToken2 = import_jsonwebtoken.default.sign({ _id }, "Ennis01+");
  return {
    status: 200,
    body: { accessToken: accessToken2 }
  };
}
var signup = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$2
});
var { ObjectId: ObjectId$1 } = import_mongodb.default;
async function post$1({ body }) {
  const client2 = await connect();
  let { accessToken: accessToken2 } = body;
  const decoded = import_jsonwebtoken.default.verify(accessToken2, "Ennis01+");
  let { _id } = decoded;
  _id = ObjectId$1(_id);
  const user = await client2.db().collection("users").findOne({ _id });
  const { on: { signin: signin2 } } = user;
  return {
    status: 200,
    body: { route: signin2 }
  };
}
var signinroute = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post: post$1
});
var { ObjectId } = import_mongodb.default;
async function post({ body }) {
  const client2 = await connect();
  let { accessToken: accessToken2 } = body;
  const decoded = import_jsonwebtoken.default.verify(accessToken2, "Ennis01+");
  let { _id } = decoded;
  _id = ObjectId(_id);
  const user = await client2.db().collection("users").findOne({ _id });
  const { roles } = user;
  let routes = [];
  const routeHash = {};
  await Promise.all(roles.map(async (name2) => {
    const role = await client2.db().collection("roles").findOne({ name: name2 });
    const { routes: roleRoutes } = role;
    roleRoutes.forEach((route) => {
      if (!(route._id in routeHash)) {
        routeHash[route._id] = true;
        delete route._id;
        routes.push(route);
      }
    });
  }));
  return {
    status: 200,
    body: { routes }
  };
}
var userroutes = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  post
});
function guard(name2) {
  return () => {
    throw new Error(`Cannot call ${name2}(...) on the server`);
  };
}
var goto = guard("goto");
var getStores = () => {
  const stores = getContext("__svelte__");
  return {
    page: {
      subscribe: stores.page.subscribe
    },
    navigating: {
      subscribe: stores.navigating.subscribe
    },
    get preloading() {
      console.error("stores.preloading is deprecated; use stores.navigating instead");
      return {
        subscribe: stores.navigating.subscribe
      };
    },
    session: stores.session
  };
};
var page = {
  subscribe(fn) {
    const store = getStores().page;
    return store.subscribe(fn);
  }
};
var serverFetch = async (params) => {
  let body, href, method;
  if (typeof params === "string") {
    href = params;
    method = "GET";
  } else {
    body = params.body;
    href = params.href;
    method = params.method;
  }
  let options2 = { method };
  if (method.toUpperCase() !== "GET") {
    options2.body = JSON.stringify(body);
    options2.headers = {
      "Accept": "application/json",
      "Content-Type": "application/json"
    };
  }
  const response = await (void 0)(href, options2);
  const data = await response.json();
  return data;
};
var localStorageStore = (key, initialValue = null) => {
  let value;
  if (typeof localStorage !== "undefined") {
    value = JSON.parse(localStorage.getItem(key) || JSON.stringify(initialValue));
  } else {
    value = [];
  }
  const { set: set2, subscribe: subscribe22, update: update2 } = writable2(value);
  if (typeof localStorage !== "undefined") {
    subscribe22((v) => {
      localStorage.setItem(key, JSON.stringify(v));
    });
  }
  const is = {
    signedin: () => {
      let signedin;
      subscribe22((state) => signedin = JSON.stringify(state) === "{}" ? false : true);
      return signedin;
    }
  };
  const on = {
    signin: () => {
      let route;
      subscribe22((state) => {
        var _a;
        return route = (_a = state == null ? void 0 : state.on) == null ? void 0 : _a.signin;
      });
      return route;
    }
  };
  const signin2 = async (body) => {
    const data = await serverFetch({ method: "POST", href: "/api/auth/signin", body });
    if (data.accessToken)
      update2(() => data.accessToken);
    if (data.error)
      update2(() => {
        return null;
      });
    return data;
  };
  const signout = () => {
    update2(() => {
      return null;
    });
  };
  return {
    is,
    on,
    signin: signin2,
    signout,
    subscribe: subscribe22
  };
};
var accessToken = localStorageStore("accessToken", null);
var getRoutes = async (accessToken2) => {
  const data = await serverFetch({ method: "POST", href: "/api/auth/get/userroutes", body: { accessToken: accessToken2 } });
  return data.routes;
};
var Icon$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  var _a, _b;
  let { src: src3 = [] } = $$props;
  let { size = "100%" } = $$props;
  let { solid = false } = $$props;
  let { class: customClass = "" } = $$props;
  if (size !== "100%") {
    if (size.slice(-1) != "x" && size.slice(-1) != "m" && size.slice(-1) != "%") {
      try {
        size = parseInt(size) + "px";
      } catch (error22) {
        size = "100%";
      }
    }
  }
  if ($$props.src === void 0 && $$bindings.src && src3 !== void 0)
    $$bindings.src(src3);
  if ($$props.size === void 0 && $$bindings.size && size !== void 0)
    $$bindings.size(size);
  if ($$props.solid === void 0 && $$bindings.solid && solid !== void 0)
    $$bindings.solid(solid);
  if ($$props.class === void 0 && $$bindings.class && customClass !== void 0)
    $$bindings.class(customClass);
  return `${src3 && src3 != [] ? `${solid ? `<svg xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 20 20"}" fill="${"currentColor"}" class="${"heroicon solid " + escape2(customClass)}"${add_attribute("width", size, 0)}${add_attribute("height", size, 0)}>${each((_a = src3[0]) != null ? _a : [], (att) => `
        <path${spread([escape_object(att)])}></path>`)}</svg>` : `<svg xmlns="${"http://www.w3.org/2000/svg"}" fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}" class="${"heroicon outline " + escape2(customClass)}"${add_attribute("width", size, 0)}${add_attribute("height", size, 0)}>${each((_b = src3[1]) != null ? _b : [], (att) => `
        <path${spread([escape_object(att)])}></path>`)}</svg>`}` : ``}`;
});
var Check = [
  [
    {
      "fill-rule": "evenodd",
      d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M5 13l4 4L19 7"
    }
  ]
];
var ChevronDown = [
  [
    {
      "fill-rule": "evenodd",
      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M19 9l-7 7-7-7"
    }
  ]
];
var ChevronLeft = [
  [
    {
      "fill-rule": "evenodd",
      d: "M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 19l-7-7 7-7"
    }
  ]
];
var Exclamation = [
  [
    {
      "fill-rule": "evenodd",
      d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
    }
  ]
];
var Pencil = [
  [
    {
      d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
    }
  ]
];
var Plus = [
  [
    {
      "fill-rule": "evenodd",
      d: "M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M12 6v6m0 0v6m0-6h6m-6 0H6"
    }
  ]
];
var Save = [
  [
    {
      d: "M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6h5a2 2 0 012 2v7a2 2 0 01-2 2H4a2 2 0 01-2-2V8a2 2 0 012-2h5v5.586l-1.293-1.293zM9 4a1 1 0 012 0v2H9V4z"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"
    }
  ]
];
var ThumbUp = [
  [
    {
      d: "M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333v5.43a2 2 0 001.106 1.79l.05.025A4 4 0 008.943 18h5.416a2 2 0 001.962-1.608l1.2-6A2 2 0 0015.56 8H12V4a2 2 0 00-2-2 1 1 0 00-1 1v.667a4 4 0 01-.8 2.4L6.8 7.933a4 4 0 00-.8 2.4z"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L7 11v9m7-10h-2M7 20H5a2 2 0 01-2-2v-6a2 2 0 012-2h2.5"
    }
  ]
];
var Trash = [
  [
    {
      "fill-rule": "evenodd",
      d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
      "clip-rule": "evenodd"
    }
  ],
  [
    {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
    }
  ]
];
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { containerClasses = "border-gray border-opacity-30 border-b-[1px]" } = $$props;
  let { descriptionClasses = "text-gray leading-[30px] py-[18px]" } = $$props;
  let { handleClasses = "py-[21px] lg:py-[20px]" } = $$props;
  let { items = [
    {
      title: "Item 1",
      description: "Description",
      visible: false
    },
    {
      title: "Item 2",
      description: "Description",
      visible: false
    },
    {
      title: "Item ",
      description: "Description",
      visible: false
    }
  ] } = $$props;
  if ($$props.containerClasses === void 0 && $$bindings.containerClasses && containerClasses !== void 0)
    $$bindings.containerClasses(containerClasses);
  if ($$props.descriptionClasses === void 0 && $$bindings.descriptionClasses && descriptionClasses !== void 0)
    $$bindings.descriptionClasses(descriptionClasses);
  if ($$props.handleClasses === void 0 && $$bindings.handleClasses && handleClasses !== void 0)
    $$bindings.handleClasses(handleClasses);
  if ($$props.items === void 0 && $$bindings.items && items !== void 0)
    $$bindings.items(items);
  return `${each(items, ({ title, description, visible }) => `<div class="${"flex flex-col " + escape2(containerClasses)}"><div class="${"flex justify-between items-center cursor-pointer " + escape2(handleClasses)}"><div>${escape2(title)}</div>
      ${validate_component(Icon$1, "Icon").$$render($$result, {
    src: ChevronDown,
    class: "transform transition duration-200 " + (visible ? "rotate-180 text-red" : "rotate-0 text-primary")
  }, {}, {})}</div>
    ${visible ? `<div${add_attribute("class", descriptionClasses, 0)}>${escape2(description)}</div>` : ``}
  </div>`)}`;
});
var Button = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let themeClasses;
  let classes;
  let { bgOpacity = "bg-opacity-100" } = $$props;
  let { boxShadow = "" } = $$props;
  let { fontWeight = "font-bold" } = $$props;
  let { href = "#" } = $$props;
  let { outline = "outline-none focus:outline-none" } = $$props;
  let { padding = "px-[30px] py-[11px]" } = $$props;
  let { ring = "ring ring-opacity-0 focus:ring-opacity-30" } = $$props;
  let { rounded = "rounded" } = $$props;
  let { textAlign = "text-center" } = $$props;
  let { textColor = "" } = $$props;
  let { textSize = "" } = $$props;
  let { theme = "default" } = $$props;
  let { transition: transition2 = "transition duration-200" } = $$props;
  let { type = "" } = $$props;
  let { style: style2 = "" } = $$props;
  let { whitespace = "whitespace-nowrap" } = $$props;
  if ($$props.bgOpacity === void 0 && $$bindings.bgOpacity && bgOpacity !== void 0)
    $$bindings.bgOpacity(bgOpacity);
  if ($$props.boxShadow === void 0 && $$bindings.boxShadow && boxShadow !== void 0)
    $$bindings.boxShadow(boxShadow);
  if ($$props.fontWeight === void 0 && $$bindings.fontWeight && fontWeight !== void 0)
    $$bindings.fontWeight(fontWeight);
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.outline === void 0 && $$bindings.outline && outline !== void 0)
    $$bindings.outline(outline);
  if ($$props.padding === void 0 && $$bindings.padding && padding !== void 0)
    $$bindings.padding(padding);
  if ($$props.ring === void 0 && $$bindings.ring && ring !== void 0)
    $$bindings.ring(ring);
  if ($$props.rounded === void 0 && $$bindings.rounded && rounded !== void 0)
    $$bindings.rounded(rounded);
  if ($$props.textAlign === void 0 && $$bindings.textAlign && textAlign !== void 0)
    $$bindings.textAlign(textAlign);
  if ($$props.textColor === void 0 && $$bindings.textColor && textColor !== void 0)
    $$bindings.textColor(textColor);
  if ($$props.textSize === void 0 && $$bindings.textSize && textSize !== void 0)
    $$bindings.textSize(textSize);
  if ($$props.theme === void 0 && $$bindings.theme && theme !== void 0)
    $$bindings.theme(theme);
  if ($$props.transition === void 0 && $$bindings.transition && transition2 !== void 0)
    $$bindings.transition(transition2);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.style === void 0 && $$bindings.style && style2 !== void 0)
    $$bindings.style(style2);
  if ($$props.whitespace === void 0 && $$bindings.whitespace && whitespace !== void 0)
    $$bindings.whitespace(whitespace);
  {
    if (type === "icon") {
      padding = "p-[11px]";
    }
  }
  themeClasses = theme === "default" ? "bg-primary-500 ring-primary-500 text-gray-900 hover:bg-primary-600" : theme === "secondary" ? "bg-purple-500 ring-purple-500 text-gray-900 hover:bg-purple-600" : theme === "error" ? "bg-red-500 ring-red-500 text-gray-900 hover:bg-red-600" : theme === "success" ? "bg-green-500 ring-green-500 text-gray-900 hover:bg-green-600" : "";
  classes = `${bgOpacity} ${boxShadow} ${fontWeight} ${outline} ${padding} ${ring} ${rounded} ${textAlign} ${textColor} ${textSize} ${themeClasses} ${transition2} ${whitespace} ${$$props.class !== void 0 ? $$props.class : ""}`;
  return `${type === "link" ? `<a${add_attribute("href", href, 0)}${add_attribute("class", classes, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}>${slots.default ? slots.default({}) : ``}</a>` : `${type === "submit" ? `<button type="${"submit"}"${add_attribute("class", classes, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}>${slots.default ? slots.default({}) : ``}</button>` : `<button${add_attribute("class", classes, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}>${slots.default ? slots.default({}) : `Button`}</button>`}`}`;
});
var Back = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Button, "Button").$$render($$result, { padding: "p-[11px]" }, {}, {
    default: () => `${validate_component(Icon$1, "Icon").$$render($$result, {
      src: ChevronLeft,
      class: "w-[24px] h-[24px]"
    }, {}, {})}`
  })}`;
});
var Icon = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { href = "" } = $$props;
  let { theme = "default" } = $$props;
  let { type = "link" } = $$props;
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.theme === void 0 && $$bindings.theme && theme !== void 0)
    $$bindings.theme(theme);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  return `${validate_component(Button, "Button").$$render($$result, { padding: "p-[6px]", href, theme, type }, {}, {
    default: () => `${slots.default ? slots.default({}) : ``}`
  })}`;
});
var Card = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { theme = "default" } = $$props;
  if ($$props.theme === void 0 && $$bindings.theme && theme !== void 0)
    $$bindings.theme(theme);
  classes = {
    bg: "bg-white bg-opacity-[1%]",
    filter: "backdrop-filter backdrop-blur-md",
    flex: "flex flex-col",
    padding: "p-[20px]",
    position: "relative",
    ring: "ring ring-1 ring-white ring-opacity-[2%] ring-inset",
    rounded: "rounded",
    shadow: "shadow-xl",
    themeClasses: theme === "default" ? "" : ""
  };
  return `<div${add_attribute("class", Object.values(classes).join(" ") + " " + $$props.class, 0)}>${slots.default ? slots.default({}) : ``}</div>`;
});
var Checkbox = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { checked = false } = $$props;
  let { indeterminate = false } = $$props;
  if ($$props.checked === void 0 && $$bindings.checked && checked !== void 0)
    $$bindings.checked(checked);
  if ($$props.indeterminate === void 0 && $$bindings.indeterminate && indeterminate !== void 0)
    $$bindings.indeterminate(indeterminate);
  classes = `relative focus-within:ring-opacity-10 flex cursor-pointer transition duration-200 rounded ring ring-opacity-0 ${checked || indeterminate ? "bg-primary-500 ring-primary-500 text-gray-900 focus-within:ring-opacity-30" : "bg-transparent ring-white ring-offset ring-offset-1 ring-offset-gray-400 hover:ring-offset-gray-200"}`;
  return `<label${add_attribute("class", classes, 0)}><input type="${"checkbox"}" class="${"absolute top-0 left-0 w-0 opacity-0"}"${add_attribute("checked", checked, 1)}${add_attribute("indeterminate", indeterminate, 1)}>
  ${checked ? `${validate_component(Icon$1, "Icon").$$render($$result, {
    src: Check,
    class: "w-[24px] h-[24px] pointer-events-none"
  }, {}, {})}` : `${indeterminate ? `<div class="${"w-[24px] h-[24px]"}">-</div>` : `<div class="${"w-[24px] h-[24px] pointer-events-none"}"></div>`}`}</label>`;
});
var Container = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { margin = "mx-auto" } = $$props;
  let { padding = "px-[24px]" } = $$props;
  let { width: width2 = "w-full lg:w-[1158px]" } = $$props;
  if ($$props.margin === void 0 && $$bindings.margin && margin !== void 0)
    $$bindings.margin(margin);
  if ($$props.padding === void 0 && $$bindings.padding && padding !== void 0)
    $$bindings.padding(padding);
  if ($$props.width === void 0 && $$bindings.width && width2 !== void 0)
    $$bindings.width(width2);
  return `<div class="${escape2(margin) + " " + escape2(padding) + " " + escape2(width2) + " " + escape2($$props.class !== void 0 ? $$props.class : "")}">${slots.default ? slots.default({}) : ``}</div>`;
});
var Cross = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<svg${spread([escape_object($$props), { viewBox: "0 0 20 20" }, { fill: "currentColor" }])}><path d="${"M10 1.6a8.4 8.4 0 100 16.8 8.4 8.4 0 000-16.8zm4.789 11.461L13.06 14.79 10 11.729l-3.061 3.06L5.21 13.06 8.272 10 5.211 6.939 6.94 5.211 10 8.271l3.061-3.061 1.729 1.729L11.728 10l3.061 3.061z"}"></path></svg>`;
});
var ChevronExpand = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<svg${spread([escape_object($$props), { fill: "currentColor" }, { viewBox: "0 0 16 16" }])}><path fill-rule="${"evenodd"}" d="${"M3.646 9.146a.5.5 0 0 1 .708 0L8 12.793l3.646-3.647a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 0-.708zm0-2.292a.5.5 0 0 0 .708 0L8 3.207l3.646 3.647a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 0 0 0 .708z"}"></path></svg>`;
});
var ReadOnly = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<svg${spread([escape_object($$props), { viewBox: "0 0 24 24" }, { fill: "currentColor" }])}><path fill="${"none"}" d="${"M0 0h24v24H0V0z"}"></path><path d="${"M14.48 11.95c.17.02.34.05.52.05 2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4c0 .18.03.35.05.52l3.43 3.43zm2.21 2.21L22.53 20H23v-2c0-2.14-3.56-3.5-6.31-3.84zM0 3.12l4 4V10H1v2h3v3h2v-3h2.88l2.51 2.51C9.19 15.11 7 16.3 7 18v2h9.88l4 4 1.41-1.41L1.41 1.71 0 3.12zM6.88 10H6v-.88l.88.88z"}"></path></svg>`;
});
var css = {
  code: ".multiselect.svelte-54s7ya.svelte-54s7ya{align-items:center;border:var(--sms-border,1pt solid #d3d3d3);border-radius:var(--sms-border-radius,5pt);cursor:text;display:flex;margin:1em 0;min-height:18pt;position:relative}.multiselect.svelte-54s7ya.svelte-54s7ya:focus-within{border:var(--sms-focus-border,1pt solid var(--sms-active-color,#6495ed))}.multiselect.readonly.svelte-54s7ya.svelte-54s7ya{background:var(--sms-readonly-bg,#d3d3d3)}ul.tokens.svelte-54s7ya>li.svelte-54s7ya{align-items:center;background:var(--sms-token-bg,var(--sms-active-color,#6495ed));border-radius:4pt;display:flex;height:16pt;margin:2pt;padding:0 0 0 1ex;transition:.3s;white-space:nowrap}button.remove-all.svelte-54s7ya.svelte-54s7ya,ul.tokens.svelte-54s7ya>li button.svelte-54s7ya{align-items:center;border-radius:50%;cursor:pointer;display:flex;transition:.2s}button.remove-all.svelte-54s7ya.svelte-54s7ya:hover,ul.tokens.svelte-54s7ya>li button.svelte-54s7ya:hover{color:var(--sms-remove-x-hover-color,#d3d3d3)}button.svelte-54s7ya.svelte-54s7ya{background:transparent;border:none;color:inherit;cursor:pointer;outline:none;padding:0 2pt}.multiselect.svelte-54s7ya input.svelte-54s7ya{background:none;border:none;box-shadow:none;color:var(--sms-text-color,inherit);flex:1;outline:none;width:1pt}ul.tokens.svelte-54s7ya.svelte-54s7ya{display:flex;flex:1;flex-wrap:wrap;margin:0;padding:0}ul.options.svelte-54s7ya.svelte-54s7ya{background:var(--sms-options-bg,#fff);border-radius:1ex;cursor:pointer;list-style:none;max-height:50vh;overflow:auto;padding:0;position:absolute;top:100%;width:100%}ul.options.hidden.svelte-54s7ya.svelte-54s7ya{visibility:hidden}ul.options.svelte-54s7ya li.svelte-54s7ya{padding:3pt 2ex}ul.options.svelte-54s7ya li.selected.svelte-54s7ya{background:var(--sms-li-selected-bg,inherit);border-left:var(\n      --sms-li-selected-border-left,3pt solid var(--sms-selected-color,green)\n    );color:var(--sms-li-selected-color,inherit)}ul.options.svelte-54s7ya li.svelte-54s7ya:not(.selected):hover{border-left:3pt solid var(--blue)}ul.options.svelte-54s7ya li.active.svelte-54s7ya{background:var(--sms-li-active-bg,var(--sms-active-color,#6495ed))}",
  map: '{"version":3,"file":"MultiSelect.svelte","sources":["MultiSelect.svelte"],"sourcesContent":["<script>\\n  import { createEventDispatcher } from \'svelte\'\\n  import { fly } from \'svelte/transition\'\\n\\n  import CrossIcon from \'./icons/Cross.svelte\'\\n  import ExpandIcon from \'./icons/ChevronExpand.svelte\'\\n  import ReadOnlyIcon from \'./icons/ReadOnly.svelte\'\\n\\n  export let selected\\n  export let maxSelect = null\\n  export let readonly = false\\n  export let placeholder = ``\\n  export let options\\n  export let input = undefined\\n  export let noOptionsMsg = `No matching options`\\n\\n  export let outerDivClass = ``\\n  export let ulTokensClass = ``\\n  export let liTokenClass = ``\\n  export let ulOptionsClass = ``\\n  export let liOptionClass = ``\\n\\n  export let removeBtnTitle = `Remove`\\n  export let removeAllTitle = `Remove all`\\n\\n  if (maxSelect !== null && maxSelect < 0) {\\n    throw new TypeError(`maxSelect must be null or positive integer, got ${maxSelect}`)\\n  }\\n  $: single = maxSelect === 1\\n  if (!selected) selected = single ? `` : []\\n\\n  if (!options?.length > 0) console.error(`MultiSelect missing options`)\\n\\n  const dispatch = createEventDispatcher()\\n  let activeOption, searchText\\n  let showOptions = false\\n\\n  $: filteredOptions = searchText\\n    ? options.filter((option) => option.toLowerCase().includes(searchText.toLowerCase()))\\n    : options\\n  $: if (\\n    (activeOption && !filteredOptions.includes(activeOption)) ||\\n    (!activeOption && searchText)\\n  )\\n    activeOption = filteredOptions[0]\\n\\n  function add(token) {\\n    if (\\n      !readonly &&\\n      !selected.includes(token) &&\\n      // (... || single) because in single mode, we always replace current token with new selection\\n      (maxSelect === null || selected.length < maxSelect || single)\\n    ) {\\n      searchText = `` // reset search string on selection\\n      selected = single ? token : [token, ...selected]\\n      if (\\n        (Array.isArray(selected) && selected.length === maxSelect) ||\\n        typeof selected === `string`\\n      ) {\\n        setOptionsVisible(false)\\n        input.blur()\\n      }\\n      dispatch(`add`, { token })\\n    }\\n  }\\n\\n  function remove(token) {\\n    if (readonly || single) return\\n    selected = selected.filter((item) => item !== token)\\n    dispatch(`remove`, { token })\\n  }\\n\\n  function setOptionsVisible(show) {\\n    // nothing to do if visible is already as intended\\n    if (readonly || show === showOptions) return\\n    showOptions = show\\n    if (show) input.focus()\\n    else activeOption = undefined\\n  }\\n\\n  function handleKeydown(event) {\\n    if (event.key === `Escape`) {\\n      setOptionsVisible(false)\\n      searchText = ``\\n    } else if (event.key === `Enter`) {\\n      if (activeOption) {\\n        selected.includes(activeOption) ? remove(activeOption) : add(activeOption)\\n        searchText = ``\\n      } // no active option means the options are closed in which case enter means open\\n      else setOptionsVisible(true)\\n    } else if ([`ArrowDown`, `ArrowUp`].includes(event.key)) {\\n      const increment = event.key === `ArrowUp` ? -1 : 1\\n      const newActiveIdx = filteredOptions.indexOf(activeOption) + increment\\n\\n      if (newActiveIdx < 0) {\\n        activeOption = filteredOptions[filteredOptions.length - 1]\\n      } else {\\n        if (newActiveIdx === filteredOptions.length) activeOption = filteredOptions[0]\\n        else activeOption = filteredOptions[newActiveIdx]\\n      }\\n    } else if (event.key === `Backspace`) {\\n      // only remove selected tags on backspace if if there are any and no searchText characters remain\\n      if (selected.length > 0 && searchText.length === 0) {\\n        selected = selected.slice(0, selected.length - 1)\\n      }\\n    }\\n  }\\n\\n  const removeAll = () => {\\n    selected = single ? `` : []\\n    searchText = ``\\n  }\\n\\n  $: isSelected = (option) => {\\n    if (!(selected?.length > 0)) return false // nothing is selected if `selected` is the empty array or string\\n    if (single) return selected === option\\n    else return selected.includes(option)\\n  }\\n<\/script>\\n\\n<!-- z-index: 2 when showOptions is ture ensures the ul.tokens of one <MultiSelect /> display above those of another following shortly after it -->\\n<div\\n  class=\\"multiselect {outerDivClass}\\"\\n  class:readonly\\n  class:single\\n  style={showOptions ? `z-index: 2;` : ``}\\n  on:mouseup|stopPropagation={() => setOptionsVisible(true)}>\\n  <ExpandIcon height=\\"14pt\\" style=\\"padding-left: 1pt;\\" />\\n  <ul class=\\"tokens {ulTokensClass}\\">\\n    {#if single}\\n      <span on:mouseup|self|stopPropagation={() => setOptionsVisible(true)}>\\n        {selected}\\n      </span>\\n    {:else if selected?.length > 0}\\n      {#each selected as tag}\\n        <li\\n          class={liTokenClass}\\n          on:mouseup|self|stopPropagation={() => setOptionsVisible(true)}>\\n          {tag}\\n          {#if !readonly}\\n            <button\\n              on:mouseup|stopPropagation={() => remove(tag)}\\n              type=\\"button\\"\\n              title=\\"{removeBtnTitle} {tag}\\">\\n              <CrossIcon height=\\"12pt\\" />\\n            </button>\\n          {/if}\\n        </li>\\n      {/each}\\n    {/if}\\n    <input\\n      bind:this={input}\\n      autocomplete=\\"off\\"\\n      bind:value={searchText}\\n      on:mouseup|self|stopPropagation={() => setOptionsVisible(true)}\\n      on:keydown={handleKeydown}\\n      on:focus={() => setOptionsVisible(true)}\\n      on:blur={() => dispatch(`blur`)}\\n      on:blur={() => setOptionsVisible(false)}\\n      placeholder={selected.length ? `` : placeholder} />\\n  </ul>\\n  {#if readonly}\\n    <ReadOnlyIcon height=\\"14pt\\" />\\n  {:else}\\n    <button\\n      type=\\"button\\"\\n      class=\\"remove-all\\"\\n      title={removeAllTitle}\\n      on:mouseup|stopPropagation={removeAll}\\n      style={selected.length === 0 ? `display: none;` : ``}>\\n      <CrossIcon height=\\"14pt\\" />\\n    </button>\\n  {/if}\\n\\n  {#key showOptions}\\n    <ul\\n      class=\\"options {ulOptionsClass}\\"\\n      class:hidden={!showOptions}\\n      transition:fly={{ duration: 300, y: 40 }}>\\n      {#each filteredOptions as option}\\n        <li\\n          on:mouseup|preventDefault|stopPropagation\\n          on:mousedown|preventDefault|stopPropagation={() =>\\n            isSelected(option) ? remove(option) : add(option)}\\n          class:selected={isSelected(option)}\\n          class:active={activeOption === option}\\n          class={liOptionClass}>\\n          {option}\\n        </li>\\n      {:else}\\n        {noOptionsMsg}\\n      {/each}\\n    </ul>\\n  {/key}\\n</div>\\n\\n<style>.multiselect{align-items:center;border:var(--sms-border,1pt solid #d3d3d3);border-radius:var(--sms-border-radius,5pt);cursor:text;display:flex;margin:1em 0;min-height:18pt;position:relative}.multiselect:focus-within{border:var(--sms-focus-border,1pt solid var(--sms-active-color,#6495ed))}.multiselect.readonly{background:var(--sms-readonly-bg,#d3d3d3)}ul.tokens>li{align-items:center;background:var(--sms-token-bg,var(--sms-active-color,#6495ed));border-radius:4pt;display:flex;height:16pt;margin:2pt;padding:0 0 0 1ex;transition:.3s;white-space:nowrap}button.remove-all,ul.tokens>li button{align-items:center;border-radius:50%;cursor:pointer;display:flex;transition:.2s}button.remove-all:hover,ul.tokens>li button:hover{color:var(--sms-remove-x-hover-color,#d3d3d3)}button{background:transparent;border:none;color:inherit;cursor:pointer;outline:none;padding:0 2pt}.multiselect input{background:none;border:none;box-shadow:none;color:var(--sms-text-color,inherit);flex:1;outline:none;width:1pt}ul.tokens{display:flex;flex:1;flex-wrap:wrap;margin:0;padding:0}ul.options{background:var(--sms-options-bg,#fff);border-radius:1ex;cursor:pointer;list-style:none;max-height:50vh;overflow:auto;padding:0;position:absolute;top:100%;width:100%}ul.options.hidden{visibility:hidden}ul.options li{padding:3pt 2ex}ul.options li.selected{background:var(--sms-li-selected-bg,inherit);border-left:var(\\n      --sms-li-selected-border-left,3pt solid var(--sms-selected-color,green)\\n    );color:var(--sms-li-selected-color,inherit)}ul.options li:not(.selected):hover{border-left:3pt solid var(--blue)}ul.options li.active{background:var(--sms-li-active-bg,var(--sms-active-color,#6495ed))}</style>\\n"],"names":[],"mappings":"AAoMO,wCAAY,CAAC,YAAY,MAAM,CAAC,OAAO,IAAI,YAAY,CAAC,iBAAiB,CAAC,CAAC,cAAc,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC,OAAO,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,SAAS,QAAQ,CAAC,wCAAY,aAAa,CAAC,OAAO,IAAI,kBAAkB,CAAC,yCAAyC,CAAC,CAAC,YAAY,qCAAS,CAAC,WAAW,IAAI,iBAAiB,CAAC,OAAO,CAAC,CAAC,EAAE,qBAAO,CAAC,gBAAE,CAAC,YAAY,MAAM,CAAC,WAAW,IAAI,cAAc,CAAC,+BAA+B,CAAC,CAAC,cAAc,GAAG,CAAC,QAAQ,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,GAAG,CAAC,YAAY,MAAM,CAAC,MAAM,uCAAW,CAAC,EAAE,qBAAO,CAAC,EAAE,CAAC,oBAAM,CAAC,YAAY,MAAM,CAAC,cAAc,GAAG,CAAC,OAAO,OAAO,CAAC,QAAQ,IAAI,CAAC,WAAW,GAAG,CAAC,MAAM,uCAAW,MAAM,CAAC,EAAE,qBAAO,CAAC,EAAE,CAAC,oBAAM,MAAM,CAAC,MAAM,IAAI,0BAA0B,CAAC,OAAO,CAAC,CAAC,kCAAM,CAAC,WAAW,WAAW,CAAC,OAAO,IAAI,CAAC,MAAM,OAAO,CAAC,OAAO,OAAO,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,0BAAY,CAAC,mBAAK,CAAC,WAAW,IAAI,CAAC,OAAO,IAAI,CAAC,WAAW,IAAI,CAAC,MAAM,IAAI,gBAAgB,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,QAAQ,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,mCAAO,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,CAAC,UAAU,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,oCAAQ,CAAC,WAAW,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC,cAAc,GAAG,CAAC,OAAO,OAAO,CAAC,WAAW,IAAI,CAAC,WAAW,IAAI,CAAC,SAAS,IAAI,CAAC,QAAQ,CAAC,CAAC,SAAS,QAAQ,CAAC,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,QAAQ,mCAAO,CAAC,WAAW,MAAM,CAAC,EAAE,sBAAQ,CAAC,gBAAE,CAAC,QAAQ,GAAG,CAAC,GAAG,CAAC,EAAE,sBAAQ,CAAC,EAAE,uBAAS,CAAC,WAAW,IAAI,oBAAoB,CAAC,OAAO,CAAC,CAAC,YAAY;MACt2C,6BAA6B,CAAC;IAChC,CAAC,CAAC,MAAM,IAAI,uBAAuB,CAAC,OAAO,CAAC,CAAC,EAAE,sBAAQ,CAAC,gBAAE,KAAK,SAAS,CAAC,MAAM,CAAC,YAAY,GAAG,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,CAAC,EAAE,sBAAQ,CAAC,EAAE,qBAAO,CAAC,WAAW,IAAI,kBAAkB,CAAC,+BAA+B,CAAC,CAAC"}'
};
var MultiSelect = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let single;
  let filteredOptions;
  let isSelected;
  let { selected } = $$props;
  let { maxSelect = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = `` } = $$props;
  let { options: options2 } = $$props;
  let { input = void 0 } = $$props;
  let { noOptionsMsg = `No matching options` } = $$props;
  let { outerDivClass = `` } = $$props;
  let { ulTokensClass = `` } = $$props;
  let { liTokenClass = `` } = $$props;
  let { ulOptionsClass = `` } = $$props;
  let { liOptionClass = `` } = $$props;
  let { removeBtnTitle = `Remove` } = $$props;
  let { removeAllTitle = `Remove all` } = $$props;
  if (maxSelect !== null && maxSelect < 0) {
    throw new TypeError(`maxSelect must be null or positive integer, got ${maxSelect}`);
  }
  if (!selected)
    selected = single ? `` : [];
  if (!(options2 == null ? void 0 : options2.length) > 0)
    console.error(`MultiSelect missing options`);
  createEventDispatcher();
  let activeOption, searchText;
  if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
    $$bindings.selected(selected);
  if ($$props.maxSelect === void 0 && $$bindings.maxSelect && maxSelect !== void 0)
    $$bindings.maxSelect(maxSelect);
  if ($$props.readonly === void 0 && $$bindings.readonly && readonly !== void 0)
    $$bindings.readonly(readonly);
  if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
    $$bindings.placeholder(placeholder);
  if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
    $$bindings.options(options2);
  if ($$props.input === void 0 && $$bindings.input && input !== void 0)
    $$bindings.input(input);
  if ($$props.noOptionsMsg === void 0 && $$bindings.noOptionsMsg && noOptionsMsg !== void 0)
    $$bindings.noOptionsMsg(noOptionsMsg);
  if ($$props.outerDivClass === void 0 && $$bindings.outerDivClass && outerDivClass !== void 0)
    $$bindings.outerDivClass(outerDivClass);
  if ($$props.ulTokensClass === void 0 && $$bindings.ulTokensClass && ulTokensClass !== void 0)
    $$bindings.ulTokensClass(ulTokensClass);
  if ($$props.liTokenClass === void 0 && $$bindings.liTokenClass && liTokenClass !== void 0)
    $$bindings.liTokenClass(liTokenClass);
  if ($$props.ulOptionsClass === void 0 && $$bindings.ulOptionsClass && ulOptionsClass !== void 0)
    $$bindings.ulOptionsClass(ulOptionsClass);
  if ($$props.liOptionClass === void 0 && $$bindings.liOptionClass && liOptionClass !== void 0)
    $$bindings.liOptionClass(liOptionClass);
  if ($$props.removeBtnTitle === void 0 && $$bindings.removeBtnTitle && removeBtnTitle !== void 0)
    $$bindings.removeBtnTitle(removeBtnTitle);
  if ($$props.removeAllTitle === void 0 && $$bindings.removeAllTitle && removeAllTitle !== void 0)
    $$bindings.removeAllTitle(removeAllTitle);
  $$result.css.add(css);
  single = maxSelect === 1;
  filteredOptions = options2;
  isSelected = (option) => {
    if (!((selected == null ? void 0 : selected.length) > 0))
      return false;
    if (single)
      return selected === option;
    else
      return selected.includes(option);
  };
  return `
<div class="${[
    "multiselect " + escape2(outerDivClass) + " svelte-54s7ya",
    (readonly ? "readonly" : "") + " " + (single ? "single" : "")
  ].join(" ").trim()}"${add_attribute("style", ``, 0)}>${validate_component(ChevronExpand, "ExpandIcon").$$render($$result, {
    height: "14pt",
    style: "padding-left: 1pt;"
  }, {}, {})}
  <ul class="${"tokens " + escape2(ulTokensClass) + " svelte-54s7ya"}">${single ? `<span>${escape2(selected)}</span>` : `${(selected == null ? void 0 : selected.length) > 0 ? `${each(selected, (tag) => `<li class="${escape2(null_to_empty(liTokenClass)) + " svelte-54s7ya"}">${escape2(tag)}
          ${!readonly ? `<button type="${"button"}" title="${escape2(removeBtnTitle) + " " + escape2(tag)}" class="${"svelte-54s7ya"}">${validate_component(Cross, "CrossIcon").$$render($$result, { height: "12pt" }, {}, {})}
            </button>` : ``}
        </li>`)}` : ``}`}
    <input autocomplete="${"off"}"${add_attribute("placeholder", selected.length ? `` : placeholder, 0)} class="${"svelte-54s7ya"}"${add_attribute("this", input, 1)}${add_attribute("value", searchText, 1)}></ul>
  ${readonly ? `${validate_component(ReadOnly, "ReadOnlyIcon").$$render($$result, { height: "14pt" }, {}, {})}` : `<button type="${"button"}" class="${"remove-all svelte-54s7ya"}"${add_attribute("title", removeAllTitle, 0)}${add_attribute("style", selected.length === 0 ? `display: none;` : ``, 0)}>${validate_component(Cross, "CrossIcon").$$render($$result, { height: "14pt" }, {}, {})}</button>`}

  <ul class="${[
    "options " + escape2(ulOptionsClass) + " svelte-54s7ya",
    "hidden"
  ].join(" ").trim()}">${filteredOptions.length ? each(filteredOptions, (option) => `<li class="${[
    escape2(null_to_empty(liOptionClass)) + " svelte-54s7ya",
    (isSelected(option) ? "selected" : "") + " " + (activeOption === option ? "active" : "")
  ].join(" ").trim()}">${escape2(option)}
        </li>`) : `${escape2(noOptionsMsg)}`}</ul>
</div>`;
});
var Select = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { label = "" } = $$props;
  let { options: options2 = [] } = $$props;
  let { multiple = false } = $$props;
  let { placeholder = "" } = $$props;
  let { value } = $$props;
  let { backgroundColor = "bg-transparent" } = $$props;
  let { boxShadow = "" } = $$props;
  let { cursor = "cursor-pointer" } = $$props;
  let { flex = "flex-grow" } = $$props;
  let { fontWeight = "font-medium" } = $$props;
  let { outline = "outline-none focus:outline-none" } = $$props;
  let { padding = "px-[11px] py-[11px]" } = $$props;
  let { ring = "ring ring-white ring ring-opacity-0 focus:ring-opacity-10 ring-offset ring-offset-1 ring-offset-gray-400 hover:ring-offset-gray-200 focus:ring-offset-gray-200 focus-within:ring-offset-gray-200 focus-within:border-0" } = $$props;
  let { rounded = "rounded" } = $$props;
  let { shadow = "" } = $$props;
  let { textAlign = "" } = $$props;
  let { textColor = "" } = $$props;
  let { textSize = "" } = $$props;
  let { transition: transition2 = "transition duration-200" } = $$props;
  let { style: style2 = "" } = $$props;
  let { whitespace = "whitespace-nowrap" } = $$props;
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
    $$bindings.options(options2);
  if ($$props.multiple === void 0 && $$bindings.multiple && multiple !== void 0)
    $$bindings.multiple(multiple);
  if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
    $$bindings.placeholder(placeholder);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  if ($$props.backgroundColor === void 0 && $$bindings.backgroundColor && backgroundColor !== void 0)
    $$bindings.backgroundColor(backgroundColor);
  if ($$props.boxShadow === void 0 && $$bindings.boxShadow && boxShadow !== void 0)
    $$bindings.boxShadow(boxShadow);
  if ($$props.cursor === void 0 && $$bindings.cursor && cursor !== void 0)
    $$bindings.cursor(cursor);
  if ($$props.flex === void 0 && $$bindings.flex && flex !== void 0)
    $$bindings.flex(flex);
  if ($$props.fontWeight === void 0 && $$bindings.fontWeight && fontWeight !== void 0)
    $$bindings.fontWeight(fontWeight);
  if ($$props.outline === void 0 && $$bindings.outline && outline !== void 0)
    $$bindings.outline(outline);
  if ($$props.padding === void 0 && $$bindings.padding && padding !== void 0)
    $$bindings.padding(padding);
  if ($$props.ring === void 0 && $$bindings.ring && ring !== void 0)
    $$bindings.ring(ring);
  if ($$props.rounded === void 0 && $$bindings.rounded && rounded !== void 0)
    $$bindings.rounded(rounded);
  if ($$props.shadow === void 0 && $$bindings.shadow && shadow !== void 0)
    $$bindings.shadow(shadow);
  if ($$props.textAlign === void 0 && $$bindings.textAlign && textAlign !== void 0)
    $$bindings.textAlign(textAlign);
  if ($$props.textColor === void 0 && $$bindings.textColor && textColor !== void 0)
    $$bindings.textColor(textColor);
  if ($$props.textSize === void 0 && $$bindings.textSize && textSize !== void 0)
    $$bindings.textSize(textSize);
  if ($$props.transition === void 0 && $$bindings.transition && transition2 !== void 0)
    $$bindings.transition(transition2);
  if ($$props.style === void 0 && $$bindings.style && style2 !== void 0)
    $$bindings.style(style2);
  if ($$props.whitespace === void 0 && $$bindings.whitespace && whitespace !== void 0)
    $$bindings.whitespace(whitespace);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    classes = `${backgroundColor} ${boxShadow} ${cursor} ${flex} ${fontWeight} ${outline} ${padding} ${ring} ${rounded} ${shadow} ${textAlign} ${textColor} ${textSize} ${transition2} ${whitespace} ${$$props.class !== void 0 ? $$props.class : ""}`;
    $$rendered = `<div${add_attribute("class", label !== "" ? "pt-[32px] relative flex" : "", 0)}>${multiple ? `<div style="display: contents; --sms-options-bg:${"var(#f00, white)"};">${validate_component(MultiSelect, "MultiSelect").$$render($$result, {
      options: options2,
      placeholder,
      outerDivClass: "peer p-[11px] flex-grow m-0",
      selected: value
    }, {
      selected: ($$value) => {
        value = $$value;
        $$settled = false;
      }
    }, {})}</div>` : `<select class="${"peer " + escape2(classes)}"${add_attribute("style", style2, 0)}${add_attribute("value", value, 1)}>${each(options2, (option) => `}
        <option${add_attribute("value", option.value, 0)}>${escape2(option.label)}</option>`)}</select>`}
  ${label !== "" ? `<label${add_attribute("for", name, 0)} class="${"absolute left-0 transform translate-y-[-40px] pointer-events-none opacity-[1] scale-[.9] origin-top-left px-[0px] py-[11px] " + escape2(transition2) + " peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-[1] peer-placeholder-shown:px-[22px] peer-placeholder-shown:opacity-[.5]"}">${escape2(label)}</label>` : ``}</div>`;
  } while (!$$settled);
  return $$rendered;
});
var Spinner = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<svg class="${"w-[100px] h-[100px] animate-spinner-rotate"}" viewBox="${"25 25 50 50"}"><circle class="${"animate-spinner-dash"}" cx="${"50"}" cy="${"50"}" r="${"20"}" stroke="${"currentColor"}" fill="${"none"}" stroke-width="${"2"}" stroke-miterlimit="${"10"}"></circle></svg>`;
});
var Table = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<div class="${"overflow-auto w-full scrollbar-thin scrollbar-track-transparent scrollbar-thumb-primary-500 scrollbar-track-rounded-full"}"><table class="${"w-full"}">${slots.thead ? slots.thead({}) : `
      <thead></thead>
    `}
    ${slots.tbody ? slots.tbody({}) : `
      <tbody></tbody>
    `}</table></div>`;
});
var Modal = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { closeable = true } = $$props;
  let { show = false } = $$props;
  if ($$props.closeable === void 0 && $$bindings.closeable && closeable !== void 0)
    $$bindings.closeable(closeable);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  classes = {
    pointerEvents: `${show ? "pointer-events-auto" : "pointer-events-none"}`,
    position: "fixed",
    top: "top-0",
    left: "left-0",
    width: "w-screen",
    height: "h-screen",
    flex: "flex items-center justify-center",
    transition: "transition duration-200"
  };
  return `<div${add_attribute("class", Object.values(classes).join(" "), 0)}><div class="${"absolute top-0 left-0 w-full h-full -z-1 transition duration-200 " + escape2(show ? "opacity-100" : "opacity-0")}"></div>
  ${slots.default ? slots.default({}) : ``}</div>`;
});
var { set: set$3, subscribe: subscribe$3, update: update$2 } = writable2({ show: false, message: "", confirm: () => {
} });
var confirmation = {
  hide: () => update$2(({ message, confirm }) => {
    return { show: false, message, confirm };
  }),
  set: set$3,
  show: (message, confirm) => update$2(() => {
    return { show: true, message, confirm };
  }),
  subscribe: subscribe$3
};
var Modal_1$3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $store, $$unsubscribe_store;
  $$unsubscribe_store = subscribe(confirmation, (value) => $store = value);
  $$unsubscribe_store();
  return `${validate_component(Modal, "Modal").$$render($$result, { show: $store.show }, {}, {
    default: () => `${validate_component(Container, "Container").$$render($$result, {
      class: "flex justify-center pointer-events-none"
    }, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, {
        class: "max-w-[375px] transition duration-200 " + ($store.show ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none")
      }, {}, {
        default: () => `<div class="${"flex flex-col items-center space-y-[32px]"}">${validate_component(Icon$1, "Icon").$$render($$result, {
          src: Exclamation,
          class: "w-[80px] h-[80px] text-red-500"
        }, {}, {})}
        <div>${escape2($store.message)}</div>
        <div class="${"flex space-x-[16px]"}">${validate_component(Button, "Button").$$render($$result, { theme: "error" }, {}, { default: () => `Cancel` })}
          ${validate_component(Button, "Button").$$render($$result, {}, {}, { default: () => `Confirm` })}</div></div>`
      })}`
    })}`
  })}`;
});
var { set: set$2, subscribe: subscribe$2, update: update$1 } = writable2({ show: false, message: "" });
var error$1 = {
  hide: () => update$1(({ message }) => {
    return { show: false, message };
  }),
  set: set$2,
  show: (message) => update$1(() => {
    return { show: true, message };
  }),
  subscribe: subscribe$2
};
var Modal_1$2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $store, $$unsubscribe_store;
  $$unsubscribe_store = subscribe(error$1, (value) => $store = value);
  $$unsubscribe_store();
  return `${validate_component(Modal, "Modal").$$render($$result, { show: $store.show }, {}, {
    default: () => `${validate_component(Container, "Container").$$render($$result, {
      class: "flex justify-center pointer-events-none max-h-full"
    }, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, {
        class: "max-w-[375px] max-h-full transition duration-200 " + ($store.show ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none")
      }, {}, {
        default: () => `<div class="${"flex flex-col items-center max-h-full space-y-[32px]"}">${validate_component(Icon$1, "Icon").$$render($$result, {
          src: Exclamation,
          class: "w-[80px] h-[80px] text-red-500"
        }, {}, {})}
        <div>${escape2($store.message)}</div>
        ${validate_component(Button, "Button").$$render($$result, { theme: "error" }, {}, { default: () => `Try Again` })}</div>`
      })}`
    })}`
  })}`;
});
var { set: set$1, subscribe: subscribe$1 } = writable2(false);
var spinner = {
  hide: () => set$1(false),
  set: set$1,
  show: () => set$1(true),
  subscribe: subscribe$1
};
var Modal_1$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $show, $$unsubscribe_show;
  $$unsubscribe_show = subscribe(spinner, (value) => $show = value);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Modal, "Modal").$$render($$result, { closeable: false, show: $show }, {
      show: ($$value) => {
        $show = $$value;
        $$settled = false;
      }
    }, {
      default: () => `${validate_component(Card, "Card").$$render($$result, {
        class: "transition duration-200 " + ($show ? "opacity-100" : "opacity-0")
      }, {}, {
        default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
      })}`
    })}`;
  } while (!$$settled);
  $$unsubscribe_show();
  return $$rendered;
});
var { set, subscribe: subscribe2, update } = writable2({ show: false, message: "" });
var success = {
  hide: () => update(({ message }) => {
    return { show: false, message };
  }),
  set,
  show: (message) => update(() => {
    return { show: true, message };
  }),
  subscribe: subscribe2
};
var Modal_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $store, $$unsubscribe_store;
  $$unsubscribe_store = subscribe(success, (value) => $store = value);
  $$unsubscribe_store();
  return `${validate_component(Modal, "Modal").$$render($$result, { show: $store.show }, {}, {
    default: () => `${validate_component(Container, "Container").$$render($$result, {
      class: "flex justify-center pointer-events-none"
    }, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, {
        class: "max-w-[375px] transition duration-200 " + ($store.show ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none")
      }, {}, {
        default: () => `<div class="${"flex flex-col items-center space-y-[32px]"}">${validate_component(Icon$1, "Icon").$$render($$result, {
          src: ThumbUp,
          class: "w-[80px] h-[80px] text-green-500"
        }, {}, {})}
        <div><!-- HTML_TAG_START -->${$store.message}<!-- HTML_TAG_END --></div>
        ${validate_component(Button, "Button").$$render($$result, { theme: "success" }, {}, { default: () => `Close` })}</div>`
      })}`
    })}`
  })}`;
});
var cellClasses$3 = "p-[10px]";
var Datatable = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let checkedRows;
  let checked;
  let editURL;
  let indeterminate;
  let showDelete;
  let showEdit;
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  const getData = async () => {
    const data = await serverFetch(`/api/datatable/${collection}?sort=${JSON.stringify(sort)}`);
    rows = data.rows.map((row) => Object.assign({ checked: false }, row));
  };
  let { collection = "" } = $$props;
  let { deleteModalFN = (row) => row[columns2[0].key] } = $$props;
  let { columns: columns2 = [] } = $$props;
  let { editable = false } = $$props;
  let { sort = {} } = $$props;
  let loaded = false;
  let rows = [];
  onMount(async () => {
    await getData();
    loaded = true;
  });
  if ($$props.collection === void 0 && $$bindings.collection && collection !== void 0)
    $$bindings.collection(collection);
  if ($$props.deleteModalFN === void 0 && $$bindings.deleteModalFN && deleteModalFN !== void 0)
    $$bindings.deleteModalFN(deleteModalFN);
  if ($$props.columns === void 0 && $$bindings.columns && columns2 !== void 0)
    $$bindings.columns(columns2);
  if ($$props.editable === void 0 && $$bindings.editable && editable !== void 0)
    $$bindings.editable(editable);
  if ($$props.sort === void 0 && $$bindings.sort && sort !== void 0)
    $$bindings.sort(sort);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    checkedRows = [...rows].filter((row) => row.checked);
    checked = checkedRows.length === rows.length;
    editURL = checkedRows.length === 1 ? `${$page.path}/edit?_id=${checkedRows[0]._id}` : "";
    indeterminate = checkedRows.length !== 0 && checkedRows.length !== rows.length;
    showDelete = checkedRows.length > 0 ? true : false;
    showEdit = checkedRows.length === 1 ? true : false;
    $$rendered = `${validate_component(Card, "Card").$$render($$result, { class: "items-center space-y-[16px]" }, {}, {
      default: () => `${!loaded ? `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}` : `${editable ? `<div class="${"flex justify-end w-full"}"><div class="${"flex space-x-[8px]"}">${showEdit ? `<div class="${"flex"}">${validate_component(Icon, "Buttons.Icon").$$render($$result, {
        type: "link",
        href: editURL,
        theme: "secondary"
      }, {}, {
        default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Pencil, class: "w-[24px] h-[24px]" }, {}, {})}`
      })}</div>` : ``}
          ${showDelete ? `<div class="${"flex"}">${validate_component(Icon, "Buttons.Icon").$$render($$result, { theme: "error" }, {}, {
        default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Trash, class: "w-[24px] h-[24px]" }, {}, {})}`
      })}</div>` : ``}
          ${validate_component(Icon, "Buttons.Icon").$$render($$result, { type: "link", href: `${$page.path}/add` }, {}, {
        default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Plus, class: "w-[24px] h-[24px]" }, {}, {})}`
      })}</div></div>` : ``}
    ${validate_component(Table, "Table").$$render($$result, {}, {}, {
        tbody: () => `<tbody slot="${"tbody"}">${each(rows, (row) => `<tr${add_attribute("id", row._id, 0)} class="${"rounded transition duration-200 bg-white bg-opacity-0 hover:bg-opacity-[2%]"}">${editable ? `<td${add_attribute("class", cellClasses$3, 0)}>${validate_component(Checkbox, "Checkbox").$$render($$result, { checked: row.checked }, {
          checked: ($$value) => {
            row.checked = $$value;
            $$settled = false;
          }
        }, {})}</td>` : ``}
            ${each(columns2, (_a) => {
          var _b = _a, { key } = _b, column = __objRest(_b, ["key"]);
          var _a2, _b2;
          return `<td${add_attribute("class", cellClasses$3, 0)}>${key in row ? `${"options" in column ? `${escape2((_b2 = (_a2 = column.options.filter((option) => option.value === row[key])[0]) == null ? void 0 : _a2.label) != null ? _b2 : "")}` : `${escape2(key in row ? row[key] : "")}`}` : ``}
              </td>`;
        })}
          </tr>`)}</tbody>`,
        thead: () => `<thead slot="${"thead"}">${editable ? `<th class="${escape2(cellClasses$3) + " w-[24px]"}">${validate_component(Checkbox, "Checkbox").$$render($$result, { checked, indeterminate }, {
          checked: ($$value) => {
            checked = $$value;
            $$settled = false;
          },
          indeterminate: ($$value) => {
            indeterminate = $$value;
            $$settled = false;
          }
        }, {})}</th>` : ``}
        ${each(columns2, ({ title }) => `<th${add_attribute("class", cellClasses$3, 0)}>${escape2(title)}</th>`)}</thead>`
      })}`}`
    })}`;
  } while (!$$settled);
  $$unsubscribe_page();
  return $$rendered;
});
var Hamburger = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { toggleMenu } = $$props;
  let { show } = $$props;
  if ($$props.toggleMenu === void 0 && $$bindings.toggleMenu && toggleMenu !== void 0)
    $$bindings.toggleMenu(toggleMenu);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  return `<div class="${"relative cursor-pointer w-[24px] h-[24px] z-30 pointer-events-auto group"}"><div class="${"absolute z-30 w-full h-[1px] bg-gray-200 group-hover:bg-primary-500 transform transition duration-200 top-1/2 left-0 " + escape2(show ? "-translate-y-1/2 rotate-45" : "translate-y-[-9px] rotate-0")}"></div>
  <div class="${"absolute z-30 w-full h-[1px] bg-gray-200 group-hover:bg-primary-500 transform transition duration-200 top-1/2 left-0 translate-y-[-1px] " + escape2(show ? "opacity-0" : "opacity-100")}"></div>
  <div class="${"absolute z-30 w-full h-[1px] bg-gray-200 group-hover:bg-primary-500 transform transition duration-200 top-1/2 left-0 " + escape2(show ? "-translate-y-1/2 -rotate-45" : "translate-y-[7px] rotate-0")}"></div></div>`;
});
var bg = "bg-gradient-to-b from-black to-black";
var display = "lg:hidden";
var height = "h-screen";
var left = "left-0";
var position = "fixed";
var top = "top-0";
var transition = "transition duration-200";
var width = "w-screen";
var zIndex = "z-10";
var Overlay = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let pointerEvents;
  let opacity;
  let classes;
  let { toggleMenu } = $$props;
  let { show } = $$props;
  if ($$props.toggleMenu === void 0 && $$bindings.toggleMenu && toggleMenu !== void 0)
    $$bindings.toggleMenu(toggleMenu);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  pointerEvents = `${show ? "pointer-events-auto" : "pointer-events-none"}`;
  opacity = `${show ? "opacity-50" : "opacity-0"}`;
  classes = `${bg} ${display} ${height} ${left} ${opacity} ${pointerEvents} ${position} ${top} ${transition} ${width} ${zIndex} ${$$props.class !== void 0 ? $$props.class : ""}`;
  return `<div${add_attribute("class", classes, 0)}></div>`;
});
var Link = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { href } = $$props;
  let { i } = $$props;
  let { show } = $$props;
  let { title } = $$props;
  let { toggleMenu } = $$props;
  const transitionDelays = [
    "delay-300",
    "delay-400",
    "delay-500",
    "delay-600",
    "delay-700",
    "delay-800",
    "delay-900",
    "delay-1000",
    "delay-1100",
    "delay-1200",
    "delay-1300",
    "delay-1400",
    "delay-1500",
    "delay-1600",
    "delay-1700",
    "delay-1800",
    "delay-1900",
    "delay-2000"
  ];
  if ($$props.href === void 0 && $$bindings.href && href !== void 0)
    $$bindings.href(href);
  if ($$props.i === void 0 && $$bindings.i && i !== void 0)
    $$bindings.i(i);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  if ($$props.title === void 0 && $$bindings.title && title !== void 0)
    $$bindings.title(title);
  if ($$props.toggleMenu === void 0 && $$bindings.toggleMenu && toggleMenu !== void 0)
    $$bindings.toggleMenu(toggleMenu);
  classes = {
    lineHeight: "leading-[25px]",
    opacity: `${show ? "opacity-100" : "opacity-0"} lg:opacity-100`,
    padding: "py-[11px] lg:px-[15.5px] lg:px-[16px]",
    rounded: "rounded-full",
    textAlign: "text-center",
    textColor: "hover:text-primary-500",
    textSize: "lg:text-[13px]",
    transform: `transform ${show ? "translate-x-0" : "translate-x-[-1rem]"} lg:translate-x-0`,
    transition: `transition duration-200`,
    transitionDelay: `${show ? transitionDelays[i] : "delay-0"} lg:delay-0`,
    width: "w-full lg:w-auto"
  };
  return `<a${add_attribute("href", href, 0)}${add_attribute("class", Object.values(classes).join(" "), 0)}>${escape2(title)}</a>`;
});
var NavWrapper = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { routes } = $$props;
  let { show } = $$props;
  let { toggleMenu } = $$props;
  if ($$props.routes === void 0 && $$bindings.routes && routes !== void 0)
    $$bindings.routes(routes);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  if ($$props.toggleMenu === void 0 && $$bindings.toggleMenu && toggleMenu !== void 0)
    $$bindings.toggleMenu(toggleMenu);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    classes = {
      alignItems: "lg:items-center",
      bg: "",
      flex: "flex flex-col lg:flex-row",
      fontSize: "text-[16px]",
      fontWeight: "font-medium",
      height: "min-h-screen h-full lg:h-auto lg:min-h-auto",
      justifyContent: "",
      overflow: "overflow-y-auto",
      padding: "py-[28px]",
      pointerEvents: `${show ? "pointer-events-auto" : "pointer-events-none"} lg:pointer-events-auto`,
      position: "relative",
      rounded: "rounded-lg",
      shadow: "",
      space: "",
      textColor: "text-blue",
      transition: "transition duration-200",
      transform: `transform ${show ? "translate-x-0" : "translate-x-[100%]"} lg:translate-x-0`
    };
    $$rendered = `<div${add_attribute("class", Object.values(classes).join(" "), 0)}>${each(routes, ({ title, href }, i) => `${validate_component(Link, "Link").$$render($$result, { toggleMenu, title, href, i, show }, {
      show: ($$value) => {
        show = $$value;
        $$settled = false;
      }
    }, {})}`)}</div>`;
  } while (!$$settled);
  return $$rendered;
});
var Nav = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  const toggleMenu = () => show = !show;
  let { routes } = $$props;
  let { show = false } = $$props;
  if ($$props.routes === void 0 && $$bindings.routes && routes !== void 0)
    $$bindings.routes(routes);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    classes = {
      flex: "",
      height: "h-screen",
      left: "left-[50%] lg:left-auto",
      opacity: `${show ? "opacity-100" : "opacity-0"} lg:opacity-100`,
      overflow: "overflow-hidden",
      padding: "",
      pointerEvents: "pointer-events-none",
      position: "absolute",
      top: "top-[0px] lg:top-auto",
      transform: "transform translate-x-[-50%] lg:translate-x-0",
      transition: "transition duration-200 lg:duration-0",
      width: "w-screen lg:w-auto",
      zIndex: "z-20"
    };
    $$rendered = `${validate_component(Hamburger, "Hamburger").$$render($$result, { toggleMenu, show }, {
      show: ($$value) => {
        show = $$value;
        $$settled = false;
      }
    }, {})}
${validate_component(Overlay, "Overlay").$$render($$result, { toggleMenu, show }, {
      show: ($$value) => {
        show = $$value;
        $$settled = false;
      }
    }, {})}

<div${add_attribute("class", Object.values(classes).join(" "), 0)}>${validate_component(NavWrapper, "NavWrapper").$$render($$result, { routes, toggleMenu, show }, {
      show: ($$value) => {
        show = $$value;
        $$settled = false;
      }
    }, {})}</div>`;
  } while (!$$settled);
  return $$rendered;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { routes = [] } = $$props;
  if ($$props.routes === void 0 && $$bindings.routes && routes !== void 0)
    $$bindings.routes(routes);
  return `<header class="${"flex w-full justify-center absolute top-0 left-0 py-[38px] z-20 lg:py-[54px]"}">${validate_component(Container, "Container").$$render($$result, {}, {}, {
    default: () => `<div class="${"flex justify-end items-center"}">${validate_component(Nav, "Nav").$$render($$result, { routes }, {}, {})}</div>`
  })}</header>`;
});
var Image = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let transitionClasses;
  let { alt } = $$props;
  let { transition: transition2 = "transition duration-200" } = $$props;
  let { src: src3 } = $$props;
  let loaded = false;
  let thisImage;
  onMount(() => {
    thisImage.onload = () => {
      loaded = true;
    };
  });
  if ($$props.alt === void 0 && $$bindings.alt && alt !== void 0)
    $$bindings.alt(alt);
  if ($$props.transition === void 0 && $$bindings.transition && transition2 !== void 0)
    $$bindings.transition(transition2);
  if ($$props.src === void 0 && $$bindings.src && src3 !== void 0)
    $$bindings.src(src3);
  transitionClasses = loaded ? "opacity-100" : "opacity-0";
  return `<img${add_attribute("src", src3, 0)}${add_attribute("alt", alt, 0)} class="${escape2(transition2) + " " + escape2(transitionClasses) + " " + escape2($$props.class !== void 0 ? $$props.class : "")}"${add_attribute("this", thisImage, 1)}>`;
});
var IntersectionObserver_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { bottom = 0 } = $$props;
  let { left: left2 = 0 } = $$props;
  let { once = false } = $$props;
  let { right = 0 } = $$props;
  let { top: top2 = 0 } = $$props;
  let container;
  let intersecting = false;
  onMount(() => {
    if (typeof IntersectionObserver !== "undefined") {
      const rootMargin = `${bottom}px ${left2}px ${top2}px ${right}px`;
      const observer = new IntersectionObserver((entries) => {
        intersecting = entries[0].isIntersecting;
        if (intersecting && once) {
          observer.unobserve(container);
        }
      }, { rootMargin });
      observer.observe(container);
      return () => observer.unobserve(container);
    }
  });
  if ($$props.bottom === void 0 && $$bindings.bottom && bottom !== void 0)
    $$bindings.bottom(bottom);
  if ($$props.left === void 0 && $$bindings.left && left2 !== void 0)
    $$bindings.left(left2);
  if ($$props.once === void 0 && $$bindings.once && once !== void 0)
    $$bindings.once(once);
  if ($$props.right === void 0 && $$bindings.right && right !== void 0)
    $$bindings.right(right);
  if ($$props.top === void 0 && $$bindings.top && top2 !== void 0)
    $$bindings.top(top2);
  return `<div${add_attribute("this", container, 1)}>${slots.default ? slots.default({ intersecting }) : ``}</div>`;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { src: src3 } = $$props;
  let { alt } = $$props;
  if ($$props.src === void 0 && $$bindings.src && src3 !== void 0)
    $$bindings.src(src3);
  if ($$props.alt === void 0 && $$bindings.alt && alt !== void 0)
    $$bindings.alt(alt);
  return `${validate_component(IntersectionObserver_1, "IntersectionObserver").$$render($$result, { once: true }, {}, {
    default: ({ intersecting }) => `${intersecting ? `${validate_component(Image, "Image").$$render($$result, { alt, src: src3 }, {}, {})}` : ``}`
  })}`;
});
var Input = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { label = "" } = $$props;
  let { name: name2 = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { type = "" } = $$props;
  let { value = "" } = $$props;
  let { backgroundColor = "bg-transparent" } = $$props;
  let { boxShadow = "" } = $$props;
  let { flex = "flex-grow" } = $$props;
  let { fontWeight = "font-medium" } = $$props;
  let { outline = "outline-none focus:outline-none" } = $$props;
  let { padding = "px-[22px] py-[11px]" } = $$props;
  let { ring = "ring ring-white ring ring-opacity-0 focus:ring-opacity-10 ring-offset ring-offset-1 ring-offset-gray-400 hover:ring-offset-gray-200 focus:ring-offset-gray-200" } = $$props;
  let { rounded = "rounded" } = $$props;
  let { shadow = "" } = $$props;
  let { textAlign = "" } = $$props;
  let { textColor = "" } = $$props;
  let { textSize = "" } = $$props;
  let { transition: transition2 = "transition duration-200" } = $$props;
  let { style: style2 = "" } = $$props;
  let { whitespace = "whitespace-nowrap" } = $$props;
  if ($$props.label === void 0 && $$bindings.label && label !== void 0)
    $$bindings.label(label);
  if ($$props.name === void 0 && $$bindings.name && name2 !== void 0)
    $$bindings.name(name2);
  if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
    $$bindings.placeholder(placeholder);
  if ($$props.type === void 0 && $$bindings.type && type !== void 0)
    $$bindings.type(type);
  if ($$props.value === void 0 && $$bindings.value && value !== void 0)
    $$bindings.value(value);
  if ($$props.backgroundColor === void 0 && $$bindings.backgroundColor && backgroundColor !== void 0)
    $$bindings.backgroundColor(backgroundColor);
  if ($$props.boxShadow === void 0 && $$bindings.boxShadow && boxShadow !== void 0)
    $$bindings.boxShadow(boxShadow);
  if ($$props.flex === void 0 && $$bindings.flex && flex !== void 0)
    $$bindings.flex(flex);
  if ($$props.fontWeight === void 0 && $$bindings.fontWeight && fontWeight !== void 0)
    $$bindings.fontWeight(fontWeight);
  if ($$props.outline === void 0 && $$bindings.outline && outline !== void 0)
    $$bindings.outline(outline);
  if ($$props.padding === void 0 && $$bindings.padding && padding !== void 0)
    $$bindings.padding(padding);
  if ($$props.ring === void 0 && $$bindings.ring && ring !== void 0)
    $$bindings.ring(ring);
  if ($$props.rounded === void 0 && $$bindings.rounded && rounded !== void 0)
    $$bindings.rounded(rounded);
  if ($$props.shadow === void 0 && $$bindings.shadow && shadow !== void 0)
    $$bindings.shadow(shadow);
  if ($$props.textAlign === void 0 && $$bindings.textAlign && textAlign !== void 0)
    $$bindings.textAlign(textAlign);
  if ($$props.textColor === void 0 && $$bindings.textColor && textColor !== void 0)
    $$bindings.textColor(textColor);
  if ($$props.textSize === void 0 && $$bindings.textSize && textSize !== void 0)
    $$bindings.textSize(textSize);
  if ($$props.transition === void 0 && $$bindings.transition && transition2 !== void 0)
    $$bindings.transition(transition2);
  if ($$props.style === void 0 && $$bindings.style && style2 !== void 0)
    $$bindings.style(style2);
  if ($$props.whitespace === void 0 && $$bindings.whitespace && whitespace !== void 0)
    $$bindings.whitespace(whitespace);
  classes = `${backgroundColor} ${boxShadow} ${flex} ${fontWeight} ${outline} ${padding} placeholder-transparent ${ring} ${rounded} ${shadow} ${textAlign} ${textColor} ${textSize} ${transition2} ${whitespace} ${$$props.class !== void 0 ? $$props.class : ""}`;
  return `<div${add_attribute("class", label !== "" ? "pt-[32px] relative flex" : "", 0)}>${type === "email" ? `<input type="${"email"}"${add_attribute("name", name2, 0)} class="${"peer " + escape2(classes)}"${add_attribute("placeholder", placeholder, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}${add_attribute("value", value, 1)}>` : `${type === "number" ? `<input type="${"number"}"${add_attribute("name", name2, 0)} class="${"peer " + escape2(classes)}"${add_attribute("placeholder", placeholder, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}${add_attribute("value", value, 1)}>` : `${type === "password" ? `<input type="${"password"}"${add_attribute("name", name2, 0)} class="${"peer " + escape2(classes)}"${add_attribute("placeholder", placeholder, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}${add_attribute("value", value, 1)}>` : `<input type="${"text"}"${add_attribute("name", name2, 0)} class="${"peer " + escape2(classes)}"${add_attribute("placeholder", placeholder, 0)}${add_attribute("style", style2 !== void 0 ? style2 : "", 0)}${add_attribute("value", value, 1)}>`}`}`}
  ${label !== "" ? `<label${add_attribute("for", name2, 0)} class="${"absolute left-0 transform translate-y-[-40px] pointer-events-none opacity-[1] scale-[.9] translate-x-[0] origin-top-left py-[11px] " + escape2(transition2) + " peer-placeholder-shown:translate-x-[22px] peer-placeholder-shown:translate-y-0 peer-placeholder-shown:scale-[1] peer-placeholder-shown:opacity-[.5]"}">${escape2(label)}</label>` : ``}</div>`;
});
create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `<svg xmlns="${"http://www.w3.org/2000/svg"}" viewBox="${"0 0 146 24"}"${add_attribute("class", $$props.class !== void 0 ? $$props.class : "", 0)}><g fill="${"none"}" fill-rule="${"evenodd"}"><path fill="${"currentColor"}" fill-rule="${"nonzero"}" d="${"M40.014 16.809V8.553c0-1.577.366-2.82 1.098-3.73.733-.91 1.65-1.365 2.75-1.365 2.158 0 3.237 1.577 3.237 4.731v8.62h3.782v-9.58c0-2.415-.5-4.22-1.503-5.417C48.376.615 46.945.017 45.084.017c-1.222 0-2.34.234-3.352.703a6.833 6.833 0 00-2.56 2.043h-.066C38.126.932 36.486.017 34.184.017c-.969 0-1.902.217-2.799.653a6.976 6.976 0 00-2.353 1.878h-.05V.265H25.2v16.527h3.782V8.553c0-1.577.372-2.82 1.115-3.73.743-.91 1.693-1.365 2.849-1.365 2.19 0 3.286 1.577 3.286 4.731v8.62h3.782zm21.101.248c2.246 0 3.997-.827 5.252-2.482h.05v2.217h3.616V.265h-3.782V2.25h-.066C64.93.761 63.23.017 61.082.017a7.76 7.76 0 00-5.681 2.415c-.705.75-1.26 1.66-1.668 2.73a9.589 9.589 0 00-.611 3.44c0 1.258.203 2.416.61 3.475.408 1.059.964 1.952 1.669 2.68a7.348 7.348 0 002.535 1.696 8.325 8.325 0 003.18.604zm.595-3.441c-1.399 0-2.538-.466-3.419-1.398-.88-.932-1.321-2.132-1.321-3.599 0-1.555.454-2.804 1.362-3.747.909-.943 2.04-1.414 3.394-1.414 1.343 0 2.458.493 3.345 1.48.886.988 1.33 2.215 1.33 3.681 0 1.467-.455 2.667-1.363 3.599-.909.932-2.018 1.398-3.328 1.398zm27.112 3.193V7.064c0-2.393-.536-4.166-1.61-5.319C86.14.593 84.655.017 82.762.017a7.373 7.373 0 00-3.056.645 6.958 6.958 0 00-2.477 1.87h-.05V.264h-3.782v16.527h3.782V8.487c0-1.588.388-2.823 1.164-3.706.777-.882 1.814-1.323 3.113-1.323.595 0 1.104.077 1.528.231.424.155.796.406 1.115.753.32.348.556.819.71 1.415.154.595.231 1.323.231 2.183v8.769h3.782zm10.218.248c2.246 0 3.996-.827 5.252-2.482h.05v2.217h3.616V.265h-3.782V2.25h-.066C102.855.761 101.154.017 99.007.017a7.76 7.76 0 00-5.682 2.415c-.704.75-1.26 1.66-1.668 2.73a9.589 9.589 0 00-.61 3.44c0 1.258.203 2.416.61 3.475.408 1.059.964 1.952 1.668 2.68a7.348 7.348 0 002.536 1.696 8.325 8.325 0 003.179.604zm.594-3.441c-1.398 0-2.538-.466-3.418-1.398-.881-.932-1.322-2.132-1.322-3.599 0-1.555.455-2.804 1.363-3.747.908-.943 2.04-1.414 3.394-1.414 1.343 0 2.458.493 3.344 1.48.886.988 1.33 2.215 1.33 3.681 0 1.467-.455 2.667-1.363 3.599-.908.932-2.018 1.398-3.328 1.398zm19.07 10.125c1.2 0 2.274-.14 3.22-.422.947-.281 1.743-.673 2.387-1.175a6.385 6.385 0 001.602-1.844 8.14 8.14 0 00.916-2.383c.188-.86.281-1.803.281-2.829V.265h-3.782v1.737h-.066a7.059 7.059 0 00-2.353-1.49A7.62 7.62 0 00118.142 0c-1.508 0-2.862.358-4.062 1.075-1.2.717-2.134 1.713-2.8 2.987-.666 1.273-.999 2.705-.999 4.293 0 1.61.35 3.038 1.049 4.285.699 1.246 1.66 2.203 2.882 2.87 1.222.667 2.598 1.001 4.129 1.001 2.047 0 3.716-.673 5.004-2.018h.066v1.753c0 1.17-.43 2.14-1.288 2.912-.86.772-2.07 1.158-3.634 1.158-1.068 0-2.006-.132-2.816-.397-.809-.265-1.742-.678-2.799-1.24l-.892 3.341c.925.552 1.966.976 3.122 1.274 1.156.298 2.356.447 3.6.447zm.132-10.72c-1.365 0-2.491-.434-3.377-1.3-.887-.865-1.33-2.026-1.33-3.482 0-1.4.435-2.542 1.305-3.425.87-.882 2.004-1.323 3.402-1.323 1.332 0 2.442.435 3.328 1.307.886.871 1.33 2.002 1.33 3.391 0 1.401-.433 2.556-1.297 3.466-.864.91-1.985 1.365-3.361 1.365zm19.086 4.036c1.542 0 2.899-.281 4.071-.844 1.173-.562 2.133-1.323 2.882-2.283l-2.642-2.266c-1.035 1.301-2.406 1.952-4.113 1.952-1.21 0-2.237-.337-3.08-1.01-.842-.672-1.384-1.593-1.627-2.762h12.024c.066-.397.099-.9.099-1.506 0-1.599-.325-3.027-.975-4.285a7.198 7.198 0 00-2.807-2.961c-1.222-.717-2.632-1.075-4.228-1.075a8.191 8.191 0 00-3.188.62c-.99.414-1.844.99-2.56 1.729-.715.739-1.277 1.638-1.684 2.696-.407 1.06-.611 2.212-.611 3.458 0 1.688.369 3.185 1.106 4.492.738 1.307 1.746 2.308 3.023 3.003 1.277.695 2.714 1.042 4.31 1.042zm3.815-10.274h-8.257c.264-1.059.776-1.878 1.535-2.457.76-.579 1.663-.868 2.709-.868 1.057 0 1.93.298 2.618.893.688.596 1.153 1.406 1.395 2.432z"}"></path><g fill="${"#F3603C"}"><path d="${"M2.786 10.286c1.538 0 2.785 1.279 2.785 2.857C5.571 14.72 4.324 16 2.786 16 1.247 16 0 14.72 0 13.143c0-1.578 1.247-2.857 2.786-2.857zM2.786 0C4.324 0 5.57 1.28 5.57 2.857c0 1.578-1.247 2.857-2.785 2.857C1.247 5.714 0 4.435 0 2.857 0 1.28 1.247 0 2.786 0zm10.028 0C14.353 0 15.6 1.28 15.6 2.857c0 1.578-1.247 2.857-2.786 2.857-1.538 0-2.785-1.279-2.785-2.857C10.029 1.28 11.276 0 12.814 0z"}"></path><ellipse cx="${"12.814"}" cy="${"13.257"}" opacity="${".5"}" rx="${"2.786"}" ry="${"2.857"}"></ellipse></g></g></svg>`;
});
var Section = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let classes;
  let { flex = "flex flex-col" } = $$props;
  let { padding = "p-[24px]" } = $$props;
  let { position: position2 = "" } = $$props;
  let { width: width2 = "w-full" } = $$props;
  if ($$props.flex === void 0 && $$bindings.flex && flex !== void 0)
    $$bindings.flex(flex);
  if ($$props.padding === void 0 && $$bindings.padding && padding !== void 0)
    $$bindings.padding(padding);
  if ($$props.position === void 0 && $$bindings.position && position2 !== void 0)
    $$bindings.position(position2);
  if ($$props.width === void 0 && $$bindings.width && width2 !== void 0)
    $$bindings.width(width2);
  classes = `${flex} ${padding} ${position2} ${width2} ${$$props.class !== void 0 ? $$props.class : ""}`;
  return `<section${add_attribute("class", classes, 0)}>${slots.default ? slots.default({}) : ``}</section>`;
});
var linkClasses = "px-[24px] py-[8px] transition duration-200 lg:px-[72px]";
var Sidebar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let groupedRoutes;
  let $page, $$unsubscribe_page;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  const toggleMenu = () => show = !show;
  let { routes = [] } = $$props;
  let { show = false } = $$props;
  if ($$props.routes === void 0 && $$bindings.routes && routes !== void 0)
    $$bindings.routes(routes);
  if ($$props.show === void 0 && $$bindings.show && show !== void 0)
    $$bindings.show(show);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    groupedRoutes = [...routes].sort((a, b) => {
      const compareA = `${"group" in a ? a.group : " "}${a.name}`;
      const compareB = `${"group" in b ? b.group : " "}${b.name}`;
      if (compareA < compareB)
        return -1;
      if (compareA > compareB)
        return 1;
      return 0;
    }).reduce((obj, route) => {
      if ("group" in route) {
        const { group } = route;
        if (!(group in obj))
          obj[group] = [];
        obj[group].push(route);
      } else {
        if (!("" in obj))
          obj[""] = [];
        obj[""].push(route);
      }
      return obj;
    }, {});
    $$rendered = `<div class="${"flex flex-col fixed top-0 left-0 z-10 w-screen h-screen py-[24px] ring ring-1 justify-between transform transition duration-200 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-primary-500 scrollbar-track-rounded-full " + escape2(show ? "translate-x-0" : "translate-x-[100%] lg:translate-x-[-100%]") + " ring-white ring-opacity-[2%] ring-inset backdrop-filter backdrop-blur-md lg:w-auto"}"><div class="${"flex flex-col space-y-[32px] mt-[-8px] pb-[32px]"}">${each(Object.keys(groupedRoutes), (group) => `<div class="${"flex flex-col"}">${group !== "" ? `<div class="${"uppercase text-white font-bold " + escape2(linkClasses)}">${escape2(group)}</div>` : ``}
        ${each(groupedRoutes[group], ({ href, name: name2 }) => `${href === $page.path.replace(/\add/g, "") ? `<div class="${"flex relative"}"><div class="${"absolute top-0 right-0 bg-primary-500 h-full w-[2px]"}"></div>
              <a${add_attribute("href", href, 0)} class="${"text-primary-500 cursor-default " + escape2(linkClasses)}">${escape2(name2)}</a>
            </div>` : `<a${add_attribute("href", href, 0)} class="${"hover:text-primary-500 " + escape2(linkClasses)}">${escape2(name2)}</a>`}`)}
      </div>`)}</div>
  <div class="${"flex mb-[-8px]"}"><a href="${"/signout"}" class="${"hover:text-primary-500 " + escape2(linkClasses)}">Sign Out</a></div></div>
<div class="${"w-full flex justify-end p-[24px] ring ring-1 ring-white ring-opacity-[2%] pointer-events-none lg:w-auto lg:h-auto"}">${validate_component(Hamburger, "Hamburger").$$render($$result, { toggleMenu, show }, {
      show: ($$value) => {
        show = $$value;
        $$settled = false;
      }
    }, {})}</div>`;
  } while (!$$settled);
  $$unsubscribe_page();
  return $$rendered;
});
function load$5({ page: page2 }) {
  return { props: { path: page2.path } };
}
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let title;
  let $page, $$unsubscribe_page;
  let $auth, $$unsubscribe_auth;
  $$unsubscribe_page = subscribe(page, (value) => $page = value);
  $$unsubscribe_auth = subscribe(accessToken, (value) => $auth = value);
  let loaded = false;
  let routes = [];
  let { path } = $$props;
  beforeUpdate(async () => {
    if ($auth === null)
      return goto("/signin");
    if ($auth !== null) {
      const data = await getRoutes($auth);
      if ([...routes].map((route) => route.name).join(",") !== [...data].map((route) => route.name).join(","))
        routes = data;
      if (![...data].map((route) => route.href).includes(path.replace(/\/add|\/edit/g, "")))
        return goto("/dashboard");
    }
  });
  onMount(() => loaded = true);
  if ($$props.path === void 0 && $$bindings.path && path !== void 0)
    $$bindings.path(path);
  title = "";
  title = `${$page.path.slice(1).split("/").reverse().map((directory) => directory.split("-").map((word) => word === "" ? "" : word[0].toUpperCase() + word.slice(1)).join(" ")).join(" - ")}  - Employee Online Portal - Allen Bailey Tag & Label`;
  $$unsubscribe_page();
  $$unsubscribe_auth();
  return `${$$result.head += `<meta name="${"description"}" content="${"Employee Online Portal - Allen-Bailey Tag & Label"}" data-svelte="svelte-prrgr2"><meta name="${"theme-color"}" content="${"#fff"}" data-svelte="svelte-prrgr2">${$$result.title = `<title>${escape2(title)}</title>`, ""}`, ""}

<main class="${"relative bg-gradient-to-br from-gray-500 to-gray-800 min-h-screen text-gray-100 flex flex-col lg:flex-row"}">${loaded ? `${validate_component(Sidebar, "Sidebar").$$render($$result, { routes }, {}, {})}
    ${slots.default ? slots.default({}) : ``}
    ${validate_component(Modal_1$3, "Modal.Confirmation").$$render($$result, {}, {}, {})}
    ${validate_component(Modal_1$2, "Modal.Error").$$render($$result, {}, {}, {})}
    ${validate_component(Modal_1$1, "Modal.Spinner").$$render($$result, {}, {}, {})}
    ${validate_component(Modal_1, "Modal.Success").$$render($$result, {}, {}, {})}` : `<div class="${"w-screen h-screen flex items-center justify-center"}">${validate_component(Card, "Card").$$render($$result, {}, {}, {
    default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
  })}</div>`}</main>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout,
  load: load$5
});
function load$4({ error: error22, status: status2 }) {
  return { props: { error: error22, status: status2 } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status: status2 } = $$props;
  let { error: error22 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status2 !== void 0)
    $$bindings.status(status2);
  if ($$props.error === void 0 && $$bindings.error && error22 !== void 0)
    $$bindings.error(error22);
  return `<h1>${escape2(status2)}</h1>

<p>${escape2(error22.message)}</p>


${error22.stack ? `<pre>${escape2(error22.stack)}</pre>` : ``}`;
});
var error2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$4
});
var Routes$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var index$c = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes$1
});
var Change_password = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_auth;
  $$unsubscribe_auth = subscribe(accessToken, (value) => value);
  let currentPassword = "";
  let password = "";
  let passwordConfirm = "";
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<form class="${"flex flex-col space-y-[16px] max-w-[500px] w-full mx-auto"}">${validate_component(Input, "Input").$$render($$result, {
        type: "password",
        label: "Current Password",
        placeholder: "Current Password",
        value: currentPassword
      }, {
        value: ($$value) => {
          currentPassword = $$value;
          $$settled = false;
        }
      }, {})}
    ${validate_component(Input, "Input").$$render($$result, {
        type: "password",
        label: "New Password",
        placeholder: "New Password",
        value: password
      }, {
        value: ($$value) => {
          password = $$value;
          $$settled = false;
        }
      }, {})}
    ${validate_component(Input, "Input").$$render($$result, {
        type: "password",
        label: "New Password ( retype )",
        placeholder: "New Password ( retype )",
        value: passwordConfirm
      }, {
        value: ($$value) => {
          passwordConfirm = $$value;
          $$settled = false;
        }
      }, {})}
    ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Change` })}</form>`
    })}`;
  } while (!$$settled);
  $$unsubscribe_auth();
  return $$rendered;
});
var index$b = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Change_password
});
var Dashboard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${validate_component(Section, "Section").$$render($$result, {}, {}, {
    default: () => `<div class="${"text-[40px] font-bold"}">Dashboard</div>`
  })}`;
});
var index$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Dashboard
});
var cellClasses$2 = "p-[10px]";
var Training_checklist = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let rows;
  let periodOptions;
  const filterUsers = () => {
    const applicableRoles = [...roles].filter((role) => role.safetyItems.map((obj) => obj.name).includes(safetyType)).map((role) => role.name);
    const applicableUsers = [...users].filter((user) => {
      return user.roles.filter((role) => applicableRoles.includes(role)).length > 0;
    }).map((user) => {
      user.checked = [...safetyHistory].filter((obj) => obj.id === user._id && obj.safetyType === safetyType).length === 1 ? true : false;
      return user;
    });
    return applicableUsers;
  };
  const getPeriodOptions = () => {
    const date = new Date();
    const currentMonth = date.getMonth();
    const currentYear = date.getFullYear();
    const initialYear = 2020;
    const safetyTypeMonth = [...safetyTypes].filter(({ name: name2 }) => name2 === safetyType)[0].month;
    const months = (currentYear - initialYear) * 12 - safetyTypeMonth + currentMonth;
    const years = Math.ceil(months / 12);
    const options2 = [...Array(years).keys()].map((_, i) => {
      const dateStart = new Date(initialYear + i, safetyTypeMonth, 1);
      const dateEnd = new Date(initialYear + i, safetyTypeMonth + 11, 1);
      return {
        label: `${dateStart.toLocaleString("default", { month: "long" })} ${dateStart.getFullYear()} - ${dateEnd.toLocaleString("default", { month: "long" })} ${dateEnd.getFullYear()}`,
        value: dateStart.getFullYear().toString()
      };
    }).reverse();
    period = options2[0].value;
    return options2;
  };
  const getRoles = async () => {
    const data = await serverFetch(`/api/datatable/roles?sort=${JSON.stringify({ name: 1 })}`);
    roles = data.rows;
  };
  const getSafetyHistory = async () => {
    const data = await serverFetch(`/api/datatable/safety-history`);
    safetyHistory = data.rows;
  };
  const getSafetyTypes = async () => {
    const data = await serverFetch(`/api/datatable/safety-types?sort=${JSON.stringify({ name: 1 })}`);
    safetyTypes = data.rows;
    safetyTypeOptions = [
      {
        label: "-- Select a Safety Item",
        value: ""
      },
      ...data.rows.map((row) => {
        return { label: row.name, value: row.name };
      })
    ];
  };
  const getUsers = async () => {
    const data = await serverFetch(`/api/datatable/users?sort=${JSON.stringify({ firstName: 1, lastName: 1 })}`);
    users = data.rows;
  };
  let columns2 = [
    { title: "First Name", key: "firstName" },
    { title: "Last Name", key: "lastName" }
  ];
  let loaded = false;
  let period = "";
  let roles = [];
  let safetyHistory = [];
  let safetyType = "";
  let safetyTypes = [];
  let safetyTypeOptions = [];
  let users = [];
  onMount(async () => {
    await Promise.all([getRoles(), getSafetyHistory(), getSafetyTypes(), getUsers()]);
    loaded = true;
  });
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    rows = safetyType === "" ? [] : filterUsers();
    periodOptions = safetyType === "" ? [] : getPeriodOptions();
    {
      if (safetyType === "" || safetyTypes.filter((obj) => obj.name === safetyType)[0].frequency === "At Hire")
        period = "";
    }
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, { class: "items-center space-y-[16px]" }, {}, {
        default: () => `${loaded ? `<div class="${"w-full flex justify-start space-x-[16px]"}">${validate_component(Select, "Select").$$render($$result, {
          label: "Safety Type",
          placeholder: "Safety Type",
          options: safetyTypeOptions,
          value: safetyType
        }, {
          value: ($$value) => {
            safetyType = $$value;
            $$settled = false;
          }
        }, {})}
        ${safetyType !== "" && safetyTypes.filter((obj) => obj.name === safetyType)[0].frequency !== "At Hire" ? `${validate_component(Select, "Select").$$render($$result, {
          label: "Period",
          placeholder: "Period",
          options: periodOptions,
          value: period
        }, {
          value: ($$value) => {
            period = $$value;
            $$settled = false;
          }
        }, {})}` : ``}</div>
      ${rows.length > 0 ? `${validate_component(Table, "Table").$$render($$result, {}, {}, {
          tbody: () => `<tbody slot="${"tbody"}">${each(rows, (row, i) => `<tr class="${"rounded transition duration-200 bg-white bg-opacity-0 hover:bg-opacity-[2%]"}"><td${add_attribute("class", cellClasses$2, 0)}><div class="${"flex justify-center"}">${validate_component(Checkbox, "Checkbox").$$render($$result, { checked: row.checked }, {
            checked: ($$value) => {
              row.checked = $$value;
              $$settled = false;
            }
          }, {})}
                  </div></td>
                ${each(columns2, (_a) => {
            var _b = _a, { key } = _b, column = __objRest(_b, ["key"]);
            return `<td${add_attribute("class", cellClasses$2, 0)}>${(column == null ? void 0 : column.type) === "checkbox" ? `<div class="${"flex justify-center"}">${validate_component(Checkbox, "Checkbox").$$render($$result, {}, {}, {})}
                      </div>` : `${escape2(row[key])}`}
                  </td>`;
          })}
              </tr>`)}</tbody>`,
          thead: () => `<thead slot="${"thead"}"><th class="${escape2(cellClasses$2) + " w-[24px]"}">Completed</th>
            ${each(columns2, ({ title }) => `<th${add_attribute("class", cellClasses$2, 0)}>${escape2(title)}</th>`)}</thead>`
        })}` : ``}` : `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`}`
      })}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var index$9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Training_checklist
});
var cellClasses$1 = "p-[10px]";
var Role_requirements = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let checkedRows;
  let checked;
  let indeterminate;
  let roleChanged;
  const getRoles = async () => {
    const data = await serverFetch(`/api/datatable/roles?sort=${JSON.stringify({ name: 1 })}`);
    roles = [
      { label: "Select a Role", value: "" },
      ...data.rows.map((row) => {
        return { label: row.name, value: row._id };
      })
    ];
  };
  const getSafetyTypes = async () => {
    const data = await serverFetch(`/api/datatable/safety-types?sort=${JSON.stringify({ name: 1 })}`);
    safetyItems = data.rows.map((row) => Object.assign({ checked: false }, row));
  };
  let columns2 = [{ title: "Name", key: "name" }];
  let initialSafetyItems = [];
  let loaded = false;
  let roleId = "";
  let roles = [];
  let safetyItems = [];
  onMount(async () => {
    await Promise.all([getRoles(), getSafetyTypes()]);
    loaded = true;
  });
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    checkedRows = [...safetyItems].filter((row) => row.checked);
    checked = checkedRows.length === safetyItems.length;
    indeterminate = checkedRows.length !== 0 && checkedRows.length !== safetyItems.length;
    roleChanged = roleId !== "" && [...safetyItems].filter((row) => row.checked).map((row) => row._id).sort().join(",") !== [...initialSafetyItems].map((row) => row._id).sort().join(",") ? true : false;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, { class: "items-center space-y-[16px]" }, {}, {
        default: () => `${loaded ? `<div class="${"flex justify-between w-full items-center space-x-[16px]"}">${validate_component(Select, "Select").$$render($$result, {
          options: roles,
          class: "flex-grow-0",
          value: roleId
        }, {
          value: ($$value) => {
            roleId = $$value;
            $$settled = false;
          }
        }, {})}
        <div class="${"flex space-x-[8px]"}">${roleChanged ? `<div class="${"flex"}">${validate_component(Icon, "Buttons.Icon").$$render($$result, { theme: "success" }, {}, {
          default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Save, class: "w-[24px] h-[24px]" }, {}, {})}`
        })}</div>` : ``}</div></div>
      ${roleId !== "" ? `${validate_component(Table, "Table").$$render($$result, {}, {}, {
          tbody: () => `<tbody slot="${"tbody"}">${each(safetyItems, (row, i) => `<tr class="${"rounded transition duration-200 bg-white bg-opacity-0 hover:bg-opacity-[2%]"}"><td${add_attribute("class", cellClasses$1, 0)}>${validate_component(Checkbox, "Checkbox").$$render($$result, { checked: row.checked }, {
            checked: ($$value) => {
              row.checked = $$value;
              $$settled = false;
            }
          }, {})}</td>
                ${each(columns2, (_a) => {
            var _b = _a, { key } = _b, column = __objRest(_b, ["key"]);
            return `<td${add_attribute("class", cellClasses$1, 0)}>${(column == null ? void 0 : column.type) === "checkbox" ? `<div class="${"flex justify-center"}">${validate_component(Checkbox, "Checkbox").$$render($$result, { checked: row[key] }, {
              checked: ($$value) => {
                row[key] = $$value;
                $$settled = false;
              }
            }, {})}
                      </div>` : `${escape2(row[key])}`}
                  </td>`;
          })}
              </tr>`)}</tbody>`,
          thead: () => `<thead slot="${"thead"}"><th class="${escape2(cellClasses$1) + " w-[24px]"}">${validate_component(Checkbox, "Checkbox").$$render($$result, { checked, indeterminate }, {
            checked: ($$value) => {
              checked = $$value;
              $$settled = false;
            },
            indeterminate: ($$value) => {
              indeterminate = $$value;
              $$settled = false;
            }
          }, {})}</th>
            ${each(columns2, (_a) => {
            var _b = _a, { title } = _b, column = __objRest(_b, ["title"]);
            return `<th class="${escape2(cellClasses$1) + " " + escape2((column == null ? void 0 : column.type) === "checkbox" ? "w-[24px]" : "")}">${escape2(title)}</th>`;
          })}</thead>`
        })}` : ``}` : `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`}`
      })}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var index$8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Role_requirements
});
var frequencyOptions = [
  { label: `Annually`, value: "Annually" },
  { label: `At Hire`, value: "At Hire" }
];
var monthOptions = [...Array(12).keys()].map((_, i) => {
  const date = new Date(2012, i, 1);
  return { label: `${date.toLocaleString("default", { month: "long" })}`, value: i };
});
var columns$1 = [
  { title: "Name", key: "name" },
  { title: "Frequency", key: "frequency", type: "select", options: frequencyOptions },
  { title: "Month", key: "month", type: "select", options: monthOptions }
];
var Types = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const datatable2 = {
    collection: "safety-types",
    columns: columns$1,
    deleteModalFN: (row) => `"${row.name}"`,
    editable: true,
    sort: { name: 1 }
  };
  return `${validate_component(Section, "Section").$$render($$result, { class: "space-y-[16px]" }, {}, {
    default: () => `${validate_component(Datatable, "Datatable").$$render($$result, Object.assign(datatable2), {}, {})}`
  })}`;
});
var index$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Types
});
async function load$3({ page: page2 }) {
  let { query } = page2;
  query = Object.fromEntries(query);
  return { props: { query } };
}
var Edit$2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const getRoute = async () => {
    const data = await serverFetch(`/api/datatable/safety-types?_id=${query._id}`);
    Object.keys(body).forEach((key) => {
      body[key] = key in data.rows[0] ? data.rows[0][key] : "";
    });
  };
  let body = [...columns$1].reduce((obj, column) => {
    obj[column.key] = column.type === "select" ? column.options[0].value : "";
    return obj;
  }, {});
  let loaded = false;
  let { query } = $$props;
  onMount(async () => {
    await Promise.all([getRoute()]);
    loaded = true;
  });
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  ${loaded ? `<form class="${"flex flex-col mt-[24px] space-y-[16px]"}">${each(columns$1, (_a) => {
        var _b = _a, { key } = _b, column = __objRest(_b, ["key"]);
        return `${"type" in column ? `${validate_component(Select, "Select").$$render($$result, {
          label: key,
          options: column.options,
          value: body[key]
        }, {
          value: ($$value) => {
            body[key] = $$value;
            $$settled = false;
          }
        }, {})}` : `${validate_component(Input, "Input").$$render($$result, {
          label: key,
          placeholder: key,
          value: body[key]
        }, {
          value: ($$value) => {
            body[key] = $$value;
            $$settled = false;
          }
        }, {})}`}`;
      })}
      ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Save` })}</form>` : `${validate_component(Card, "Card").$$render($$result, {}, {}, {
        default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
      })}`}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var edit$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Edit$2,
  load: load$3
});
var Add$3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let body = [...columns$1].reduce((obj, column) => {
    obj[column.key] = column.type === "select" ? column.options[0].value : "";
    return obj;
  }, {});
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    {
      if (body.frequency === "At Hire")
        body.month = "";
    }
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  <form class="${"flex flex-col mt-[24px] space-y-[16px] max-w-[500px] w-full mx-auto"}">${each(columns$1, (_a) => {
        var _b = _a, { key, title } = _b, column = __objRest(_b, ["key", "title"]);
        return `${"type" in column ? `${title === "Month" && body.frequency !== "At Hire" || title !== "Month" ? `${validate_component(Select, "Select").$$render($$result, {
          label: title,
          options: column.options,
          value: body[key]
        }, {
          value: ($$value) => {
            body[key] = $$value;
            $$settled = false;
          }
        }, {})}` : ``}` : `${validate_component(Input, "Input").$$render($$result, {
          label: title,
          placeholder: title,
          value: body[key]
        }, {
          value: ($$value) => {
            body[key] = $$value;
            $$settled = false;
          }
        }, {})}`}`;
      })}
    ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Add` })}</form>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var add$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Add$3
});
var _layout_reset$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${$$result.head += `<meta name="${"description"}" content="${"Employee Online Portal - Allen-Bailey Tag & Label"}" data-svelte="svelte-1hdaj2x"><meta name="${"theme-color"}" content="${"#fff"}" data-svelte="svelte-1hdaj2x">`, ""}

<main class="${"relative bg-gradient-to-br from-gray-500 to-gray-800 min-h-screen text-gray-100 flex flex-col"}">${slots.default ? slots.default({}) : ``}
  ${validate_component(Modal_1$2, "Modal.Error").$$render($$result, {}, {}, {})}
  ${validate_component(Modal_1$1, "Modal.Spinner").$$render($$result, {}, {}, {})}</main>`;
});
var __layout_reset$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout_reset$1
});
var Signin = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let email = "";
  let password = "";
  let loaded = false;
  onMount(() => loaded = true);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${$$result.head += `${$$result.title = `<title>Signin - Employee Online Portal - Allen-Bailey Tag &amp; Label</title>`, ""}`, ""}

${validate_component(Section, "Section").$$render($$result, {
      padding: "",
      class: "relative flex-grow justify-center"
    }, {}, {
      default: () => `${validate_component(Container, "Container").$$render($$result, { class: "flex justify-center" }, {}, {
        default: () => `${loaded ? `${validate_component(Card, "Card").$$render($$result, { class: "max-w-[500px] w-full" }, {}, {
          default: () => `<form class="${"flex flex-col space-y-[36px]"}"><div class="${"font-bold text-[36px]"}">Sign In</div>
          <div class="${"flex flex-col space-y-[16px]"}">${validate_component(Input, "Input").$$render($$result, {
            label: "Email",
            name: "email",
            type: "email",
            placeholder: "Email",
            value: email
          }, {
            value: ($$value) => {
              email = $$value;
              $$settled = false;
            }
          }, {})}
            ${validate_component(Input, "Input").$$render($$result, {
            label: "Password",
            name: "password",
            type: "password",
            placeholder: "Password",
            value: password
          }, {
            value: ($$value) => {
              password = $$value;
              $$settled = false;
            }
          }, {})}</div>
          ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Sign In` })}</form>`
        })}` : `${validate_component(Card, "Card").$$render($$result, {}, {}, {
          default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
        })}`}`
      })}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var index$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Signin
});
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const datatable2 = {
    collection: "routes",
    columns: [
      { title: "Group", key: "group" },
      { title: "Name", key: "name" },
      { title: "Route", key: "href" }
    ],
    deleteModalFN: (row) => `"${"group" in row ? row.group + " - " : ""}${row.name}"`,
    editable: true,
    sort: { group: 1, name: 1 }
  };
  return `${validate_component(Section, "Section").$$render($$result, { class: "space-y-[16px]" }, {}, {
    default: () => `${validate_component(Datatable, "Datatable").$$render($$result, Object.assign(datatable2), {}, {})}`
  })}`;
});
var index$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
async function load$2({ page: page2 }) {
  let { query } = page2;
  query = Object.fromEntries(query);
  return { props: { query } };
}
var Edit$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const getRoute = async () => {
    const data = await serverFetch(`/api/datatable/routes?_id=${query._id}`);
    delete data.rows[0]._id;
    body = data.rows[0];
  };
  let body = { group: "", name: "", href: "" };
  let loaded = false;
  let { query } = $$props;
  onMount(async () => {
    await Promise.all([getRoute()]);
    loaded = true;
  });
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  ${loaded ? `<form class="${"flex flex-col mt-[24px] space-y-[16px]"}">${each(Object.keys(body), (key) => `${validate_component(Input, "Input").$$render($$result, {
        label: key,
        placeholder: key,
        value: body[key]
      }, {
        value: ($$value) => {
          body[key] = $$value;
          $$settled = false;
        }
      }, {})}`)}
      ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Save` })}</form>` : `${validate_component(Card, "Card").$$render($$result, {}, {}, {
        default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
      })}`}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var edit$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Edit$1,
  load: load$2
});
var Add$2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let body = { group: "", name: "", href: "" };
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  <form class="${"flex flex-col mt-[24px] space-y-[16px] max-w-[500px] w-full mx-auto"}">${each(Object.keys(body), (key) => `${validate_component(Input, "Input").$$render($$result, {
        label: key,
        placeholder: key,
        value: body[key]
      }, {
        value: ($$value) => {
          body[key] = $$value;
          $$settled = false;
        }
      }, {})}`)}
    ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Add` })}</form>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var add$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Add$2
});
var cellClasses = "p-[10px]";
var Roles = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let checkedRows;
  let checked;
  let indeterminate;
  let showDelete;
  let roleChanged;
  const getRoutes2 = async () => {
    const data = await serverFetch(`/api/datatable/routes`);
    rows = data.rows.map((row) => Object.assign({ checked: false }, row));
  };
  const getRoles = async () => {
    const data = await serverFetch("/api/datatable/roles");
    roleOptions = [
      { value: "", label: "Select a Role" },
      ...data.rows.map((role) => {
        return __spreadValues({
          value: role._id,
          label: role.name
        }, role);
      })
    ];
  };
  let { columns: columns2 = [
    { title: "Group", key: "group" },
    { title: "Name", key: "name" },
    { title: "Route", key: "href" }
  ] } = $$props;
  let loaded = false;
  let initialRoutes = [];
  let roleOptions = [];
  let roleId = "";
  let rows = [];
  onMount(async () => {
    await Promise.all([getRoutes2(), getRoles()]);
    loaded = true;
  });
  if ($$props.columns === void 0 && $$bindings.columns && columns2 !== void 0)
    $$bindings.columns(columns2);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    checkedRows = [...rows].filter((row) => row.checked);
    checked = checkedRows.length === rows.length;
    indeterminate = checkedRows.length !== 0 && checkedRows.length !== rows.length;
    showDelete = roleId !== "" ? true : false;
    roleChanged = roleId !== "" && [...rows].filter((row) => row.checked).map((row) => row._id).sort().join(",") !== [...initialRoutes].map((row) => row._id).sort().join(",") ? true : false;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, { class: "space-y-[16px]" }, {}, {
      default: () => `${validate_component(Card, "Card").$$render($$result, { class: "items-center space-y-[16px]" }, {}, {
        default: () => `${!loaded ? `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}` : `<div class="${"flex justify-between w-full items-center space-x-[16px]"}">${validate_component(Select, "Select").$$render($$result, {
          options: roleOptions,
          class: "flex-grow-0",
          value: roleId
        }, {
          value: ($$value) => {
            roleId = $$value;
            $$settled = false;
          }
        }, {})}
        <div class="${"flex justify-end"}"><div class="${"flex space-x-[8px]"}">${roleChanged ? `<div class="${"flex"}">${validate_component(Icon, "Buttons.Icon").$$render($$result, { theme: "success" }, {}, {
          default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Save, class: "w-[24px] h-[24px]" }, {}, {})}`
        })}</div>` : ``}
            ${showDelete ? `<div class="${"flex"}">${validate_component(Icon, "Buttons.Icon").$$render($$result, { theme: "error" }, {}, {
          default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Trash, class: "w-[24px] h-[24px]" }, {}, {})}`
        })}</div>` : ``}
            ${validate_component(Icon, "Buttons.Icon").$$render($$result, { type: "link", href: `./roles/add` }, {}, {
          default: () => `${validate_component(Icon$1, "Icon").$$render($$result, { src: Plus, class: "w-[24px] h-[24px]" }, {}, {})}`
        })}</div></div></div>
      ${roleId !== "" ? `<table class="${"w-full"}"><thead><th class="${escape2(cellClasses) + " w-[24px]"}">${validate_component(Checkbox, "Checkbox").$$render($$result, { checked, indeterminate }, {
          checked: ($$value) => {
            checked = $$value;
            $$settled = false;
          },
          indeterminate: ($$value) => {
            indeterminate = $$value;
            $$settled = false;
          }
        }, {})}</th>
            ${each(columns2, ({ title }) => `<th${add_attribute("class", cellClasses, 0)}>${escape2(title)}</th>`)}</thead>
          <tbody>${each(rows, (row) => `<tr${add_attribute("id", row._id, 0)}><td${add_attribute("class", cellClasses, 0)}>${validate_component(Checkbox, "Checkbox").$$render($$result, { checked: row.checked }, {
          checked: ($$value) => {
            row.checked = $$value;
            $$settled = false;
          }
        }, {})}</td>
                ${each(columns2, ({ key }) => `<td${add_attribute("class", cellClasses, 0)}>${escape2(key in row ? row[key] : "")}</td>`)}
              </tr>`)}</tbody></table>` : ``}`}`
      })}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Roles
});
var Add$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let body = { name: "" };
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  <form class="${"flex flex-col mt-[24px] space-y-[16px] max-w-[500px] w-full mx-auto"}">${each(Object.keys(body), (key) => `${validate_component(Input, "Input").$$render($$result, {
        label: key,
        placeholder: key,
        value: body[key]
      }, {
        value: ($$value) => {
          body[key] = $$value;
          $$settled = false;
        }
      }, {})}`)}
    ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Add` })}</form>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var add$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Add$1
});
var columns = [
  { title: "First Name", key: "firstName" },
  { title: "Last Name", key: "lastName" },
  { title: "Email", key: "email" },
  { title: "Extension", key: "extension" },
  { title: "Roles", key: "roles", type: "select", multiple: true, placeholder: "Select role(s)" },
  { title: "Status", key: "status", type: "select", multiple: false, placeholder: "Status" }
];
var Management = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const datatable2 = {
    collection: "users",
    columns,
    deleteModalFN: (row) => `"${row.firstName} ${row.lastName}"`,
    editable: true,
    sort: { firstName: 1 }
  };
  return `${validate_component(Section, "Section").$$render($$result, { class: "space-y-[16px]" }, {}, {
    default: () => `${validate_component(Datatable, "Datatable").$$render($$result, Object.assign(datatable2), {}, {})}`
  })}`;
});
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Management
});
async function load$1({ page: page2 }) {
  let { query } = page2;
  query = Object.fromEntries(query);
  return { props: { query } };
}
var Edit = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const getRoles = async () => {
    const data = await serverFetch("/api/datatable/roles");
    selects.roles = data.rows.map((row) => row.name);
  };
  const getUser = async () => {
    const data = await serverFetch(`/api/datatable/users?_id=${query._id}`);
    Object.keys(body).forEach((key) => {
      body[key].value = data.rows[0][key];
    });
  };
  let body = columns.reduce((obj, column) => {
    obj[column.key] = __spreadValues({
      label: column.title,
      value: ""
    }, column);
    return obj;
  }, {});
  let loaded = false;
  let selects = {
    roles: [],
    status: [
      { label: "Active", value: "Active" },
      { label: "Unverified", value: "Unverified" }
    ]
  };
  let { query } = $$props;
  onMount(async () => {
    await Promise.all([getRoles(), getUser()]);
    loaded = true;
  });
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  ${loaded ? `<form class="${"flex flex-col mt-[24px] space-y-[16px] max-w-[500px] w-full mx-auto"}">${each(Object.keys(body), (key) => `${!("type" in body[key]) ? `${validate_component(Input, "Input").$$render($$result, {
        label: body[key].label,
        placeholder: body[key].label,
        value: body[key].value
      }, {
        value: ($$value) => {
          body[key].value = $$value;
          $$settled = false;
        }
      }, {})}` : `${validate_component(Select, "Select").$$render($$result, {
        label: body[key].label,
        multiple: body[key].multiple,
        placeholder: body[key].placeholder,
        options: selects[key],
        value: body[key].value
      }, {
        value: ($$value) => {
          body[key].value = $$value;
          $$settled = false;
        }
      }, {})}`}`)}
      ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Save` })}</form>` : `${validate_component(Card, "Card").$$render($$result, {}, {}, {
        default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
      })}`}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var edit = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Edit,
  load: load$1
});
var Add = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const getRoles = async () => {
    const data = await serverFetch("/api/datatable/roles");
    selects.roles = data.rows.map((row) => row.name);
  };
  let body = columns.reduce((obj, column) => {
    obj[column.key] = __spreadValues({
      label: column.title,
      value: column.key === "status" ? "Unverified" : ""
    }, column);
    return obj;
  }, {});
  let loaded = false;
  let selects = {
    roles: [],
    status: [
      { label: "Active", value: "Active" },
      { label: "Unverified", value: "Unverified" }
    ]
  };
  onMount(async () => {
    await getRoles();
    loaded = true;
  });
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, {}, {}, {
      default: () => `<div class="${"flex"}">${validate_component(Back, "Buttons.Back").$$render($$result, {}, {}, {})}</div>
  ${loaded ? `<form class="${"flex flex-col mt-[24px] space-y-[16px] max-w-[500px] w-full mx-auto"}">${each(Object.keys(body), (key) => `${!("type" in body[key]) ? `${validate_component(Input, "Input").$$render($$result, {
        label: body[key].label,
        placeholder: body[key].label,
        value: body[key].value
      }, {
        value: ($$value) => {
          body[key].value = $$value;
          $$settled = false;
        }
      }, {})}` : `${validate_component(Select, "Select").$$render($$result, {
        label: body[key].label,
        multiple: body[key].multiple,
        placeholder: body[key].placeholder,
        options: selects[key],
        value: body[key].value
      }, {
        value: ($$value) => {
          body[key].value = $$value;
          $$settled = false;
        }
      }, {})}`}`)}
      ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Add` })}</form>` : `${validate_component(Card, "Card").$$render($$result, {}, {}, {
        default: () => `${validate_component(Spinner, "Spinner").$$render($$result, {}, {}, {})}`
      })}`}`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var add = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Add
});
var Directory = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  const datatable2 = {
    collection: "users",
    columns: [...columns].filter((column) => column.key !== "roles"),
    deleteModalFN: (row) => `"${row.firstName} ${row.lastName}"`,
    editable: false,
    sort: { firstName: 1 }
  };
  return `${validate_component(Section, "Section").$$render($$result, { class: "space-y-[16px]" }, {}, {
    default: () => `${validate_component(Datatable, "Datatable").$$render($$result, Object.assign(datatable2), {}, {})}`
  })}`;
});
var index$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Directory
});
var _layout_reset = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${$$result.head += `<meta name="${"description"}" content="${"Employee Online Portal - Allen-Bailey Tag & Label"}" data-svelte="svelte-p3whcm"><meta name="${"theme-color"}" content="${"#fff"}" data-svelte="svelte-p3whcm">${$$result.title = `<title>Verify - Users - Employee Online Portal - Allen-Bailey Tag &amp; Label</title>`, ""}`, ""}

<main class="${"relative bg-gradient-to-br from-gray-500 to-gray-800 min-h-screen text-gray-100 flex flex-col"}">${slots.default ? slots.default({}) : ``}
  ${validate_component(Modal_1$3, "Modal.Confirmation").$$render($$result, {}, {}, {})}
  ${validate_component(Modal_1$2, "Modal.Error").$$render($$result, {}, {}, {})}
  ${validate_component(Modal_1$1, "Modal.Spinner").$$render($$result, {}, {}, {})}
  ${validate_component(Modal_1, "Modal.Success").$$render($$result, {}, {}, {})}</main>`;
});
var __layout_reset = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout_reset
});
async function load({ page: page2 }) {
  let { query } = page2;
  query = Object.fromEntries(query);
  return { props: { query } };
}
var Verify = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { query } = $$props;
  let password = "";
  let passwordConfirm = "";
  onMount(() => {
  });
  if ($$props.query === void 0 && $$bindings.query && query !== void 0)
    $$bindings.query(query);
  let $$settled;
  let $$rendered;
  do {
    $$settled = true;
    $$rendered = `${validate_component(Section, "Section").$$render($$result, { class: "items-center justify-center" }, {}, {
      default: () => `<form class="${"flex flex-col space-y-[16px] max-w-[500px] w-full mx-auto"}">${validate_component(Input, "Input").$$render($$result, {
        label: "Password",
        type: "password",
        placeholder: "Password",
        value: password
      }, {
        value: ($$value) => {
          password = $$value;
          $$settled = false;
        }
      }, {})}
    ${validate_component(Input, "Input").$$render($$result, {
        label: "Password ( retype )",
        type: "password",
        placeholder: "Password ( retype )",
        value: passwordConfirm
      }, {
        value: ($$value) => {
          passwordConfirm = $$value;
          $$settled = false;
        }
      }, {})}
    ${validate_component(Button, "Button").$$render($$result, { type: "submit" }, {}, { default: () => `Change` })}</form>`
    })}`;
  } while (!$$settled);
  return $$rendered;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Verify,
  load
});
var Safety = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return ``;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Safety
});

// .svelte-kit/node/env.js
init_shims();
var host = process.env["HOST"] || "0.0.0.0";
var port = process.env["PORT"] || 3e3;

// .svelte-kit/node/index.js
import require$$0$1, { resolve as resolve2, join, normalize as normalize2, dirname } from "path";
import buffer from "buffer";
import tty from "tty";
import util from "util";
import {
  createReadStream,
  existsSync,
  statSync
} from "fs";
import fs__default, { readdirSync, statSync as statSync2 } from "fs";
import require$$2 from "net";
import zlib2 from "zlib";
import http2 from "http";
import {
  parse
} from "querystring";
import { fileURLToPath } from "url";
function isContentTypeTextual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
function getRawBody(req) {
  return new Promise((fulfil, reject) => {
    const h2 = req.headers;
    if (!h2["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h2["content-length"]);
    if (isNaN(length) && h2["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      const [type] = h2["content-type"].split(/;\s*/);
      if (isContentTypeTextual(type)) {
        const encoding3 = h2["content-encoding"] || "utf-8";
        return fulfil(new TextDecoder(encoding3).decode(data));
      }
      fulfil(data);
    });
  });
}
var charset = preferredCharsets;
var preferredCharsets_1 = preferredCharsets;
var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var charset3 = parseCharset(accepts2[i].trim(), i);
    if (charset3) {
      accepts2[j++] = charset3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match)
    return null;
  var charset3 = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    charset: charset3,
    q,
    i
  };
}
function getCharsetPriority(charset3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(charset3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$3(charset3, spec, index2) {
  var s3 = 0;
  if (spec.charset.toLowerCase() === charset3.toLowerCase()) {
    s3 |= 1;
  } else if (spec.charset !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s3
  };
}
function preferredCharsets(accept, provided) {
  var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
  }
  var priorities = provided.map(function getPriority(type, index2) {
    return getCharsetPriority(type, accepts2, index2);
  });
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$3(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
  return spec.charset;
}
function isQuality$3(spec) {
  return spec.q > 0;
}
charset.preferredCharsets = preferredCharsets_1;
var encoding = preferredEncodings;
var preferredEncodings_1 = preferredEncodings;
var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
  var accepts2 = accept.split(",");
  var hasIdentity = false;
  var minQuality = 1;
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var encoding3 = parseEncoding(accepts2[i].trim(), i);
    if (encoding3) {
      accepts2[j++] = encoding3;
      hasIdentity = hasIdentity || specify$2("identity", encoding3);
      minQuality = Math.min(minQuality, encoding3.q || 1);
    }
  }
  if (!hasIdentity) {
    accepts2[j++] = {
      encoding: "identity",
      q: minQuality,
      i
    };
  }
  accepts2.length = j;
  return accepts2;
}
function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match)
    return null;
  var encoding3 = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    encoding: encoding3,
    q,
    i
  };
}
function getEncodingPriority(encoding3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(encoding3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$2(encoding3, spec, index2) {
  var s3 = 0;
  if (spec.encoding.toLowerCase() === encoding3.toLowerCase()) {
    s3 |= 1;
  } else if (spec.encoding !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s3
  };
}
function preferredEncodings(accept, provided) {
  var accepts2 = parseAcceptEncoding(accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
  }
  var priorities = provided.map(function getPriority(type, index2) {
    return getEncodingPriority(type, accepts2, index2);
  });
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$2(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
  return spec.encoding;
}
function isQuality$2(spec) {
  return spec.q > 0;
}
encoding.preferredEncodings = preferredEncodings_1;
var language = preferredLanguages;
var preferredLanguages_1 = preferredLanguages;
var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var language3 = parseLanguage(accepts2[i].trim(), i);
    if (language3) {
      accepts2[j++] = language3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match)
    return null;
  var prefix = match[1], suffix = match[2], full = prefix;
  if (suffix)
    full += "-" + suffix;
  var q = 1;
  if (match[3]) {
    var params = match[3].split(";");
    for (var j = 0; j < params.length; j++) {
      var p = params[j].split("=");
      if (p[0] === "q")
        q = parseFloat(p[1]);
    }
  }
  return {
    prefix,
    suffix,
    q,
    i,
    full
  };
}
function getLanguagePriority(language3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(language3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$1(language3, spec, index2) {
  var p = parseLanguage(language3);
  if (!p)
    return null;
  var s3 = 0;
  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s3 |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s3 |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s3 |= 1;
  } else if (spec.full !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s3
  };
}
function preferredLanguages(accept, provided) {
  var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
  }
  var priorities = provided.map(function getPriority(type, index2) {
    return getLanguagePriority(type, accepts2, index2);
  });
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$1(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
  return spec.full;
}
function isQuality$1(spec) {
  return spec.q > 0;
}
language.preferredLanguages = preferredLanguages_1;
var mediaType = preferredMediaTypes;
var preferredMediaTypes_1 = preferredMediaTypes;
var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
  var accepts2 = splitMediaTypes(accept);
  for (var i = 0, j = 0; i < accepts2.length; i++) {
    var mediaType3 = parseMediaType(accepts2[i].trim(), i);
    if (mediaType3) {
      accepts2[j++] = mediaType3;
    }
  }
  accepts2.length = j;
  return accepts2;
}
function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match)
    return null;
  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];
  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);
    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];
      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
      if (key === "q") {
        q = parseFloat(value);
        break;
      }
      params[key] = value;
    }
  }
  return {
    type,
    subtype,
    params,
    q,
    i
  };
}
function getMediaTypePriority(type, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify(type, spec, index2) {
  var p = parseMediaType(type);
  var s3 = 0;
  if (!p) {
    return null;
  }
  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s3 |= 4;
  } else if (spec.type != "*") {
    return null;
  }
  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s3 |= 2;
  } else if (spec.subtype != "*") {
    return null;
  }
  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function(k) {
      return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
    })) {
      s3 |= 1;
    } else {
      return null;
    }
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s3
  };
}
function preferredMediaTypes(accept, provided) {
  var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
  }
  var priorities = provided.map(function getPriority(type, index2) {
    return getMediaTypePriority(type, accepts2, index2);
  });
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType2(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
  return spec.type + "/" + spec.subtype;
}
function isQuality(spec) {
  return spec.q > 0;
}
function quoteCount(string) {
  var count = 0;
  var index2 = 0;
  while ((index2 = string.indexOf('"', index2)) !== -1) {
    count++;
    index2++;
  }
  return count;
}
function splitKeyValuePair(str) {
  var index2 = str.indexOf("=");
  var key;
  var val;
  if (index2 === -1) {
    key = str;
  } else {
    key = str.substr(0, index2);
    val = str.substr(index2 + 1);
  }
  return [key, val];
}
function splitMediaTypes(accept) {
  var accepts2 = accept.split(",");
  for (var i = 1, j = 0; i < accepts2.length; i++) {
    if (quoteCount(accepts2[j]) % 2 == 0) {
      accepts2[++j] = accepts2[i];
    } else {
      accepts2[j] += "," + accepts2[i];
    }
  }
  accepts2.length = j + 1;
  return accepts2;
}
function splitParameters(str) {
  var parameters = str.split(";");
  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ";" + parameters[i];
    }
  }
  parameters.length = j + 1;
  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }
  return parameters;
}
mediaType.preferredMediaTypes = preferredMediaTypes_1;
var modules = Object.create(null);
var negotiator = Negotiator;
var Negotiator_1 = Negotiator;
function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }
  this.request = request;
}
Negotiator.prototype.charset = function charset2(available) {
  var set2 = this.charsets(available);
  return set2 && set2[0];
};
Negotiator.prototype.charsets = function charsets(available) {
  var preferredCharsets2 = loadModule("charset").preferredCharsets;
  return preferredCharsets2(this.request.headers["accept-charset"], available);
};
Negotiator.prototype.encoding = function encoding2(available) {
  var set2 = this.encodings(available);
  return set2 && set2[0];
};
Negotiator.prototype.encodings = function encodings(available) {
  var preferredEncodings2 = loadModule("encoding").preferredEncodings;
  return preferredEncodings2(this.request.headers["accept-encoding"], available);
};
Negotiator.prototype.language = function language2(available) {
  var set2 = this.languages(available);
  return set2 && set2[0];
};
Negotiator.prototype.languages = function languages(available) {
  var preferredLanguages2 = loadModule("language").preferredLanguages;
  return preferredLanguages2(this.request.headers["accept-language"], available);
};
Negotiator.prototype.mediaType = function mediaType2(available) {
  var set2 = this.mediaTypes(available);
  return set2 && set2[0];
};
Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  var preferredMediaTypes2 = loadModule("mediaType").preferredMediaTypes;
  return preferredMediaTypes2(this.request.headers.accept, available);
};
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
function loadModule(moduleName) {
  var module2 = modules[moduleName];
  if (module2 !== void 0) {
    return module2;
  }
  switch (moduleName) {
    case "charset":
      module2 = charset;
      break;
    case "encoding":
      module2 = encoding;
      break;
    case "language":
      module2 = language;
      break;
    case "mediaType":
      module2 = mediaType;
      break;
    default:
      throw new Error("Cannot find module '" + moduleName + "'");
  }
  modules[moduleName] = module2;
  return module2;
}
negotiator.Negotiator = Negotiator_1;
function createCommonjsModule(fn) {
  var module2 = { exports: {} };
  return fn(module2, module2.exports), module2.exports;
}
var require$$0 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana"
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana"
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana"
  },
  "image/avcs": {
    source: "iana"
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
var mimeDb = require$$0;
var mimeTypes = createCommonjsModule(function(module2, exports2) {
  var extname = require$$0$1.extname;
  var EXTRACT_TYPE_REGEXP2 = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset3;
  exports2.charsets = { lookup: charset3 };
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset3(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP2.exec(type);
    var mime = match && mimeDb[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset4 = exports2.charset(mime);
      if (charset4)
        mime += "; charset=" + charset4.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP2.exec(type);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(mimeDb).forEach(function forEachMimeType(type) {
      var mime = mimeDb[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from = preference.indexOf(mimeDb[types2[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type;
      }
    });
  }
});
var accepts = Accepts;
function Accepts(req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req);
  }
  this.headers = req.headers;
  this.negotiator = new negotiator(req);
}
Accepts.prototype.type = Accepts.prototype.types = function(types_) {
  var types2 = types_;
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length);
    for (var i = 0; i < types2.length; i++) {
      types2[i] = arguments[i];
    }
  }
  if (!types2 || types2.length === 0) {
    return this.negotiator.mediaTypes();
  }
  if (!this.headers.accept) {
    return types2[0];
  }
  var mimes = types2.map(extToMime);
  var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first = accepts2[0];
  return first ? types2[mimes.indexOf(first)] : false;
};
Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
  var encodings2 = encodings_;
  if (encodings2 && !Array.isArray(encodings2)) {
    encodings2 = new Array(arguments.length);
    for (var i = 0; i < encodings2.length; i++) {
      encodings2[i] = arguments[i];
    }
  }
  if (!encodings2 || encodings2.length === 0) {
    return this.negotiator.encodings();
  }
  return this.negotiator.encodings(encodings2)[0] || false;
};
Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
  var charsets2 = charsets_;
  if (charsets2 && !Array.isArray(charsets2)) {
    charsets2 = new Array(arguments.length);
    for (var i = 0; i < charsets2.length; i++) {
      charsets2[i] = arguments[i];
    }
  }
  if (!charsets2 || charsets2.length === 0) {
    return this.negotiator.charsets();
  }
  return this.negotiator.charsets(charsets2)[0] || false;
};
Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
  var languages2 = languages_;
  if (languages2 && !Array.isArray(languages2)) {
    languages2 = new Array(arguments.length);
    for (var i = 0; i < languages2.length; i++) {
      languages2[i] = arguments[i];
    }
  }
  if (!languages2 || languages2.length === 0) {
    return this.negotiator.languages();
  }
  return this.negotiator.languages(languages2)[0] || false;
};
function extToMime(type) {
  return type.indexOf("/") === -1 ? mimeTypes.lookup(type) : type;
}
function validMime(type) {
  return typeof type === "string";
}
var safeBuffer = createCommonjsModule(function(module2, exports2) {
  var Buffer2 = buffer.Buffer;
  function copyProps(src3, dst) {
    for (var key in src3) {
      dst[key] = src3[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});
var bytes_1 = bytes;
var format_1 = format2;
var parse_1 = parse$4;
var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
var map = {
  b: 1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: (1 << 30) * 1024
};
var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;
function bytes(value, options2) {
  if (typeof value === "string") {
    return parse$4(value);
  }
  if (typeof value === "number") {
    return format2(value, options2);
  }
  return null;
}
function format2(value, options2) {
  if (!Number.isFinite(value)) {
    return null;
  }
  var mag = Math.abs(value);
  var thousandsSeparator = options2 && options2.thousandsSeparator || "";
  var unitSeparator = options2 && options2.unitSeparator || "";
  var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
  var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
  var unit = options2 && options2.unit || "";
  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.tb) {
      unit = "TB";
    } else if (mag >= map.gb) {
      unit = "GB";
    } else if (mag >= map.mb) {
      unit = "MB";
    } else if (mag >= map.kb) {
      unit = "KB";
    } else {
      unit = "B";
    }
  }
  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);
  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, "$1");
  }
  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }
  return str + unitSeparator + unit;
}
function parse$4(val) {
  if (typeof val === "number" && !isNaN(val)) {
    return val;
  }
  if (typeof val !== "string") {
    return null;
  }
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = "b";
  if (!results) {
    floatValue = parseInt(val, 10);
    unit = "b";
  } else {
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }
  return Math.floor(map[unit] * floatValue);
}
bytes_1.format = format_1;
bytes_1.parse = parse_1;
var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var compressible_1 = compressible;
function compressible(type) {
  if (!type || typeof type !== "string") {
    return false;
  }
  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && match[1].toLowerCase();
  var data = mimeDb[mime];
  if (data && data.compressible !== void 0) {
    return data.compressible;
  }
  return COMPRESSIBLE_TYPE_REGEXP.test(mime) || void 0;
}
var s2 = 1e3;
var m = s2 * 60;
var h = m * 60;
var d2 = h * 24;
var y = d2 * 365.25;
var ms = function(val, options2) {
  options2 = options2 || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse$3(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options2.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse$3(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "days":
    case "day":
    case "d":
      return n * d2;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s2;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  if (ms2 >= d2) {
    return Math.round(ms2 / d2) + "d";
  }
  if (ms2 >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (ms2 >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (ms2 >= s2) {
    return Math.round(ms2 / s2) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  return plural(ms2, d2, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s2, "second") || ms2 + " ms";
}
function plural(ms2, n, name2) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name2;
  }
  return Math.ceil(ms2 / n) + " " + name2 + "s";
}
var debug$1 = createCommonjsModule(function(module2, exports2) {
  exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports2.coerce = coerce;
  exports2.disable = disable;
  exports2.enable = enable;
  exports2.enabled = enabled;
  exports2.humanize = ms;
  exports2.names = [];
  exports2.skips = [];
  exports2.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash2 = 0, i;
    for (i in namespace) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
      hash2 |= 0;
    }
    return exports2.colors[Math.abs(hash2) % exports2.colors.length];
  }
  function createDebug(namespace) {
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports2.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format3) {
        if (match === "%%")
          return match;
        index2++;
        var formatter = exports2.formatters[format3];
        if (typeof formatter === "function") {
          var val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      exports2.formatArgs.call(self2, args);
      var logFn = debug2.log || exports2.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports2.enabled(namespace);
    debug2.useColors = exports2.useColors();
    debug2.color = selectColor(namespace);
    if (typeof exports2.init === "function") {
      exports2.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports2.save(namespaces);
    exports2.names = [];
    exports2.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0; i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports2.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports2.enable("");
  }
  function enabled(name2) {
    var i, len;
    for (i = 0, len = exports2.skips.length; i < len; i++) {
      if (exports2.skips[i].test(name2)) {
        return false;
      }
    }
    for (i = 0, len = exports2.names.length; i < len; i++) {
      if (exports2.names[i].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
});
var browser = createCommonjsModule(function(module2, exports2) {
  exports2 = module2.exports = debug$1;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports2.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports2.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index2 = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index2++;
      if (match === "%c") {
        lastC = index2;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces == null) {
        exports2.storage.removeItem("debug");
      } else {
        exports2.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load2() {
    var r;
    try {
      r = exports2.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  exports2.enable(load2());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
});
var node = createCommonjsModule(function(module2, exports2) {
  exports2 = module2.exports = debug$1;
  exports2.init = init2;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load2;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
  }
  exports2.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports2.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  function formatArgs(args) {
    var name2 = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  [3" + c + ";1m" + name2 + " [0m";
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push("[3" + c + "m+" + exports2.humanize(this.diff) + "[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name2 + " " + args[0];
    }
  }
  function log() {
    return stream.write(util.format.apply(util, arguments) + "\n");
  }
  function save(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  }
  function load2() {
    return process.env.DEBUG;
  }
  function createWritableStdioStream(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs2 = fs__default;
        stream2 = new fs2.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net = require$$2;
        stream2 = new net.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  }
  function init2(debug2) {
    debug2.inspectOpts = {};
    var keys = Object.keys(exports2.inspectOpts);
    for (var i = 0; i < keys.length; i++) {
      debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  exports2.enable(load2());
});
var src2 = createCommonjsModule(function(module2) {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = browser;
  } else {
    module2.exports = node;
  }
});
var onHeaders_1 = onHeaders;
function createWriteHead(prevWriteHead, listener) {
  var fired = false;
  return function writeHead(statusCode) {
    var args = setWriteHeadHeaders.apply(this, arguments);
    if (!fired) {
      fired = true;
      listener.call(this);
      if (typeof args[0] === "number" && this.statusCode !== args[0]) {
        args[0] = this.statusCode;
        args.length = 1;
      }
    }
    return prevWriteHead.apply(this, args);
  };
}
function onHeaders(res, listener) {
  if (!res) {
    throw new TypeError("argument res is required");
  }
  if (typeof listener !== "function") {
    throw new TypeError("argument listener must be a function");
  }
  res.writeHead = createWriteHead(res.writeHead, listener);
}
function setHeadersFromArray(res, headers) {
  for (var i = 0; i < headers.length; i++) {
    res.setHeader(headers[i][0], headers[i][1]);
  }
}
function setHeadersFromObject(res, headers) {
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    if (k)
      res.setHeader(k, headers[k]);
  }
}
function setWriteHeadHeaders(statusCode) {
  var length = arguments.length;
  var headerIndex = length > 1 && typeof arguments[1] === "string" ? 2 : 1;
  var headers = length >= headerIndex + 1 ? arguments[headerIndex] : void 0;
  this.statusCode = statusCode;
  if (Array.isArray(headers)) {
    setHeadersFromArray(this, headers);
  } else if (headers) {
    setHeadersFromObject(this, headers);
  }
  var args = new Array(Math.min(length, headerIndex));
  for (var i = 0; i < args.length; i++) {
    args[i] = arguments[i];
  }
  return args;
}
var vary_1 = vary;
var append_1 = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$2(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$2(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$2(header) {
  var end = 0;
  var list2 = [];
  var start = 0;
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list2.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list2.push(header.substring(start, end));
  return list2;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
vary_1.append = append_1;
var Buffer$1 = safeBuffer.Buffer;
var debug = src2("compression");
var compression_1 = compression;
var filter = shouldCompress;
var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;
function compression(options2) {
  var opts = options2 || {};
  var filter2 = opts.filter || shouldCompress;
  var threshold = bytes_1.parse(opts.threshold);
  if (threshold == null) {
    threshold = 1024;
  }
  return function compression2(req, res, next) {
    var ended = false;
    var length;
    var listeners = [];
    var stream;
    var _end = res.end;
    var _on = res.on;
    var _write = res.write;
    res.flush = function flush() {
      if (stream) {
        stream.flush();
      }
    };
    res.write = function write(chunk, encoding3) {
      if (ended) {
        return false;
      }
      if (!this._header) {
        this._implicitHeader();
      }
      return stream ? stream.write(toBuffer(chunk, encoding3)) : _write.call(this, chunk, encoding3);
    };
    res.end = function end(chunk, encoding3) {
      if (ended) {
        return false;
      }
      if (!this._header) {
        if (!this.getHeader("Content-Length")) {
          length = chunkLength(chunk, encoding3);
        }
        this._implicitHeader();
      }
      if (!stream) {
        return _end.call(this, chunk, encoding3);
      }
      ended = true;
      return chunk ? stream.end(toBuffer(chunk, encoding3)) : stream.end();
    };
    res.on = function on(type, listener) {
      if (!listeners || type !== "drain") {
        return _on.call(this, type, listener);
      }
      if (stream) {
        return stream.on(type, listener);
      }
      listeners.push([type, listener]);
      return this;
    };
    function nocompress(msg) {
      debug("no compression: %s", msg);
      addListeners(res, _on, listeners);
      listeners = null;
    }
    onHeaders_1(res, function onResponseHeaders() {
      if (!filter2(req, res)) {
        nocompress("filtered");
        return;
      }
      if (!shouldTransform(req, res)) {
        nocompress("no transform");
        return;
      }
      vary_1(res, "Accept-Encoding");
      if (Number(res.getHeader("Content-Length")) < threshold || length < threshold) {
        nocompress("size below threshold");
        return;
      }
      var encoding3 = res.getHeader("Content-Encoding") || "identity";
      if (encoding3 !== "identity") {
        nocompress("already encoded");
        return;
      }
      if (req.method === "HEAD") {
        nocompress("HEAD request");
        return;
      }
      var accept = accepts(req);
      var method = accept.encoding(["gzip", "deflate", "identity"]);
      if (method === "deflate" && accept.encoding(["gzip"])) {
        method = accept.encoding(["gzip", "identity"]);
      }
      if (!method || method === "identity") {
        nocompress("not acceptable");
        return;
      }
      debug("%s compression", method);
      stream = method === "gzip" ? zlib2.createGzip(opts) : zlib2.createDeflate(opts);
      addListeners(stream, stream.on, listeners);
      res.setHeader("Content-Encoding", method);
      res.removeHeader("Content-Length");
      stream.on("data", function onStreamData(chunk) {
        if (_write.call(res, chunk) === false) {
          stream.pause();
        }
      });
      stream.on("end", function onStreamEnd() {
        _end.call(res);
      });
      _on.call(res, "drain", function onResponseDrain() {
        stream.resume();
      });
    });
    next();
  };
}
function addListeners(stream, on, listeners) {
  for (var i = 0; i < listeners.length; i++) {
    on.apply(stream, listeners[i]);
  }
}
function chunkLength(chunk, encoding3) {
  if (!chunk) {
    return 0;
  }
  return !Buffer$1.isBuffer(chunk) ? Buffer$1.byteLength(chunk, encoding3) : chunk.length;
}
function shouldCompress(req, res) {
  var type = res.getHeader("Content-Type");
  if (type === void 0 || !compressible_1(type)) {
    debug("%s not compressible", type);
    return false;
  }
  return true;
}
function shouldTransform(req, res) {
  var cacheControl = res.getHeader("Cache-Control");
  return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
}
function toBuffer(chunk, encoding3) {
  return !Buffer$1.isBuffer(chunk) ? Buffer$1.from(chunk, encoding3) : chunk;
}
compression_1.filter = filter;
function parse$1(str, loose) {
  if (str instanceof RegExp)
    return { keys: false, pattern: str };
  var c, o, tmp, ext, keys = [], pattern = "", arr = str.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys.push("wild");
      pattern += "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext)
        pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}
var Trouter = class {
  constructor() {
    this.routes = [];
    this.all = this.add.bind(this, "");
    this.get = this.add.bind(this, "GET");
    this.head = this.add.bind(this, "HEAD");
    this.patch = this.add.bind(this, "PATCH");
    this.options = this.add.bind(this, "OPTIONS");
    this.connect = this.add.bind(this, "CONNECT");
    this.delete = this.add.bind(this, "DELETE");
    this.trace = this.add.bind(this, "TRACE");
    this.post = this.add.bind(this, "POST");
    this.put = this.add.bind(this, "PUT");
  }
  use(route, ...fns) {
    let handlers = [].concat.apply([], fns);
    let { keys, pattern } = parse$1(route, true);
    this.routes.push({ keys, pattern, method: "", handlers });
    return this;
  }
  add(method, route, ...fns) {
    let { keys, pattern } = parse$1(route);
    let handlers = [].concat.apply([], fns);
    this.routes.push({ keys, pattern, method, handlers });
    return this;
  }
  find(method, url) {
    let isHEAD = method === "HEAD";
    let i = 0, j = 0, k, tmp, arr = this.routes;
    let matches = [], params = {}, handlers = [];
    for (; i < arr.length; i++) {
      tmp = arr[i];
      if (tmp.method.length === 0 || tmp.method === method || isHEAD && tmp.method === "GET") {
        if (tmp.keys === false) {
          matches = tmp.pattern.exec(url);
          if (matches === null)
            continue;
          if (matches.groups !== void 0)
            for (k in matches.groups)
              params[k] = matches.groups[k];
          tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
        } else if (tmp.keys.length > 0) {
          matches = tmp.pattern.exec(url);
          if (matches === null)
            continue;
          for (j = 0; j < tmp.keys.length; )
            params[tmp.keys[j]] = matches[++j];
          tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
        } else if (tmp.pattern.test(url)) {
          tmp.handlers.length > 1 ? handlers = handlers.concat(tmp.handlers) : handlers.push(tmp.handlers[0]);
        }
      }
    }
    return { params, handlers };
  }
};
function parse2(req, toDecode) {
  let raw = req.url;
  if (raw == null)
    return;
  let prev = req._parsedUrl;
  if (prev && prev.raw === raw)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = parse(search.substring(1));
      }
    }
    if (!!toDecode && !req._decoded) {
      req._decoded = true;
      if (pathname.indexOf("%") !== -1) {
        try {
          pathname = decodeURIComponent(pathname);
        } catch (e) {
        }
      }
    }
  }
  return req._parsedUrl = { pathname, search, query, raw };
}
function onError(err, req, res) {
  let code = res.statusCode = err.code || err.status || 500;
  if (typeof err === "string" || Buffer.isBuffer(err))
    res.end(err);
  else
    res.end(err.message || http2.STATUS_CODES[code]);
}
var mount = (fn) => fn instanceof Polka ? fn.attach : fn;
var Polka = class extends Trouter {
  constructor(opts = {}) {
    super();
    this.parse = parse2;
    this.server = opts.server;
    this.handler = this.handler.bind(this);
    this.onError = opts.onError || onError;
    this.onNoMatch = opts.onNoMatch || this.onError.bind(null, { code: 404 });
    this.attach = (req, res) => setImmediate(this.handler, req, res);
  }
  use(base, ...fns) {
    if (base === "/") {
      super.use(base, fns.map(mount));
    } else if (typeof base === "function" || base instanceof Polka) {
      super.use("/", [base, ...fns].map(mount));
    } else {
      super.use(base, (req, _, next) => {
        if (typeof base === "string") {
          let len = base.length;
          base.startsWith("/") || len++;
          req.url = req.url.substring(len) || "/";
          req.path = req.path.substring(len) || "/";
        } else {
          req.url = req.url.replace(base, "") || "/";
          req.path = req.path.replace(base, "") || "/";
        }
        if (req.url.charAt(0) !== "/") {
          req.url = "/" + req.url;
        }
        next();
      }, fns.map(mount), (req, _, next) => {
        req.path = req._parsedUrl.pathname;
        req.url = req.path + req._parsedUrl.search;
        next();
      });
    }
    return this;
  }
  listen() {
    (this.server = this.server || http2.createServer()).on("request", this.attach);
    this.server.listen.apply(this.server, arguments);
    return this;
  }
  handler(req, res, next) {
    let info = this.parse(req, true);
    let obj = this.find(req.method, req.path = info.pathname);
    req.params = obj.params;
    req.originalUrl = req.originalUrl || req.url;
    req.url = info.pathname + info.search;
    req.query = info.query || {};
    req.search = info.search;
    let i = 0, arr = obj.handlers.concat(this.onNoMatch), len = arr.length;
    let loop = async () => res.finished || i < len && arr[i++](req, res, next);
    (next = next || ((err) => err ? this.onError(err, req, res, next) : loop().catch(next)))();
  }
};
function polka(opts) {
  return new Polka(opts);
}
function list(dir, callback, pre = "") {
  dir = resolve2(".", dir);
  let arr = readdirSync(dir);
  let i = 0, abs, stats;
  for (; i < arr.length; i++) {
    abs = join(dir, arr[i]);
    stats = statSync2(abs);
    stats.isDirectory() ? list(abs, callback, join(pre, arr[i])) : callback(join(pre, arr[i]), abs, stats);
  }
}
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);
  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }
  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && ext in this._types) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }
      this._types[ext] = type;
    }
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
    }
  }
};
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, "").toLowerCase();
  let ext = last.replace(/^.*\./, "").toLowerCase();
  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && this._types[ext] || null;
};
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};
var Mime_1 = Mime;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma", "es"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/mrb-consumer+xml": ["*xdf"], "application/mrb-publish+xml": ["*xdf"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["*xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-error+xml": ["xer"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
var lite = new Mime_1(standard);
var noop3 = () => {
};
function isMatch(uri2, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].test(uri2))
      return true;
  }
}
function toAssume(uri2, extns) {
  let i = 0, x, len = uri2.length - 1;
  if (uri2.charCodeAt(len) === 47) {
    uri2 = uri2.substring(0, len);
  }
  let arr = [], tmp = `${uri2}/index`;
  for (; i < extns.length; i++) {
    x = extns[i] ? `.${extns[i]}` : "";
    if (uri2)
      arr.push(uri2 + x);
    arr.push(tmp + x);
  }
  return arr;
}
function viaCache(cache, uri2, extns) {
  let i = 0, data, arr = toAssume(uri2, extns);
  for (; i < arr.length; i++) {
    if (data = cache[arr[i]])
      return data;
  }
}
function viaLocal(dir, isEtag, uri2, extns) {
  let i = 0, arr = toAssume(uri2, extns);
  let abs, stats, name2, headers;
  for (; i < arr.length; i++) {
    abs = normalize2(join(dir, name2 = arr[i]));
    if (abs.startsWith(dir) && existsSync(abs)) {
      stats = statSync(abs);
      if (stats.isDirectory())
        continue;
      headers = toHeaders(name2, stats, isEtag);
      headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
      return { abs, stats, headers };
    }
  }
}
function is404(req, res) {
  return res.statusCode = 404, res.end();
}
function send(req, res, file, stats, headers) {
  let code = 200, tmp, opts = {};
  headers = __spreadValues({}, headers);
  for (let key in headers) {
    tmp = res.getHeader(key);
    if (tmp)
      headers[key] = tmp;
  }
  if (tmp = res.getHeader("content-type")) {
    headers["Content-Type"] = tmp;
  }
  if (req.headers.range) {
    code = 206;
    let [x, y2] = req.headers.range.replace("bytes=", "").split("-");
    let end = opts.end = parseInt(y2, 10) || stats.size - 1;
    let start = opts.start = parseInt(x, 10) || 0;
    if (start >= stats.size || end >= stats.size) {
      res.setHeader("Content-Range", `bytes */${stats.size}`);
      res.statusCode = 416;
      return res.end();
    }
    headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
    headers["Content-Length"] = end - start + 1;
    headers["Accept-Ranges"] = "bytes";
  }
  res.writeHead(code, headers);
  createReadStream(file, opts).pipe(res);
}
function isEncoding(name2, type, headers) {
  headers["Content-Encoding"] = type;
  headers["Content-Type"] = lite.getType(name2.replace(/\.([^.]*)$/, "")) || "";
}
function toHeaders(name2, stats, isEtag) {
  let headers = {
    "Content-Length": stats.size,
    "Content-Type": lite.getType(name2) || "",
    "Last-Modified": stats.mtime.toUTCString()
  };
  if (isEtag)
    headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
  if (/\.br$/.test(name2))
    isEncoding(name2, "br", headers);
  if (/\.gz$/.test(name2))
    isEncoding(name2, "gzip", headers);
  return headers;
}
function sirv(dir, opts = {}) {
  dir = resolve2(dir || ".");
  let isNotFound = opts.onNoMatch || is404;
  let setHeaders = opts.setHeaders || noop3;
  let extensions = opts.extensions || ["html", "htm"];
  let gzips = opts.gzip && extensions.map((x) => `${x}.gz`).concat("gz");
  let brots = opts.brotli && extensions.map((x) => `${x}.br`).concat("br");
  const FILES = {};
  let fallback = "/";
  let isEtag = !!opts.etag;
  let isSPA = !!opts.single;
  if (typeof opts.single === "string") {
    let idx = opts.single.lastIndexOf(".");
    fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
  }
  let ignores = [];
  if (opts.ignores !== false) {
    ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
    if (opts.dotfiles)
      ignores.push(/\/\.\w/);
    else
      ignores.push(/\/\.well-known/);
    [].concat(opts.ignores || []).forEach((x) => {
      ignores.push(new RegExp(x, "i"));
    });
  }
  let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
  if (cc && opts.immutable)
    cc += ",immutable";
  else if (cc && opts.maxAge === 0)
    cc += ",must-revalidate";
  if (!opts.dev) {
    list(dir, (name2, abs, stats) => {
      if (/\.well-known[\\+\/]/.test(name2))
        ;
      else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name2))
        return;
      let headers = toHeaders(name2, stats, isEtag);
      if (cc)
        headers["Cache-Control"] = cc;
      FILES["/" + name2.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
    });
  }
  let lookup = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
  return function(req, res, next) {
    let extns = [""];
    let val = req.headers["accept-encoding"] || "";
    if (gzips && val.includes("gzip"))
      extns.unshift(...gzips);
    if (brots && /(br|brotli)/i.test(val))
      extns.unshift(...brots);
    extns.push(...extensions);
    let pathname = req.path || parse2(req, true).pathname;
    let data = lookup(pathname, extns) || isSPA && !isMatch(pathname, ignores) && lookup(fallback, extns);
    if (!data)
      return next ? next() : isNotFound(req, res);
    if (isEtag && req.headers["if-none-match"] === data.headers["ETag"]) {
      res.writeHead(304);
      return res.end();
    }
    if (gzips || brots) {
      res.setHeader("Vary", "Accept-Encoding");
    }
    setHeaders(res, pathname, data.stats);
    send(req, res, data.abs, data.stats, data.headers);
  };
}
var __dirname2 = dirname(fileURLToPath(import.meta.url));
var noop_handler = (_req, _res, next) => next();
var paths = {
  assets: join(__dirname2, "/assets"),
  prerendered: join(__dirname2, "/prerendered")
};
function createServer({ render: render2 }) {
  const immutable_path = (pathname) => {
    let app_dir = "_app";
    if (app_dir === "/") {
      return false;
    }
    if (app_dir.startsWith("/")) {
      app_dir = app_dir.slice(1);
    }
    if (app_dir.endsWith("/")) {
      app_dir = app_dir.slice(0, -1);
    }
    return pathname.startsWith(`/${app_dir}/`);
  };
  const prerendered_handler = fs__default.existsSync(paths.prerendered) ? sirv(paths.prerendered, {
    etag: true,
    maxAge: 0,
    gzip: true,
    brotli: true
  }) : noop_handler;
  const assets_handler = fs__default.existsSync(paths.assets) ? sirv(paths.assets, {
    setHeaders: (res, pathname, stats) => {
      if (immutable_path(pathname)) {
        res.setHeader("cache-control", "public, max-age=31536000, immutable");
      }
    },
    gzip: true,
    brotli: true
  }) : noop_handler;
  const server = polka().use(compression_1({ threshold: 0 }), assets_handler, prerendered_handler, async (req, res) => {
    const parsed = new URL(req.url || "", "http://localhost");
    let body;
    try {
      body = await getRawBody(req);
    } catch (err) {
      res.statusCode = err.status || 400;
      return res.end(err.reason || "Invalid request body");
    }
    const rendered = await render2({
      method: req.method,
      headers: req.headers,
      path: parsed.pathname,
      query: parsed.searchParams,
      rawBody: body
    });
    if (rendered) {
      res.writeHead(rendered.status, rendered.headers);
      if (rendered.body)
        res.write(rendered.body);
      res.end();
    } else {
      res.statusCode = 404;
      res.end("Not found");
    }
  });
  return server;
}
init();
var instance = createServer({ render }).listen(port, host, () => {
  console.log(`Listening on ${host}:${port}`);
});
export {
  instance
};
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * compressible
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Jeremiah Senkpiel
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * compression
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * on-headers
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bcrypt.js for details
 */
